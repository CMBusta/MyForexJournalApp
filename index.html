<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Forex Trading Journal (Offline Ready)</title>
    <link rel="stylesheet" href="./output.css" />
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

    <style>
      /* 7. UI and Design Polish: Custom Scrollbar Styles */
      body {
        font-family: "Inter", sans-serif;
        transition: background-color 0.3s, color 0.3s;
      }

      .scrollable-list {
        max-height: 70vh;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #4f46e5 #f5f7fa;
      }

      .scrollable-list::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      .scrollable-list::-webkit-scrollbar-track {
        background: #f5f7fa;
        border-radius: 10px;
      }
      .scrollable-list::-webkit-scrollbar-thumb {
        background: #4f46e5;
        border-radius: 10px;
      }
      .scrollable-list::-webkit-scrollbar-thumb:hover {
        background: #3730a3;
      }

      /* Dark Mode Styles */
      @media (prefers-color-scheme: dark) {
        .dark-mode-text {
          color: white;
        }

        .dark-mode-bg {
          background-color: #1f2937;
        }

        .scrollable-list::-webkit-scrollbar-track {
          background: #1f2937;
        }
        .scrollable-list::-webkit-scrollbar-thumb {
          background: #3b82f6;
        }
        .scrollable-list::-webkit-scrollbar-thumb:hover {
          background: #2563eb;
        }
      }

<<<<<<< HEAD
      /* Splash Screen Styles */
      #splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
=======
      @media (min-width: 1024px) {
        html {
          font-size: 1.1rem;
        }

        .form-section,
        .journal-list-section {
          width: 50% !important;
        }
      }
    </style>
    <style>
      @media (max-width: 767px) {
        html {
          font-size: 0.95rem;
        }

        body {
          padding: 1rem !important;
        }

        .container {
          flex-direction: column !important;
          gap: 1rem !important;
        }

        .form-section,
        .journal-list-section {
          width: 100% !important;
          padding: 1rem !important;
        }

        button {
          padding-top: 0.6rem !important;
          padding-bottom: 0.6rem !important;
          padding-left: 0.9rem !important;
          padding-right: 0.9rem !important;
          font-size: 0.9rem !important;
        }

        input,
        select,
        textarea {
          font-size: 0.9rem !important;
          padding: 0.6rem 0.75rem !important;
        }

        .scrollable-list {
          max-height: 75vh !important;
        }

        #messageModal > div,
        #strategiesModal > div,
        #rawDataModal > div,
        #strategyDbModal > div {
          max-width: 95% !important;
          margin: 0 0.5rem !important;
          padding: 1rem !important;
        }

        h1,
        h2,
        h3 {
          font-size: 1.1rem !important;
        }
      }
    </style>
    <style>
      .journal-list-section {
        width: 100% !important;
      }

      #addEntryModalContent {
        max-height: 90vh;
        overflow-y: auto;
      }
    </style>
    <script src="https://cdn.tailwindcss.com"></script>

    <script>
      tailwind.config = { darkMode: "class" };
    </script>
    <script defer src="./papaparse.min.js"></script>
    <style>
      .entry-strategies {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        justify-content: flex-end;
        align-items: flex-start;
        max-width: 100%;
        overflow: visible;
      }
      .entry-images {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.5rem;
      }

      #strategyColorPicker::-webkit-color-swatch-wrapper {
        padding: 0;
      }
      #strategyColorPicker::-webkit-color-swatch {
        border: none;
        border-radius: 50%;
      }
    </style>
    <style>
      html,
      body {
>>>>>>> a0823573854bb126707a7d2b60927a607b5f1138
        height: 100%;
        background-color: #f3f4f6; /* Light background */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        transition: opacity 0.7s ease-out;
      }

      @media (prefers-color-scheme: dark) {
        #splash-screen {
          background-color: #1f2937; /* Dark background */
        }
      }

      .splash-ring-container {
        position: relative;
        width: 100px;
        height: 100px;
        margin-bottom: 20px;
      }

      .splash-ring {
        fill: transparent;
        stroke: #6366f1; /* Indigo color */
        stroke-width: 5px;
        stroke-dasharray: 283; /* 2 * PI * 45 (r=45 for 90x90 circle) */
        stroke-dashoffset: 283;
        transition: stroke-dashoffset 0.5s ease-out, stroke 0.3s;
      }

      .splash-percent {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: 600;
        font-size: 1.25rem;
        color: #6366f1; /* Indigo color */
      }
    </style>
  </head>

  <body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200">
    <div id="splash-screen">
      <div class="splash-ring-container">
        <svg viewBox="0 0 100 100" class="w-full h-full">
          <circle
            cx="50"
            cy="50"
            r="45"
            stroke="#e5e7eb"
            stroke-width="5"
            fill="none"
          ></circle>
          <circle
            cx="50"
            cy="50"
            r="45"
            id="splash-ring"
            class="splash-ring"
            transform="rotate(-90 50 50)"
            fill="none"
          ></circle>
        </svg>
        <div id="splash-percent" class="splash-percent">0%</div>
      </div>
      <p id="splash-text" class="text-lg font-medium text-gray-700 dark:text-gray-300">
        Loading...
      </p>
    </div>
<<<<<<< HEAD
    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
      <header class="mb-8 flex flex-col sm:flex-row justify-between items-start sm:items-center">
        <h1 class="text-3xl font-bold text-indigo-600 dark:text-indigo-400">
          Forex Trading Journal
        </h1>
        <div class="flex space-x-2 mt-4 sm:mt-0">
=======

    <div class="mt-4 space-y-2">
      <button
        class="w-full py-2 px-4 bg-violet-600 text-white font-semibold rounded-lg shadow-md hover:bg-violet-700 transition duration-300 flex items-center justify-center space-x-2"
        id="strategiesBtn"
      >
        <svg
          class="w-5 h-5"
          fill="currentColor"
          viewbox="0 0 20 20"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            clip-rule="evenodd"
            d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16ZM6.75 9.25a.75.75 0 0 0 0 1.5h6.5a.75.75 0 0 0 0-1.5h-6.5Z"
            fill-rule="evenodd"
          ></path>
        </svg>
        <span class="md:inline">Strategies</span>
      </button>
      <input accept=".csv" class="hidden" id="csvFileInput" type="file" />
      <button
        class="w-full py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 flex items-center justify-center space-x-2"
        id="importCsvBtn"
      >
        <svg
          class="w-5 h-5"
          fill="currentColor"
          viewbox="0 0 20 20"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            clip-rule="evenodd"
            d="M10 2a.75.75 0 0 1 .75.75v10.63l2.47-2.47a.75.75 0 1 1 1.06 1.06l-3.75 3.75a.75.75 0 0 1-1.06 0l-3.75-3.75a.75.75 0 1 1 1.06-1.06l2.47 2.47V2.75A.75.75 0 0 1 10 2Z"
            fill-rule="evenodd"
          ></path>
        </svg>
        <span class="md:inline">Import (CSV)</span>
      </button>
      <!-- ‚úÖ Hidden CSV file input with broader MIME types for Android compatibility -->
      <input
        accept=".csv,text/csv,text/plain,text/comma-separated-values,application/vnd.ms-excel"
        id="csvFileInput"
        style="display: none"
        type="file"
      />
      <script>
        let currentEntries = [];
        let currentStrategies = [];

        window.showMessageModal =
          window.showMessageModal ||
          function (msg, type) {
            alert(`${type ? type.toUpperCase() + ": " : ""}${msg}`);
          };

        const importBtn = document.getElementById("importCsvBtn");
        const csvInput = document.getElementById("csvFileInput");

        if (importBtn && csvInput) {
          importBtn.addEventListener("click", () => csvInput.click());

          csvInput.addEventListener("change", (event) => {
            const file = event.target.files[0];
            if (!file) return;

            console.log("Selected file:", file.name);

            const reader = new FileReader();
            reader.onload = function (e) {
              const csvContent = e.target.result;
              console.log("CSV content loaded.");
              // üîß Add your CSV import logic here
            };
            reader.readAsText(file);
          });
        }
      </script>

      <button
        class="bg-green-600 hover:bg-green-700 text-white font-semibold px-4 py-2 rounded-lg shadow-md transition duration-300 hidden"
        id="backupCsvBtn"
      >
        Backup (CSV)
      </button>
      <button
        class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold px-4 py-2 rounded-lg shadow-md transition duration-300 hidden"
        id="restoreCsvBtn"
      >
        Restore (CSV)
      </button>
      <button
        class="bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2 rounded-lg shadow-md transition duration-300"
        id="backupJsonBtn"
      >
        Backup (JSON)
      </button>
      <button
        class="bg-orange-500 hover:bg-orange-600 text-white font-semibold px-4 py-2 rounded-lg shadow-md transition duration-300"
        id="restoreJsonBtn"
      >
        Restore (JSON)
      </button>
      <input
        type="file"
        id="jsonFileInput"
        accept="application/json"
        style="display: none"
      />

      <button
        class="w-full py-2 px-4 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-800 transition duration-300 flex items-center justify-center space-x-2 dark:bg-gray-600 dark:hover:bg-gray-700"
        id="showDbDataBtn"
      >
        <svg
          class="w-5 h-5"
          fill="currentColor"
          viewbox="0 0 20 20"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            clip-rule="evenodd"
            d="M3.5 2.75A.75.75 0 0 0 2.75 3.5v13a.75.75 0 0 0 .75.75h13a.75.75 0 0 0 .75-.75v-13a.75.75 0 0 0-.75-.75h-13ZM15 4.5H5v11h10V4.5Z"
            fill-rule="evenodd"
          ></path>
          <path
            d="M5.5 8a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1H6a.5.5 0 0 1-.5-.5ZM5.5 11a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5Z"
          ></path>
        </svg>
        <span class="md:inline">Show Raw Data</span>
      </button>
      <!-- <button
        class="w-full py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-300 flex items-center justify-center space-x-2"
        id="strategyDbBtn"
      >
        <svg
          class="w-5 h-5"
          fill="currentColor"
          viewbox="0 0 20 20"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M10 2a8 8 0 100 16 8 8 0 000-16zM9 5h2v5H9V5zm0 6h2v2H9v-2z"
          ></path>
        </svg>
        <span class="md:inline">Manage Strategies (DB)</span>
      </button> -->
      <button
        class="w-full py-2 px-4 bg-gray-400 text-white font-semibold rounded-lg shadow-md hover:bg-gray-500 transition duration-300 hidden"
        id="exportCsvBtn"
      >
        Export CSV (hidden by default)
      </button>
      <button
        class="fixed top-4 right-4 p-3 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-yellow-400 shadow-lg z-30 transition duration-300 hover:scale-105"
        id="darkModeToggle"
      >
        <span class="dark:hidden">üåô</span>
        <span class="hidden dark:inline">‚òÄÔ∏è</span>
      </button>
      <div
        class="container mx-auto p-4 md:p-6 rounded-2xl shadow-xl flex flex-col md:flex-row gap-4 md:gap-8 bg-white dark:bg-gray-900 max-w-7xl"
      >
        <div class="flex justify-center items-center w-full">
          <div
            class="w-full md:w-1/3 p-6 rounded-xl shadow-lg bg-gray-50 dark:bg-gray-800 form-section center"
          >
            <div class="flex items-center justify-center gap-3 mb-6">
              <img
                alt="Forex Journal Logo"
                class="w-14 h-14 rounded-lg shadow-md"
                src="icon.png"
              /><span
                class="text-3xl font-bold text-indigo-700 dark:text-violet-600"
                >Forex Journal</span
              >
            </div>
            <!-- Add Entry Modal (inserted) -->
            <div
              class="fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-black dark:bg-opacity-70 flex items-center justify-center hidden z-50 transition-opacity duration-300 opacity-0"
              id="addEntryModal"
            >
              <div
                class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-3xl w-full mx-4 transform transition-transform duration-300 scale-95"
                id="addEntryModalContent"
              >
                <div class="flex justify-between items-center mb-4">
                  <h2
                    class="text-2xl font-bold text-indigo-700 dark:text-violet-600"
                  >
                    Add Journal Entry
                  </h2>
                  <button
                    class="text-gray-600 dark:text-gray-200 hover:text-gray-900"
                    id="closeAddEntryModalBtn"
                  >
                    ‚úï
                  </button>
                </div>
                <form class="space-y-4" id="journalForm">
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="date"
                      >Date</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="date"
                      name="date"
                      required=""
                      type="date"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="time"
                      >Time (Entry)</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="time"
                      name="time"
                      placeholder="HH:MM or HHMM (e.g., 0445)"
                      required=""
                      type="text"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="pair"
                      >Pair</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="pair"
                      name="pair"
                    >
                      <option value="GBP/USD">GBP/USD</option>
                      <option value="EUR/USD">EUR/USD</option>
                      <option value="USD/JPY">USD/JPY</option>
                      <option value="AUD/USD">AUD/USD</option>
                      <option value="USD/CAD">USD/CAD</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="direction"
                      >Direction</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="direction"
                      name="direction"
                    >
                      <option value="Buy">Buy</option>
                      <option value="Sell">Sell</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="strategyInput"
                      >Strategy</label
                    >
                    <div
                      class="p-3 rounded-lg bg-gray-200 dark:bg-gray-700 grid grid-cols-2 gap-2 md:grid-cols-3"
                      id="indicatorsContainer"
                    ></div>
                    <input
                      class="mt-2 w-full p-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                      id="strategy"
                      name="strategy"
                      placeholder="Select a strategy above"
                      readonly=""
                      type="text"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="timeFrame"
                      >Time Frame</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="timeFrame"
                      name="timeFrame"
                    >
                      <option value="M1">M1</option>
                      <option value="M5">M5</option>
                      <option value="M15">M15</option>
                      <option value="M30">M30</option>
                      <option value="H1">H1</option>
                      <option value="H4">H4</option>
                      <option value="D1">D1</option>
                      <option value="W1">W1</option>
                      <option value="MN">MN</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="entryPrice"
                      >Entry Price</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="entryPrice"
                      name="entryPrice"
                      step="0.00001"
                      type="number"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="slPrice"
                      >SL Price</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="slPrice"
                      name="slPrice"
                      step="0.00001"
                      type="number"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="tpPrice"
                      >TP Price</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="tpPrice"
                      name="tpPrice"
                      step="0.00001"
                      type="number"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="exitPrice"
                      >Exit Price</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="exitPrice"
                      name="exitPrice"
                      step="0.00001"
                      type="number"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="exitReason"
                      >Exit Reason</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="exitReason"
                      name="exitReason"
                    >
                      <option value="TP">TP</option>
                      <option value="SL">SL</option>
                      <option value="Exited Early">Exited Early</option>
                      <option value="Break-Even">Break-Even</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="lotSize"
                      >Lot Size</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="lotSize"
                      name="lotSize"
                      step="0.01"
                      type="number"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="setupGrade"
                      >Setup Grade</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="setupGrade"
                      name="setupGrade"
                    >
                      <option value="A">A</option>
                      <option value="B">B</option>
                      <option value="C">C</option>
                      <option value="D">D</option>
                      <option value="F">F</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="didFollowPlan"
                      >Did I Follow My Plan?</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="didFollowPlan"
                      name="didFollowPlan"
                    >
                      <option value="Yes">Yes</option>
                      <option value="No">No</option>
                      <option value="Some">Some</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="emotionalState"
                      >Emotional State</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="emotionalState"
                      name="emotionalState"
                    >
                      <option value="Calm">Calm</option>
                      <option value="Doubtful">Doubtful</option>
                      <option value="Slightly Confident">
                        Slightly Confident
                      </option>
                      <option value="Confident">Confident</option>
                      <option value="Stressed">Stressed</option>
                      <option value="Excited">Excited</option>
                      <option value="Greedy">Greedy</option>
                      <option value="Fearful">Fearful</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="preTradeImage"
                      >Pre-Trade Screenshot (&lt;1MB)</label
                    >
                    <input
                      accept="image/*"
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="preTradeImage"
                      name="preTradeImage"
                      type="file"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="postTradeImage"
                      >Post-Trade Screenshot (&lt;1MB)</label
                    >
                    <input
                      accept="image/*"
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="postTradeImage"
                      name="postTradeImage"
                      type="file"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="lessonsLearned"
                      >Lessons Learned</label
                    >
                    <textarea
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="lessonsLearned"
                      name="lessonsLearned"
                      rows="3"
                    ></textarea>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="notes"
                      >Notes</label
                    >
                    <textarea
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus;border-indigo-500"
                      id="notes"
                      name="notes"
                      rows="3"
                    ></textarea>
                  </div>
                  <button
                    class="w-full py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 flex items-center justify-center space-x-2"
                    id="submitBtn"
                    type="submit"
                  >
                    <svg
                      class="w-5 h-5"
                      fill="currentColor"
                      id="submitBtnIcon"
                      viewbox="0 0 20 20"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path
                        d="M7.74 3.425a.75.75 0 0 1 .424-.047l7.74 1.72a.75.75 0 0 1 .596.74v.928a1.5 1.5 0 0 1-.806 1.34L14.473 9.42a2.5 2.5 0 0 0-1.282 2.228v.57a.75.75 0 0 1-.364.646L9.67 15.602a3.033 3.033 0 0 1-2.924 0l-3.217-2.31a.75.75 0 0 1-.364-.647v-.57a2.5 2.5 0 0 0-1.282-2.228L.89 7.493a1.5 1.5 0 0 1-.805-1.34V5.118a.75.75 0 0 1 .596-.74l7.74-1.72a.75.75 0 0 1 .424.047Z"
                      ></path>
                    </svg>
                    <span class="md:inline">Add Journal Entry</span>
                  </button>
                </form>
                <div class="mt-4 flex justify-end">
                  <button
                    class="py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 mr-2"
                    id="closeAddEntryModalFooterBtn"
                  >
                    Close
                  </button>
                  <!-- Keep the original submit button inside the form; footer Close only hides modal -->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div
        class="w-full md:w-2/3 p-6 rounded-xl shadow-lg bg-gray-50 dark:bg-gray-800 journal-list-section"
      >
        <h2
          class="text-2xl font-bold text-center text-indigo-700 dark:text-violet-600 mb-6"
        >
          Journal Entries
        </h2>
        <div
          class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6 p-4 border border-gray-200 dark:border-gray-700 rounded-xl bg-white dark:bg-gray-900 shadow-inner"
          id="metricsDashboard"
        ></div>
        <!-- === Strategy Usage List === -->
        <div
          class="space-y-2 p-4 border border-gray-200 dark:border-gray-700 rounded-xl bg-white dark:bg-gray-900 shadow-inner mt-6"
          id="strategyUsageList"
        >
          <h3
            class="text-lg font-bold text-indigo-700 dark:text-violet-600 mb-2"
          >
            Strategy Usage Count
          </h3>
          <div
            class="grid grid-cols-2 sm:grid-cols-3 gap-3"
            id="strategyUsageContent"
          >
            <!-- Strategy count items will be rendered here -->
          </div>
        </div>
        <div
          class="space-y-4 mb-6 p-4 border border-gray-200 dark:border-gray-700 rounded-xl bg-white dark:bg-gray-900 shadow-inner"
        >
          <div class="flex flex-col">
            <div class="mb-4">
              <input
                class="w-full p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark;border-gray-600 focus:ring-indigo-500 focus;border-indigo-500"
                id="filterInput"
                placeholder="Filter by Pair, Strategy, or Trade ID..."
                type="text"
              />
            </div>
            <!-- Date Range Filter -->
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
              <div class="flex flex-col">
                <label
                  class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-1"
                  for="startDate"
                  >From Date &amp; Time</label
                >
                <input
                  class="p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600"
                  id="startDate"
                  type="datetime-local"
                />
              </div>
              <div class="flex flex-col">
                <label
                  class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-1"
                  for="endDate"
                  >To Date &amp; Time</label
                >
                <input
                  class="p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600"
                  id="endDate"
                  type="datetime-local"
                />
              </div>
            </div>
          </div>
          <!-- Pair Filter -->
          <div class="flex flex-col">
            <label
              class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-1"
              for="pairFilter"
              >Pair</label
            >
            <select
              class="p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600"
              id="pairFilter"
            >
              <option value="All">All</option>
              <option value="EUR/USD">EUR/USD</option>
              <option value="GBP/USD">GBP/USD</option>
              <option value="USD/JPY">USD/JPY</option>
              <option value="AUD/USD">AUD/USD</option>
              <option value="USD/CAD">USD/CAD</option>
              <option value="NZD/USD">NZD/USD</option>
              <option value="USD/CHF">USD/CHF</option>
              <option value="XAU/USD">XAU/USD</option>
            </select>
          </div>
          <label
            class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-1"
            >Trade Outcome</label
          >
          <div class="flex space-x-4 justify-between md:justify-start">
            <label class="inline-flex items-center"
              ><input
                checked=""
                class="form-radio text-indigo-600 h-4 w-4"
                name="tradeOutcomeFilter"
                type="radio"
                value="All"
              /><span class="ml-2 text-sm text-gray-700 dark:text-gray-300"
                >All</span
              ></label
            >
            <label class="inline-flex items-center"
              ><input
                class="form-radio text-green-600 h-4 w-4"
                name="tradeOutcomeFilter"
                type="radio"
                value="Win"
              /><span class="ml-2 text-sm text-gray-700 dark:text-gray-300"
                >Winners</span
              ></label
            >
            <label class="inline-flex items-center"
              ><input
                class="form-radio text-red-600 h-4 w-4"
                name="tradeOutcomeFilter"
                type="radio"
                value="Loss"
              /><span class="ml-2 text-sm text-gray-700 dark:text-gray-300"
                >Losers</span
              ></label
            >
            <label class="inline-flex items-center"
              ><input
                class="form-radio text-yellow-600 h-4 w-4"
                name="tradeOutcomeFilter"
                type="radio"
                value="Break-Even"
              /><span class="ml-2 text-sm text-gray-700 dark:text-gray-300"
                >B/E</span
              ></label
            >
          </div>

          <div
            class="text-center text-gray-500 dark:text-gray-400 hidden"
            id="loading"
          >
            Loading...
          </div>

          <div
            class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4 scrollable-list"
            id="journalList"
          ></div>
          <div
            class="hidden text-center text-gray-500 dark:text-gray-400 mt-4"
            id="noEntries"
          >
            No journal entries yet. Add your first one!
          </div>
        </div>
        <div
          class="fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-black dark:bg-opacity-70 flex items-center justify-center hidden z-50"
          id="messageModal"
        >
          <div
            class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm mx-auto"
          >
            <p
              class="text-center text-gray-700 dark:text-gray-300 mb-4"
              id="modalMessage"
            ></p>
            <button
              class="w-full py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition"
              id="modalCloseBtn"
            >
              OK
            </button>
          </div>
        </div>
        <div
          class="fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-black dark:bg-opacity-70 flex items-center justify-center hidden z-50"
          id="strategiesModal"
        >
          <div
            class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-md w-full mx-4"
          >
            <h2
              class="text-2xl font-bold text-center text-violet-700 dark:text-violet-600 mb-4"
            >
              Manage Strategies
            </h2>
            <form class="space-y-4 mb-6" id="strategyForm">
              <div class="flex flex-col">
                <label
                  class="text-sm font-medium text-gray-700 dark:text-gray-300"
                  for="strategyName"
                  >Strategy Name</label
                >
                <input
                  class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-violet-500 focus:border-violet-500"
                  id="strategyName"
                  name="strategyName"
                  required=""
                  type="text"
                />
              </div>
              <div
                class="space-y-4 p-4 border border-gray-200 dark:border-gray-700 rounded-lg bg-gray-100 dark:bg-gray-900"
              >
                <h3
                  class="text-md font-semibold text-gray-700 dark:text-gray-300"
                >
                  Pick Strategy Color
                </h3>
                <label
                  for="strategyColorPicker"
                  class="text-sm font-medium text-gray-700"
                >
                  Color
                </label>
                <input
                  type="color"
                  id="strategyColorPicker"
                  value="#4f46e5"
                  class="w-16 h-16 rounded-full border border-gray-300 shadow-inner cursor-pointer bg-transparent"
                  style="
                    appearance: none;
                    -webkit-appearance: none;
                    padding: 0;
                    border: none;
                    background: none;
                  "
                />
              </div>
              <button
                class="w-full py-2 px-4 bg-violet-600 text-white font-semibold rounded-lg shadow-md hover:bg-violet-700 transition duration-300"
                id="addStrategyBtn"
                type="submit"
              >
                Add Strategy
              </button>
            </form>
            <div
              class="space-y-2 mt-4 max-h-60 overflow-y-auto"
              id="strategiesList"
            ></div>
            <div class="flex justify-end mt-4">
              <button
                class="py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300"
                id="closeStrategiesModalBtn"
              >
                Close
              </button>
            </div>
          </div>
        </div>
        <div
          class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center hidden z-50"
          id="imageModal"
        >
>>>>>>> a0823573854bb126707a7d2b60927a607b5f1138
          <button
            id="exportBtn"
            class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md"
          >
            Export CSV
          </button>
          <button
            id="importBtn"
            class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md"
          >
            Import CSV
          </button>
          <button
            id="deleteAllBtn"
            class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md"
          >
            Clear All Data
          </button>
        </div>
      </header>

      <section
        class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg mb-8"
      >
        <h2 class="text-2xl font-semibold mb-4 text-gray-900 dark:text-gray-100">
          Add New Trade Entry
        </h2>
        <form id="tradeForm" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          <div>
            <label
              for="tradeDate"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Date</label
            >
            <input
              type="date"
              id="tradeDate"
              required
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            />
          </div>

          <div>
            <label
              for="currencyPair"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Currency Pair</label
            >
            <input
              type="text"
              id="currencyPair"
              required
              list="pairSuggestions"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 uppercase dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            />
            <datalist id="pairSuggestions">
              </datalist>
          </div>

          <div>
            <label
              for="strategy"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Strategy</label
            >
            <select
              id="strategy"
              required
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            >
              <option value="">Select a Strategy</option>
              </select>
          </div>

          <div>
            <label
              for="direction"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Direction</label
            >
            <select
              id="direction"
              required
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            >
              <option value="Long">Long</option>
              <option value="Short">Short</option>
            </select>
          </div>

          <div>
            <label
              for="result"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Result</label
            >
            <select
              id="result"
              required
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            >
              <option value="Win">Win</option>
              <option value="Loss">Loss</option>
              <option value="Break Even">Break Even</option>
            </select>
          </div>

          <div>
            <label
              for="pips"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Pips Gained/Lost (Optional)</label
            >
            <input
              type="number"
              id="pips"
              step="0.1"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            />
          </div>

          <div class="md:col-span-2 lg:col-span-3">
            <label
              for="imageFile"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Trade Screenshot (Optional)</label
            >
            <input
              type="file"
              id="imageFile"
              accept="image/*"
              class="mt-1 block w-full text-sm text-gray-500 dark:text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 dark:file:bg-gray-700 dark:file:text-indigo-400 dark:file:hover:bg-gray-600"
            />
            <div id="imagePreviewContainer" class="mt-2 hidden">
              <img id="imagePreview" class="w-24 h-24 object-cover rounded-md" alt="Trade Screenshot Preview" />
              <button type="button" id="clearImageBtn" class="mt-1 text-xs text-red-500 hover:text-red-700">Remove Image</button>
            </div>
            <input type="hidden" id="imageData" />
          </div>

          <div class="md:col-span-2 lg:col-span-3">
            <label
              for="notes"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Notes (Optional)</label
            >
            <textarea
              id="notes"
              rows="3"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            ></textarea>
          </div>

          <input type="hidden" id="entryId" />

          <div class="md:col-span-2 lg:col-span-3 pt-4 flex space-x-4">
            <button
              type="submit"
              class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-lg"
            >
              Save Trade
            </button>
            <button
              type="button"
              id="cancelEditBtn"
              class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-lg hidden"
            >
              Cancel Edit
            </button>
          </div>
        </form>
      </section>

      <section
        id="strategy-section"
        class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg mb-8"
      >
        <h2 class="text-2xl font-semibold mb-4 text-gray-900 dark:text-gray-100">
          Strategy Management
        </h2>
        <form id="strategyForm" class="flex space-x-4 mb-4">
          <input
            type="text"
            id="strategyName"
            placeholder="New Strategy Name (e.g., London Breakout)"
            required
            class="flex-1 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
          />
          <button
            type="submit"
            class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md"
          >
            Add Strategy
          </button>
        </form>
        <ul
          id="strategyList"
          class="space-y-2 scrollable-list p-2 border border-gray-200 dark:border-gray-700 rounded-lg max-h-48 overflow-y-auto"
        >
          </ul>
      </section>

      <section
        class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg"
      >
        <h2 class="text-2xl font-semibold mb-4 text-gray-900 dark:text-gray-100">
          Journal Entries
        </h2>
        <div class="mb-4">
          <input
            type="text"
            id="filterText"
            placeholder="Filter by Pair, Strategy, or Notes..."
            class="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
          />
        </div>
        <div id="entriesList" class="space-y-4 scrollable-list p-2">
          </div>
      </section>

      <div
        id="toast"
        class="fixed bottom-4 right-4 bg-indigo-600 text-white p-3 rounded-lg shadow-xl hidden transition-opacity duration-300"
      >
        Trade saved successfully!
      </div>
<<<<<<< HEAD
=======
      <!-- Chart.js and Data Labels Plugin -->
      <script>
        let dbInstance = null;

        /* === Consolidated fixed app JS (preserves original GUI structure) === */

        (function () {
          // DOM refs used in original HTML
          const journalForm = document.getElementById("journalForm");
          const journalList = document.getElementById("journalList");
          const loadingDiv = document.getElementById("loading");
          const noEntriesDiv = document.getElementById("noEntries");
          const submitBtn = document.getElementById("submitBtn");
          const submitBtnIcon = document.getElementById("submitBtnIcon");
          const strategiesBtn = document.getElementById("strategiesBtn");
          const strategiesModal = document.getElementById("strategiesModal");
          const closeStrategiesModalBtn = document.getElementById(
            "closeStrategiesModalBtn"
          );
          // === Strategies Modal Handling ===
          document.addEventListener("DOMContentLoaded", () => {
            const strategiesBtn = document.getElementById("strategiesBtn");
            const strategiesModal = document.getElementById("strategiesModal");
            const closeStrategiesModalBtn = document.getElementById(
              "closeStrategiesModalBtn"
            );

            if (strategiesBtn && strategiesModal && closeStrategiesModalBtn) {
              strategiesBtn.addEventListener("click", () => {
                strategiesModal.classList.remove("hidden");
              });

              closeStrategiesModalBtn.addEventListener("click", () => {
                strategiesModal.classList.add("hidden");
              });
            }
          });

          const strategyForm = document.getElementById("strategyForm");
          const strategiesList = document.getElementById("strategiesList");
          const strategyNameInput = document.getElementById("strategyName");
          const addStrategyBtn = document.getElementById("addStrategyBtn");
          const importCsvBtn = document.getElementById("importCsvBtn");
          const csvFileInput = document.getElementById("csvFileInput");
          const showDbDataBtn = document.getElementById("showDbDataBtn");
          const rawDataModal = document.getElementById("rawDataModal");
          const rawEntriesPre = document.getElementById("rawEntriesPre");
          const rawStrategiesPre = document.getElementById("rawStrategiesPre");
          const closeRawDataModalBtn = document.getElementById(
            "closeRawDataModalBtn"
          );
          const metricsDashboard = document.getElementById("metricsDashboard");

          const colorSelectorDiv = document.getElementById("colorSelector");
          const shadeSelectorDiv = document.getElementById("shadeSelector");
          const selectedColorBaseInput =
            document.getElementById("selectedColorBase");
          const selectedColorShadeInput =
            document.getElementById("selectedColorShade");
          const preTradeImageInput = document.getElementById("preTradeImage");
          const postTradeImageInput = document.getElementById("postTradeImage");
          const imageModal = document.getElementById("imageModal");
          const closeImageModalBtn =
            document.getElementById("closeImageModalBtn");
          const zoomedImage = document.getElementById("zoomedImage");
          const darkModeToggle = document.getElementById("darkModeToggle");
          const backupJsonBtn = document.getElementById("backupJsonBtn");
          const restoreJsonBtn = document.getElementById("restoreJsonBtn");

          // Some elements may be undefined depending on GUI sections; guard them
          function $(id) {
            return document.getElementById(id);
          }

          // IndexedDB constants
          const DB_NAME = "ForexJournalDB";
          const DB_VERSION = 2;
          const STORE_ENTRIES = "entries";
          const STORE_STRATEGIES = "strategies";

          // let db = null;
          let currentStrategies = [];
          let currentEntries = [];

          // --- IndexedDB helpers ---
          let db = null;

          async function openDB() {
            // ‚úÖ Reuse an already-open database connection
            if (db) return db;

            return new Promise((resolve, reject) => {
              const request = indexedDB.open(DB_NAME, DB_VERSION);

              request.onupgradeneeded = (event) => {
                const dbInstance = event.target.result;

                // Entries store
                if (!dbInstance.objectStoreNames.contains(STORE_ENTRIES)) {
                  const es = dbInstance.createObjectStore(STORE_ENTRIES, {
                    keyPath: "id",
                    autoIncrement: true,
                  });
                  es.createIndex("dateTime", ["date", "time"], {
                    unique: false,
                  });
                }

                // Strategies store
                if (!dbInstance.objectStoreNames.contains(STORE_STRATEGIES)) {
                  dbInstance.createObjectStore(STORE_STRATEGIES, {
                    keyPath: "id",
                  });
                }
              };

              request.onsuccess = (event) => {
                db = event.target.result;

                // ‚úÖ Keep connection open; reopen automatically if it closes
                db.onclose = () => {
                  console.warn("IndexedDB connection closed ‚Äî reopening...");
                  db = null;
                };

                resolve(db);
              };

              request.onerror = (event) => reject(event.target.error);
            });
          }

          function txRequestPromise(req) {
            return new Promise((res, rej) => {
              req.onsuccess = () => res(req.result);
              req.onerror = () => rej(req.error);
            });
          }

          async function putItem(storeName, item) {
            const idb = await openDB();
            const tx = idb.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            return txRequestPromise(store.put(item));
          }
          async function addItem(storeName, item) {
            const idb = await openDB();
            const tx = idb.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            return txRequestPromise(store.add(item));
          }
          async function deleteItem(storeName, key) {
            const idb = await openDB();
            const tx = idb.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            return txRequestPromise(store.delete(key));
          }
          async function getAll(storeName) {
            const idb = await openDB();
            const tx = idb.transaction(storeName, "readonly");
            const store = tx.objectStore(storeName);
            return txRequestPromise(store.getAll());
          }

          async function getById(storeName, id) {
            const idb = await openDB();
            const tx = idb.transaction(storeName, "readonly");
            const store = tx.objectStore(storeName);
            return new Promise((resolve, reject) => {
              const req = store.get(id);
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            });
          }

          // --- Defaults loader ---
          async function ensureDefaults() {
            let s = await getAll(STORE_STRATEGIES);
            if (!s || s.length === 0) {
              const defaults = [
                {
                  id: 1,
                  name: "Asian Range Breakout",
                  colorClass:
                    "text-indigo-600 bg-indigo-100 dark:bg-indigo-800 dark:text-indigo-300",
                  colorBase: "indigo",
                  colorShade: "600",
                },
                {
                  id: 2,
                  name: "NY Reversal",
                  colorClass:
                    "text-violet-600 bg-violet-100 dark:bg-violet-800 dark:text-violet-300",
                  colorBase: "violet",
                  colorShade: "600",
                },
                {
                  id: 3,
                  name: "Trend Continuation",
                  colorClass:
                    "text-green-600 bg-green-100 dark:bg-green-800 dark:text-green-300",
                  colorBase: "green",
                  colorShade: "600",
                },
              ];
              for (const d of defaults) await putItem(STORE_STRATEGIES, d);
            }
          }

          // --- Loaders ---
          async function loadStrategies() {
            currentStrategies = await getAll(STORE_STRATEGIES);
            renderStrategySelectors();
            renderStrategiesList();
            return currentStrategies;
          }

          async function loadEntries() {
            currentEntries = await getAll(STORE_ENTRIES);
            currentEntries.sort((a, b) => {
              const da = new Date(
                (a.date || "1970-01-01") + "T" + (a.time || "00:00") + ":00"
              );
              const dbd = new Date(
                (b.date || "1970-01-01") + "T" + (b.time || "00:00") + ":00"
              );
              return dbd - da;
            });
            return currentEntries;
          }

          
// Blob safe image resolver
function resolveImageSource(data) {
    if (!data) return "";
    if (typeof data === "string") {
        if (data.startsWith("data:image")) return data;
        return "";
    }
    if (data instanceof Blob) {
        try { return URL.createObjectURL(data); }
        catch(e){ console.warn("Blob preview failed:", e); return ""; }
    }
    return "";
}
// --- UI helpers ---
          function showMessageModal(message, type = "info") {
            const modal = $("messageModal");
            const text = $("modalMessage");
            if (modal && text) {
              text.textContent = message;
              modal.classList.remove("hidden");
              if (type === "success") {
                setTimeout(() => modal.classList.add("hidden"), 2200);
              }
            } else {
              alert(message);
            }
          }
          function hideMessageModal() {
            const m = $("messageModal");
            if (m) m.classList.add("hidden");
          }
          const modalCloseBtn = $("modalCloseBtn");
          if (modalCloseBtn)
            modalCloseBtn.addEventListener("click", hideMessageModal);

          // --- Strategy rendering ---
          function renderStrategySelectors() {
            const container = $("indicatorsContainer");
            if (!container) return;
            container.innerHTML = "";
            const currentValue = $("strategy")
              ? $("strategy").value.trim()
              : "";
            let selectedStrategies = currentValue
              ? currentValue.split(" + ").map((s) => s.trim())
              : [];
            currentStrategies.forEach((s) => {
              const button = document.createElement("button");
              button.type = "button";
              button.className =
                s.colorClass +
                " text-xs font-semibold px-3 py-1 rounded-full shadow-sm hover:opacity-80 transition";
              button.textContent = s.name;
              if (selectedStrategies.includes(s.name)) {
                button.classList.add(
                  "ring-2",
                  "ring-offset-2",
                  "ring-indigo-500",
                  "dark:ring-violet-400"
                );
              }
              button.onclick = () => {
                if (selectedStrategies.includes(s.name)) {
                  selectedStrategies = selectedStrategies.filter(
                    (name) => name !== s.name
                  );
                  button.classList.remove(
                    "ring-2",
                    "ring-offset-2",
                    "ring-indigo-500",
                    "dark:ring-violet-400"
                  );
                } else {
                  selectedStrategies.push(s.name);
                  button.classList.add(
                    "ring-2",
                    "ring-offset-2",
                    "ring-indigo-500",
                    "dark:ring-violet-400"
                  );
                }
                if ($("strategy"))
                  $("strategy").value = selectedStrategies.join(" + ");
              };
              container.appendChild(button);
            });
          }

          function renderStrategiesList() {
            const list = document.getElementById("strategiesList");
            if (!list) return;
            list.innerHTML = "";

            if (!currentStrategies || currentStrategies.length === 0) {
              list.innerHTML =
                '<p class="text-sm text-gray-500">No strategies defined.</p>';
              return;
            }

            currentStrategies.forEach((s) => {
              const div = document.createElement("div");
              div.className =
                "flex items-center justify-between p-2 border rounded-md bg-gray-50 dark:bg-gray-800";

              // üß© note the updated data-action="edit-strategy"
              div.innerHTML = `
      <div>
        <span class="px-2 py-1 rounded text-xs" style="background:${
          s.colorHex || "#4f46e5"
        }; color:white">${s.name}</span>
      </div>
      <div class="flex gap-2">
        <button class="text-sm text-indigo-600" 
                data-id="${s.id}" 
                data-action="edit-strategy">
          Edit
        </button>
        <button class="text-sm text-red-600" 
                data-id="${s.id}" 
                data-action="del">
          Delete
        </button>
      </div>
    `;

              list.appendChild(div);
            });

            // Attach event listeners to the buttons
            list.querySelectorAll("button").forEach((btn) => {
              btn.addEventListener("click", async (ev) => {
                ev.stopPropagation(); // prevent overlap with other click handlers
                const id = parseInt(btn.dataset.id);
                const action = btn.dataset.action;

                if (action === "del") {
                  if (!confirm("Delete strategy?")) return;
                  await deleteItem(STORE_STRATEGIES, id);
                  await loadStrategies();
                  showMessageModal("Strategy deleted", "success");
                }
                // üß© note: changed from "edit" ‚Üí "edit-strategy"
                else if (action === "edit-strategy") {
                  const s = await getById(STORE_STRATEGIES, id);
                  if (!s) return;

                  // Fill in form fields
                  strategyNameInput.value = s.name;

                  const colorPicker = document.getElementById(
                    "strategyColorPicker"
                  );
                  if (s.colorHex) {
                    colorPicker.value = s.colorHex;
                  } else {
                    colorPicker.value = "#4f46e5";
                  }

                  // Update the submit button to show ‚ÄúUpdate Strategy‚Äù
                  addStrategyBtn.textContent = "Update Strategy";

                  // Mark the form as editing mode
                  strategyForm.dataset.editingId = s.id;
                }
              });
            });
          }

          strategyForm.addEventListener("submit", async (ev) => {
            ev.preventDefault();

            const name = document.getElementById("strategyName").value.trim();
            const colorHex = document.getElementById(
              "strategyColorPicker"
            ).value;
            const addStrategyBtn = document.getElementById("addStrategyBtn");

            if (!name) return;

            // --- EDIT MODE ---
            if (strategyForm.dataset.editingId) {
              const id = parseInt(strategyForm.dataset.editingId);
              const existing = currentStrategies.find((x) => x.id === id);
              if (existing) {
                existing.name = name;
                existing.colorHex = colorHex;
                await putItem(STORE_STRATEGIES, existing);
              }
              delete strategyForm.dataset.editingId;
              addStrategyBtn.textContent = "Add Strategy";
              showMessageModal("Strategy updated successfully!", "success");
            }
            // --- ADD MODE ---
            else {
              const newStrategy = {
                id: Date.now(),
                name,
                colorHex,
              };
              await addItem(STORE_STRATEGIES, newStrategy);
              showMessageModal("Strategy added successfully!", "success");
            }

            // Refresh + reset
            await loadStrategies();
            strategyForm.reset();
            document.getElementById("strategyColorPicker").value = "#4f46e5";
          });

          // --- Entries rendering ---

          function createStrategyChips(entry) {
            if (!entry || !entry.strategy) return "";
            const names = entry.strategy
              .split(/\s*\+\s*/)
              .map((x) => x.trim())
              .filter(Boolean);
            const chips = names.map((n) => {
              const s = currentStrategies.find((x) => x.name === n);
              if (s) {
                // Prefer hex color if available (user-created strategies)
                if (s.colorHex) {
                  // use inline background and pick contrasting text (white) for simplicity
                  return `<span style="background:${s.colorHex}; color:white" class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium shadow-sm">${n}</span>`;
                }
                // Fallback to existing Tailwind color classes (defaults)
                if (s.colorClass) {
                  return `<span class="${s.colorClass} inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium">${n}</span>`;
                }
              }
              return `<span class="bg-gray-200 text-gray-800 inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium">${n}</span>`;
            });
            return chips.join(
              ' <span class="text-gray-600 dark:text-gray-400 mx-1">+</span> '
            );
          }
          window.showImageModal = function (src) {
            const imgModal = $("imageModal");
            const zoom = $("zoomedImage");
            if (!imgModal || !zoom) return;
            zoom.src = src;
            imgModal.classList.remove("hidden");
          };

          const closeImgBtn = $("closeImageModalBtn");
          if (closeImgBtn)
            closeImgBtn.addEventListener("click", () => {
              const m = $("imageModal");
              if (m) m.classList.add("hidden");
            });

          function renderEntryCard(entry) {
            const outcomeColor =
              entry.outcome === "Win"
                ? "border-green-500"
                : entry.outcome === "Loss"
                ? "border-red-500"
                : "border-yellow-500";
            const outcomeTextColor =
              entry.outcome === "Win"
                ? "text-green-500"
                : entry.outcome === "Loss"
                ? "text-red-500"
                : "text-yellow-500";
            const preSrc = resolveImageSource(entry.preTradeImage);
const postSrc = resolveImageSource(entry.postTradeImage);

const preThumb = preSrc
    ? `<img src="${preSrc}" alt="Pre Trade"
         class="w-20 h-20 object-cover rounded-lg cursor-zoom-in hover:opacity-80 transition"
         onclick="showImageModal('${preSrc}')">`
    : "";

const postThumb = postSrc
    ? `<img src="${postSrc}" alt="Post Trade"
         class="w-20 h-20 object-cover rounded-lg cursor-zoom-in hover:opacity-80 transition"
         onclick="showImageModal('${postSrc}')">`
    : "";

            return `
              <div class="p-4 rounded-xl shadow-lg border-l-4 ${outcomeColor} bg-white dark:bg-gray-900 transition duration-300 hover:shadow-xl">
                <div class="flex justify-between items-start mb-2">
                  <div class="flex flex-col">
                    <h3 class="text-lg font-bold text-gray-900 dark:text-gray-100">${
                      entry.pair
                    }
                      <span class="text-sm font-normal text-gray-500 dark:text-gray-400">(${
                        entry.timeFrame
                      })</span></h3>
                    <p class="text-sm text-gray-500 dark:text-gray-400">${
                      entry.date
                    } at ${entry.time}</p>
                  </div>
                  <div class="text-right">
                    <p class="text-xl font-extrabold ${outcomeTextColor}">${
              entry.rMultiple || "0.00"
            } R</p>
                    <div class="entry-strategies mt-1">${
                      createStrategyChips(entry) ||
                      '<span class="text-gray-500">N/A</span>'
                    }</div>
                  </div>
                </div>
                <div class="entry-images mb-3">
                  ${preThumb}
                  ${postThumb}
                </div>
                <div class="grid grid-cols-2 gap-2 text-sm mb-3 text-gray-700 dark:text-gray-300">
                  <div><span class="font-semibold">Direction:</span>
                      <span class="font-medium ${
                        entry.direction === "Buy"
                          ? "text-green-600"
                          : "text-red-600"
                      }">${entry.direction}</span>
                  </div>
                  <div><span class="font-semibold">Exit:</span> ${
                    entry.exitReason
                  }</div>
                  <div><span class="font-semibold">Entry:</span> ${
                    entry.entryPrice
                  }</div>
                  <div><span class="font-semibold">Exit Price:</span> ${
                    entry.exitPrice
                  }</div>
                </div>
                <details class="trade-details mt-2 border-t pt-3 border-gray-200 dark:border-gray-700">
                  <summary class="cursor-pointer text-sm font-semibold hover:text-indigo-800 dark:hover:text-violet-400 transition">
                    View Details
                  </summary>
                  <div class="mt-3 space-y-2 text-sm text-gray-700 dark:text-gray-300">
                    <p><span class="font-semibold">Stop Loss:</span> ${
                      entry.slPrice
                    } /
                       <span class="font-semibold">Take Profit:</span> ${
                         entry.tpPrice
                       }</p>
                    <p><span class="font-semibold">Lot Size:</span> ${
                      entry.lotSize
                    }</p>
                    <p><span class="font-semibold">Grade:</span> ${
                      entry.setupGrade
                    } /
                       <span class="font-semibold">Follow Plan:</span> ${
                         entry.didFollowPlan
                       }</p>
                    <p><span class="font-semibold">Emotion:</span> ${
                      entry.emotionalState
                    }</p>
                    <p class="mt-2"><span class="font-semibold block mb-1">Lessons Learned:</span>
                       ${entry.lessonsLearned || "N/A"}</p>
                    <p><span class="font-semibold block mb-1">Notes:</span>
                       ${entry.notes || "N/A"}</p>
                  </div>
                </details>
                <div class="flex justify-end space-x-2 mt-4 pt-3 border-t border-gray-200 dark:border-gray-700">
                  <button class="text-indigo-600 hover:text-indigo-800 dark:text-violet-400 dark:hover:text-violet-600 transition text-sm" data-action="edit" data-id="${
                    entry.id
                  }">Edit</button>
                  <button class="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-600 transition text-sm" data-action="delete" data-id="${
                    entry.id
                  }">Delete</button>
                </div>
              </div>
            `;
          }

          async function renderJournalEntries(filteredEntries = null) {
            if (loadingDiv) loadingDiv.classList.remove("hidden");
            if (!filteredEntries) {
              await loadEntries();
              filteredEntries = currentEntries;
            }
            renderMetrics(calculateMetrics(filteredEntries));
            renderStrategyUsage(filteredEntries);

            journalList.innerHTML = "";
            if (!filteredEntries || filteredEntries.length === 0) {
              if (noEntriesDiv) noEntriesDiv.classList.remove("hidden");
            } else {
              if (noEntriesDiv) noEntriesDiv.classList.add("hidden");
              filteredEntries.forEach((entry) => {
                journalList.innerHTML += renderEntryCard(entry);
              });
              // attach edit/delete handlers
              journalList
                .querySelectorAll("button[data-action]")
                .forEach((btn) => {
                  btn.addEventListener("click", async (ev) => {
                    const id = parseInt(btn.dataset.id);
                    const action = btn.dataset.action;
                    if (action === "delete") {
                      if (!confirm("Delete this entry?")) return;
                      await deleteItem(STORE_ENTRIES, id);
                      await loadEntries();
                      await renderJournalEntries();
                      showMessageModal("Entry deleted", "success");
                    } else if (action === "edit") {
                      const entry = await getById(STORE_ENTRIES, id);
                      if (!entry) return;

                      console.log("üìù Editing journal entry:", entry);

                      // ‚úÖ Use your existing modal and form population function
                      populateFormForEdit(entry);
                    }
                  });
                });
            }
            if (loadingDiv) loadingDiv.classList.add("hidden");
          }
          // === Filtering Functionality ===
          const filterInput = document.getElementById("filterInput");
          const startDateInput = document.getElementById("startDate");
          const endDateInput = document.getElementById("endDate");
          const pairFilter = document.getElementById("pairFilter");
          const outcomeRadios = document.querySelectorAll(
            'input[name="tradeOutcomeFilter"]'
          );
          // === FILTER TRIGGER DELAY ===
          // This prevents the filter from firing too many times in a row.
          let filterTimeout;

          function triggerFilters() {
            // Cancel the previous scheduled call (if any)
            clearTimeout(filterTimeout);

            // Wait 300 milliseconds after the last change before running filters
            filterTimeout = setTimeout(() => {
              applyFilters();
            }, 300);
          }

          // === FIXED FILTER FUNCTION ===
          async function applyFilters() {
            // Get all saved journal entries
            let entries = await getAll(STORE_ENTRIES);

            // Make sure each entry has an outcome (Winner, Loser, etc.)
            entries.forEach((e) => {
              if (!e.outcome) calculateR(e);
            });

            // Read all filter input fields
            const filterText = filterInput.value.trim().toLowerCase();
            const startDate = startDateInput.value
              ? new Date(startDateInput.value)
              : null;
            const endDate = endDateInput.value
              ? new Date(endDateInput.value)
              : null;
            const selectedPair = pairFilter.value;
            const selectedOutcome =
              [...outcomeRadios].find((r) => r.checked)?.value || "All";

            // Filter the entries
            const filtered = entries.filter((e) => {
              // --- Ensure date & time parse correctly ---
              let entryDateTime = null;
              if (e.date) {
                // Detect format (YYYY-MM-DD or MM/DD/YYYY)
                if (e.date.includes("-")) {
                  let [year, month, day] = e.date.split("-");
                  let timePart = (e.time || "00:00")
                    .toString()
                    .replace(/^(\d{1,2})(\d{2})$/, "$1:$2");
                  entryDateTime = new Date(
                    `${year}-${month}-${day}T${timePart}:00`
                  );
                } else if (e.date.includes("/")) {
                  let [month, day, year] = e.date.split("/");
                  let timePart = (e.time || "00:00")
                    .toString()
                    .replace(/^(\d{1,2})(\d{2})$/, "$1:$2");
                  entryDateTime = new Date(
                    `${year}-${month}-${day}T${timePart}:00`
                  );
                }
              }

              // --- Date range filter ---
              if (startDate && entryDateTime && entryDateTime < startDate)
                return false;
              if (endDate && entryDateTime && entryDateTime > endDate)
                return false;

              // --- Pair filter ---
              if (
                selectedPair !== "All" &&
                e.pair &&
                e.pair.trim() !== selectedPair.trim()
              )
                return false;

              // --- Outcome filter ---
              const entryOutcome = (e.outcome || "").toLowerCase();
              if (
                selectedOutcome !== "All" &&
                entryOutcome !== selectedOutcome.toLowerCase()
              )
                return false;

              // --- Text search filter ---
              if (
                filterText &&
                !(
                  (e.pair && e.pair.toLowerCase().includes(filterText)) ||
                  (e.strategy &&
                    e.strategy.toLowerCase().includes(filterText)) ||
                  (e.notes && e.notes.toLowerCase().includes(filterText))
                )
              )
                return false;

              return true;
            });

            // Render the results
            renderJournalEntries(filtered);
          }

          // === Filter Event Listeners ===
          // === FILTER EVENT LISTENERS ===
          if (filterInput)
            filterInput.addEventListener("input", triggerFilters);
          if (startDateInput)
            startDateInput.addEventListener("change", triggerFilters);
          if (endDateInput)
            endDateInput.addEventListener("change", triggerFilters);
          if (pairFilter) pairFilter.addEventListener("change", triggerFilters);
          outcomeRadios.forEach((r) =>
            r.addEventListener("change", triggerFilters)
          );

          function populateFormForEdit(entry) {
            try {
              const modal = document.getElementById("addEntryModal");
              const modalContent = document.getElementById(
                "addEntryModalContent"
              );

              // Show the modal
              modal.classList.remove("hidden");
              modal.classList.add("flex");
              modal.style.opacity = "1";
              modalContent.style.transform = "scale(1)";
              modalContent.style.opacity = "1";

              // Prefill input fields with current entry data
              document.getElementById("date").value = entry.date || "";
              document.getElementById("time").value = entry.time || "";
              document.getElementById("pair").value = entry.pair || "GBP/USD";
              document.getElementById("direction").value =
                entry.direction || "Buy";
              document.getElementById("strategy").value = entry.strategy || "";
              document.getElementById("timeFrame").value =
                entry.timeFrame || "M1";
              document.getElementById("entryPrice").value =
                entry.entryPrice || "";
              document.getElementById("slPrice").value = entry.slPrice || "";
              document.getElementById("tpPrice").value = entry.tpPrice || "";
              document.getElementById("exitPrice").value =
                entry.exitPrice || "";
              document.getElementById("exitReason").value =
                entry.exitReason || "TP";
              document.getElementById("lotSize").value = entry.lotSize || "";
              document.getElementById("setupGrade").value =
                entry.setupGrade || "A";
              document.getElementById("didFollowPlan").value =
                entry.didFollowPlan || "Yes";
              document.getElementById("emotionalState").value =
                entry.emotionalState || "Calm";
              document.getElementById("lessonsLearned").value =
                entry.lessonsLearned || "";
              document.getElementById("notes").value = entry.notes || "";

              // Set the entry ID for editing mode
              journalForm.dataset.editingId = entry.id;
              submitBtn.querySelector("span").textContent = "Save Changes";

              // Re-render strategy selectors (highlighting selected strategies)
              renderStrategySelectors();

              // Highlight selected strategies
              const selectedStrategies = (entry.strategy || "")
                .split(" + ")
                .map((s) => s.trim());
              document
                .querySelectorAll("#indicatorsContainer button")
                .forEach((btn) => {
                  if (selectedStrategies.includes(btn.textContent.trim())) {
                    btn.classList.add(
                      "ring-2",
                      "ring-offset-2",
                      "ring-indigo-500",
                      "dark:ring-violet-400"
                    );
                  } else {
                    btn.classList.remove(
                      "ring-2",
                      "ring-offset-2",
                      "ring-indigo-500",
                      "dark:ring-violet-400"
                    );
                  }
                });

              // Set the image fields only if there are uploaded images
              const preImageField = document.getElementById("preTradeImage");
              const postImageField = document.getElementById("postTradeImage");

              // If there is an existing image for preTradeImage, keep it
              if (entry.preTradeImage) {
                preImageField.setAttribute("src", entry.preTradeImage);
                preImageField.setAttribute("alt", "Pre-Trade Image");
              }

              // If there is an existing image for postTradeImage, keep it
              if (entry.postTradeImage) {
                postImageField.setAttribute("src", entry.postTradeImage);
                postImageField.setAttribute("alt", "Post-Trade Image");
              }
            } catch (err) {
              console.error(err);
            }
          }

          // Handle form submit (add or update)
          if (journalForm) {
            
async function readFileAsBlob(input) {
    return new Promise((resolve) => {
        if (!input || !input.files || !input.files[0]) return resolve(null);
        resolve(input.files[0]);
    });
}
journalForm.addEventListener("submit", async (ev) => {
              ev.preventDefault();

              const form = ev.target;
              const obj = {};

              // Collect form data (simplified for clarity)
              new FormData(form).forEach((v, k) => (obj[k] = v));

              // Convert images to Base64 or preserve old ones
              const editingId = form.dataset.editingId
                ? parseInt(form.dataset.editingId)
                : null;
              let existing = null;

              if (editingId) {
                existing = await getAll("entries").then((list) =>
                  list.find((x) => x.id === editingId)
                );
              }

              const preFile = document.getElementById("preTradeImage").files[0];
              const postFile =
                document.getElementById("postTradeImage").files[0];

              // Helper to convert file to base64
              async function fileToBase64(file) {
                return new Promise((res, rej) => {
                  if (!file) return res("");
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.onerror = rej;
                  reader.readAsDataURL(file);
                });
              }

              // ‚úÖ Preserve or update images correctly
              obj.preTradeImage =
                (await fileToBase64(preFile)) || existing?.preTradeImage || "";
              obj.postTradeImage =
                (await fileToBase64(postFile)) ||
                existing?.postTradeImage ||
                "";

              if (editingId) {
                // ‚úÖ Update existing entry
                obj.id = editingId;
                await putItem("entries", obj);
                delete form.dataset.editingId; // clear editing mode
                showMessageModal("Entry updated successfully!", "success");
              } else {
                // ‚úÖ Add new entry
                await addItem("entries", obj);
                showMessageModal("New entry added successfully!", "success");
              }

              // Refresh UI
              // 1. Reset the form immediately (This is fast)
              form.reset();
              const modal = document.getElementById("addEntryModal");
              if (modal) modal.classList.add("hidden"); // 2. DEFER THE SLOW RENDER

              // This runs *after* the success message modal (A or B) has been clicked and closed.
              setTimeout(async () => {
                await renderJournalEntries();
              }, 50);
            });
          }

          // --- File to base64 ---
          function fileToBase64(file) {
            return new Promise((res, rej) => {
              if (!file) return res(null);
              const MAX_SIZE = 1048576;
              if (file.size > MAX_SIZE) {
                showMessageModal("File too large (>1MB).", "error");
                return res(null);
              }
              const reader = new FileReader();
              reader.onload = () => res(reader.result);
              reader.onerror = () => res(null);
              reader.readAsDataURL(file);
            });
          }

          // --- R calculation ---
          function calculateR(entry) {
            const entryPrice = parseFloat(entry.entryPrice);
            const exitPrice = parseFloat(entry.exitPrice);
            const slPrice = parseFloat(entry.slPrice);
            if (
              isNaN(entryPrice) ||
              isNaN(exitPrice) ||
              isNaN(slPrice) ||
              slPrice === entryPrice
            ) {
              entry.rMultiple = "0.00";
              entry.outcome = "Invalid";
              return 0;
            }
            const isJPY = entry.pair && entry.pair.includes("JPY");
            const multiplier = isJPY ? 100 : 10000;
            const riskInPips = Math.abs(entryPrice - slPrice) * multiplier;
            if (riskInPips === 0) {
              entry.rMultiple = "0.00";
              entry.outcome = "Break-Even";
              return 0;
            }
            let profitInPips =
              entry.direction === "Buy"
                ? (exitPrice - entryPrice) * multiplier
                : (entryPrice - exitPrice) * multiplier;
            const rMultiple = profitInPips / riskInPips;
            const R_THRESHOLD = 0.1;
            if (rMultiple > R_THRESHOLD) entry.outcome = "Win";
            else if (rMultiple < -R_THRESHOLD) entry.outcome = "Loss";
            else entry.outcome = "Break-Even";
            entry.rMultiple = rMultiple.toFixed(2);
            return rMultiple;
          }

          // --- Metrics ---
          function calculateMetrics(entries) {
            const totalTrades = entries.length;
            let totalRScore = 0;
            let winningTrades = 0;
            for (const entry of entries) {
              const r = calculateR(entry);
              totalRScore += r;
              if (entry.outcome === "Win") winningTrades++;
            }
            const winRate =
              totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;
            const avgRR = totalTrades > 0 ? totalRScore / totalTrades : 0;
            return {
              winRate: winRate.toFixed(1),
              totalTrades,
              totalRScore: totalRScore.toFixed(2),
              avgRR: avgRR.toFixed(2),
            };
          }

          function renderMetrics(metrics) {
            if (!metricsDashboard) return;
            function card(title, value, colorClass = "") {
              return `<div class="p-3 rounded-xl flex flex-col items-center justify-center ${colorClass} shadow-md border-2 border-transparent"><div class="text-xs font-semibold uppercase opacity-80">${title}</div><div class="text-2xl font-bold mt-1">${value}</div></div>`;
            }
            metricsDashboard.innerHTML = `
              ${card(
                "Total Trades",
                metrics.totalTrades,
                "bg-indigo-100 dark:bg-indigo-900 text-indigo-700 dark:text-indigo-300"
              )}
              ${card(
                "Win Rate",
                metrics.winRate + "%",
                metrics.winRate >= 50
                  ? "bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300"
                  : "bg-yellow-100 dark:bg-yellow-900 text-yellow-700 dark:text-yellow-300"
              )}
              ${card(
                "Total R-Score",
                metrics.totalRScore,
                metrics.totalRScore >= 0
                  ? "bg-teal-100 dark:bg-teal-900 text-teal-700 dark:text-teal-300"
                  : "bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300"
              )}
              ${card(
                "Avg R-Multiple",
                metrics.avgRR,
                metrics.avgRR >= 0
                  ? "bg-teal-100 dark:bg-teal-900 text-teal-700 dark:text-teal-300"
                  : "bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300"
              )}
            `;
          }

          // === Strategy Usage Rendering ===
          function renderStrategyUsage(entries) {
            const container = document.getElementById("strategyUsageContent");
            if (!container) return;
            container.innerHTML = "";

            const counts = {};
            entries.forEach((e) => {
              if (!e.strategy) return;
              e.strategy
                .split("+")
                .map((s) => s.trim())
                .filter(Boolean)
                .forEach((str) => {
                  counts[str] = (counts[str] || 0) + 1;
                });

              // === AUTO-SAVE STRATEGIES FROM USAGE LIST (unique, case-insensitive, cleans duplicates, with logs) ===
              (async () => {
                try {
                  const db = await openDB();
                  const tx = db.transaction(STORE_STRATEGIES, "readwrite");
                  const store = tx.objectStore(STORE_STRATEGIES);
                  const existing = await txRequestPromise(store.getAll());

                  // üßπ Clean existing duplicates (case-insensitive)
                  const seen = new Set();
                  for (const s of existing) {
                    const lower = s.name.toLowerCase().trim();
                    if (seen.has(lower)) {
                      await store.delete(s.id);
                      console.log("üßπ Deleted duplicate strategy:", s.name);
                    } else {
                      seen.add(lower);
                    }
                  }

                  // Normalize existing strategy names (case-insensitive)
                  const refreshed = await txRequestPromise(store.getAll());
                  const existingNamesLower = refreshed.map((s) =>
                    s.name.toLowerCase().trim()
                  );

                  // Get unique strategy names from current counts, ignoring case
                  const uniqueNames = Object.keys(counts).reduce(
                    (acc, name) => {
                      const lower = name.toLowerCase().trim();
                      if (!acc.some((n) => n.toLowerCase() === lower))
                        acc.push(name.trim());
                      return acc;
                    },
                    []
                  );

                  for (const strategyName of uniqueNames) {
                    // ‚úÖ Add only if it doesn‚Äôt already exist (case-insensitive)
                    if (
                      !existingNamesLower.includes(
                        strategyName.toLowerCase().trim()
                      )
                    ) {
                      const colors = [
                        "indigo",
                        "violet",
                        "green",
                        "blue",
                        "orange",
                        "pink",
                      ];
                      const shades = ["500", "600", "700"];
                      const colorBase =
                        colors[Math.floor(Math.random() * colors.length)];
                      const colorShade =
                        shades[Math.floor(Math.random() * shades.length)];
                      const colorClass = `text-${colorBase}-${colorShade} bg-${colorBase}-100 dark:bg-${colorBase}-800 dark:text-${colorBase}-300`;

                      await putItem(STORE_STRATEGIES, {
                        id: Date.now() + Math.floor(Math.random() * 10000),
                        name: strategyName.trim(),
                        colorClass,
                        colorBase,
                        colorShade,
                      });
                      console.log("‚úÖ Added new strategy:", strategyName);
                    }
                  }
                } catch (err) {
                  console.error("‚ö†Ô∏è Error in auto-save strategies block:", err);
                }
              })();
            });

            // Convert to array and sort descending
            let sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            let showingAll = false;
            const renderList = () => {
              container.innerHTML = "";
              const display = showingAll ? sorted : sorted.slice(0, 5);
              display.forEach(([name, count]) => {
                const s = currentStrategies.find((x) => x.name === name);
                const colorClass = s
                  ? s.colorClass
                  : "bg-gray-200 text-gray-800";
                const div = document.createElement("div");
                div.className = `${colorClass} px-3 py-2 rounded-lg text-sm font-semibold flex items-center justify-between`;
                div.innerHTML = `
                <span>${name}</span>
                <span class="text-xs font-bold bg-white/30 dark:bg-black/20 px-2 py-0.5 rounded-md">${count}</span>
              `;
                container.appendChild(div);
              });
            };

            // Toggle button
            let toggleBtn = document.getElementById("toggleStrategyListBtn");
            if (!toggleBtn) {
              toggleBtn = document.createElement("button");
              toggleBtn.id = "toggleStrategyListBtn";
              toggleBtn.className =
                "mt-3 text-sm font-semibold text-indigo-600 dark:text-violet-400 hover:underline";
              toggleBtn.textContent = "Show All Strategies";
              toggleBtn.addEventListener("click", () => {
                showingAll = !showingAll;
                toggleBtn.textContent = showingAll
                  ? "Show Top 5 Only"
                  : "Show All Strategies";
                renderList();
              });
              container.parentElement.appendChild(toggleBtn);
            }

            renderList();
          }

          // --- Render functions for selectors already defined earlier ---
          function renderStrategySelectorsWrapper() {
            renderStrategySelectors();
          }

          // --- Save strategies array by clearing and repopulating store ---
          async function saveStrategies(strategies) {
            const idb = await openDB();
            const tx = idb.transaction(STORE_STRATEGIES, "readwrite");
            const store = tx.objectStore(STORE_STRATEGIES);
            await new Promise((res) => {
              const c = store.clear();
              c.onsuccess = () => res();
              c.onerror = () => res();
            });
            for (const s of strategies) {
              await new Promise((res) => {
                const r = store.put(s);
                r.onsuccess = () => res();
                r.onerror = () => res();
              });
            }
            currentStrategies = strategies;
            renderStrategySelectors();
            renderStrategiesList();
          }

          // --- Load all raw data (for backup) ---
          async function loadAllRawData() {
            const entries = await getAll(STORE_ENTRIES);
            const strategies = await getAll(STORE_STRATEGIES);
            return { entries, strategies };
          }

          async function overwriteEntries(newEntries) {
            const idb = await openDB();
            const tx = idb.transaction(STORE_ENTRIES, "readwrite");
            const store = tx.objectStore(STORE_ENTRIES);
            await new Promise((res) => {
              const c = store.clear();
              c.onsuccess = () => res();
              c.onerror = () => res();
            });
            for (const entry of newEntries) {
              const copy = Object.assign({}, entry);
              if (copy.id) delete copy.id;
              await addItem(STORE_ENTRIES, copy);
            }
          }

          // --- Backup & Restore JSON handlers ---
          if (backupJsonBtn)
            backupJsonBtn.addEventListener("click", async () => {
              try {
                const data = await loadAllRawData();
                const jsonData = JSON.stringify(data, null, 2);

                // ‚úÖ Detect Android WebView bridge
                if (
                  window.Android &&
                  typeof window.Android.saveBackupBase64 === "function"
                ) {
                  const base64Data = btoa(
                    unescape(encodeURIComponent(jsonData))
                  );
                  window.Android.saveBackupBase64(base64Data);
                  alert("‚úÖ Backup saved to Downloads (Android)");
                } else {
                  // ‚úÖ Fallback for desktop browsers
                  const blob = new Blob([jsonData], {
                    type: "application/json",
                  });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement("a");
                  a.href = url;
                  a.download = `forex_journal_backup_${
                    new Date().toISOString().split("T")[0]
                  }.json`;
                  a.click();
                  URL.revokeObjectURL(url);
                  showMessageModal(
                    "Backup (JSON) file created successfully.",
                    "success"
                  );
                }
              } catch (err) {
                console.error(err);
                showMessageModal("Failed to create JSON backup.", "error");
              }
            });

          // Hidden file input for JSON restore (guarantee it exists)
          let jsonFileInput = document.querySelector(
            'input[type="file"][accept=".json"]'
          );
          if (!jsonFileInput) {
            jsonFileInput = document.createElement("input");
            jsonFileInput.type = "file";
            jsonFileInput.accept = ".json";
            jsonFileInput.classList.add("hidden");
            document.body.appendChild(jsonFileInput);
          }
          if (restoreJsonBtn)
            restoreJsonBtn.addEventListener("click", () =>
              jsonFileInput.click()
            );

          jsonFileInput.addEventListener("change", async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
              const text = await file.text();
              const data = JSON.parse(text);
              if (!data.entries || !data.strategies) {
                showMessageModal("Invalid backup file format.", "error");
                return;
              }
              await overwriteEntries(data.entries);
              await saveStrategies(data.strategies);
              await loadEntries();
              await renderJournalEntries();
              showMessageModal(
                "Database restored successfully from JSON.",
                "success"
              );
            } catch (err) {
              console.error(err);
              showMessageModal("Failed to restore from JSON.", "error");
            } finally {
              jsonFileInput.value = "";
            }
          });

          // --- CSV import/export (using PapaParse if available) ---
          function downloadBlob(dataStr, filename, mime) {
            const blob = new Blob([dataStr], {
              type: mime || "application/octet-stream",
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
          }

          if (window.Papa) {
            if (document.getElementById("backupCsvBtn"))
              document
                .getElementById("backupCsvBtn")
                .addEventListener("click", async () => {
                  try {
                    const all = await getAll(STORE_ENTRIES);
                    if (!all || all.length === 0) {
                      showMessageModal("No entries to export.", "info");
                      return;
                    }
                    const rows = all.map((e) => ({
                      id: e.id,
                      date: e.date,
                      time: e.time,
                      pair: e.pair,
                      direction: e.direction,
                      strategy: e.strategy,
                      timeFrame: e.timeFrame,
                      entryPrice: e.entryPrice,
                      slPrice: e.slPrice,
                      tpPrice: e.tpPrice,
                      exitPrice: e.exitPrice,
                      exitReason: e.exitReason,
                      lotSize: e.lotSize,
                      setupGrade: e.setupGrade,
                      didFollowPlan: e.didFollowPlan,
                      emotionalState: e.emotionalState,
                      preTradeImage: e.preTradeImage || "",
                      postTradeImage: e.postTradeImage || "",
                      lessonsLearned: e.lessonsLearned || "",
                      notes: e.notes || "",
                    }));
                    const csv = window.Papa.unparse(rows);
                    downloadBlob(
                      csv,
                      `forex_journal_${
                        new Date().toISOString().split("T")[0]
                      }.csv`,
                      "text/csv;charset=utf-8;"
                    );
                    showMessageModal("CSV exported.", "success");
                  } catch (err) {
                    console.error(err);
                    showMessageModal("CSV export failed.", "error");
                  }
                });
            // import
            if (importCsvBtn && csvFileInput) {
              importCsvBtn.addEventListener("click", () =>
                csvFileInput.click()
              );
              csvFileInput.addEventListener("change", (ev) => {
                const f = ev.target.files[0];
                if (!f) return;
                window.Papa.parse(f, {
                  header: true,
                  skipEmptyLines: true,
                  complete: async (results) => {
                    const rows = results.data;
                    for (const r of rows) {
                      
const convertIfBase64 = (str) => {
  if (!str || typeof str !== 'string') return null;
  if (str.startsWith('data:image')) {
    const mime = str.substring(5, str.indexOf(';')) || 'image/jpeg';
    const b64 = str.split(',')[1];
    try {
      const byteString = atob(b64);
      const ab = new ArrayBuffer(byteString.length);
      const ia = new Uint8Array(ab);
      for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
      return new Blob([ab], { type: mime });
    } catch (e) { console.warn('Failed to convert data URL to Blob', e); return null; }
  }
  // raw base64 (may contain whitespace)
  const cleaned = str.replace(/\s+/g, '');
  if (/^[A-Za-z0-9+/=]+$/.test(cleaned)) {
    try {
      const byteString = atob(cleaned);
      const ab = new ArrayBuffer(byteString.length);
      const ia = new Uint8Array(ab);
      for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i);
      return new Blob([ab], { type: 'image/jpeg' });
    } catch (e) { console.warn('Failed to convert raw base64 to Blob', e); return null; }
  }
  return null;
};

const preBlob = convertIfBase64(r.preTradeImage);
const postBlob = convertIfBase64(r.postTradeImage);

const entry = {
  date: r.date || "",
  time: r.time || "",
  pair: r.pair || "GBP/USD",
  direction: r.direction || "Buy",
  strategy: r.strategy || "",
  timeFrame: r.timeFrame || "M1",
  entryPrice: r.entryPrice || "",
  slPrice: r.slPrice || "",
  tpPrice: r.tpPrice || "",
  exitPrice: r.exitPrice || "",
  exitReason: r.exitReason || "TP",
  lotSize: r.lotSize || "",
  setupGrade: r.setupGrade || "A",
  didFollowPlan: r.didFollowPlan || "Yes",
  emotionalState: r.emotionalState || "Calm",
  preTradeImage: preBlob || (r.preTradeImage || ""),
  postTradeImage: postBlob || (r.postTradeImage || ""),
  lessonsLearned: r.lessonsLearned || "",
  notes: r.notes || ""
};

                      if (entry.id) delete entry.id;
                      await addItem(STORE_ENTRIES, entry);
                    }
                    await loadEntries();
                    renderJournalEntries();
                    showMessageModal("CSV imported.", "success");
                    csvFileInput.value = "";
                  },
                  error: (err) => {
                    console.error(err);
                    showMessageModal("CSV import failed.", "error");
                    csvFileInput.value = "";
                  },
                });
              });
            }
          } else {
            // fallback: attach simple handlers for UI buttons if Papa not present
            if (importCsvBtn)
              importCsvBtn.addEventListener("click", () =>
                showMessageModal(
                  "PapaParse not loaded. CSV import disabled.",
                  "error"
                )
              );
            if (document.getElementById("backupCsvBtn"))
              document
                .getElementById("backupCsvBtn")
                .addEventListener("click", () =>
                  showMessageModal(
                    "PapaParse not loaded. CSV export disabled.",
                    "error"
                  )
                );
          }

          // --- Raw data modal handlers ---
          if (showDbDataBtn)
            showDbDataBtn.addEventListener("click", async () => {
              const entries = await getAll(STORE_ENTRIES);
              const strategies = await getAll(STORE_STRATEGIES);
              if (rawEntriesPre)
                rawEntriesPre.textContent = JSON.stringify(entries, null, 2);
              if (rawStrategiesPre)
                rawStrategiesPre.textContent = JSON.stringify(
                  strategies,
                  null,
                  2
                );
              if (rawDataModal) rawDataModal.classList.remove("hidden");
            });
          if (closeRawDataModalBtn)
            closeRawDataModalBtn.addEventListener("click", () =>
              rawDataModal.classList.add("hidden")
            );

          // --- Strategies modal open/close ---
          if (strategiesBtn)
            strategiesBtn.addEventListener("click", async () => {
              await loadStrategies();
              if (strategiesModal) strategiesModal.classList.remove("hidden");
            });
          if (closeStrategiesModalBtn)
            closeStrategiesModalBtn.addEventListener("click", () =>
              strategiesModal.classList.add("hidden")
            );

          // --- Strategy add form ---
          if (strategyForm)
            strategyForm.addEventListener("submit", async (ev) => {
              ev.preventDefault();
              const name = (
                (strategyNameInput && strategyNameInput.value) ||
                ""
              ).trim();
              if (!name) {
                showMessageModal("Enter strategy name.", "error");
                return;
              }
              const newStrategy = {
                id: Date.now(),
                name,
                colorClass:
                  "text-indigo-600 bg-indigo-100 dark:bg-indigo-800 dark:text-indigo-300",
                colorBase: "indigo",
                colorShade: "600",
              };
              await putItem(STORE_STRATEGIES, newStrategy);
              strategyNameInput.value = "";
              await loadStrategies();
              showMessageModal("New strategy added to the DB.", "success");
            });

          // --- Helpers: normalize time ---
          function normalizeTimeFormat(timeStr) {
            if (!timeStr) return "";
            const cleanStr = timeStr.toString().replace(/[^0-9]/g, "");
            if (cleanStr.length === 4)
              return `${cleanStr.substring(0, 2)}:${cleanStr.substring(2, 4)}`;
            return timeStr;
          }

          // --- Filters (basic) ---

          // --- Raw Data modal show/hide already wired earlier ---

          // --- Init ---
          (async function init() {
            try {
              await openDB();
              await ensureDefaults();
              await loadStrategies();
              await loadEntries();
              await renderJournalEntries();
              console.log("Initialization complete.");
            } catch (err) {
              console.error("Init error", err);
              showMessageModal(
                "Initialization failed: Could not load data.",
                "error"
              );
            }

            // === Expose helper functions globally ===
            window.openDB = openDB;
            window.loadEntries = loadEntries;
            window.renderJournalEntries = renderJournalEntries;
            window.ensureDefaults = ensureDefaults;
            window.getAll = getAll;
            window.loadAllRawData = loadAllRawData;

            // --- Delete All Entries Button Handler (Entries + Strategies) ---
            const deleteAllBtn = document.getElementById("deleteAllBtn");
            if (deleteAllBtn) {
              deleteAllBtn.addEventListener("click", async () => {
                if (
                  !confirm(
                    "Are you sure you want to delete ALL journal entries and strategies? This cannot be undone."
                  )
                )
                  return;
                try {
                  const idb = await openDB();

                  // Clear both object stores
                  const tx = idb.transaction(
                    ["entries", "strategies"],
                    "readwrite"
                  );
                  const entriesStore = tx.objectStore("entries");
                  const strategiesStore = tx.objectStore("strategies");

                  await Promise.all([
                    new Promise((res, rej) => {
                      const req = entriesStore.clear();
                      req.onsuccess = () => res();
                      req.onerror = () => rej(req.error);
                    }),
                    new Promise((res, rej) => {
                      const req = strategiesStore.clear();
                      req.onsuccess = () => res();
                      req.onerror = () => rej(req.error);
                    }),
                  ]);

                  await ensureDefaults(); // re-add default strategies
                  await loadEntries();
                  await renderJournalEntries();

                  // Update raw data modal
                  if (typeof loadAllRawData === "function") {
                    const raw = await loadAllRawData();
                    const rawEntriesPre =
                      document.getElementById("rawEntriesPre");
                    const rawStrategiesPre =
                      document.getElementById("rawStrategiesPre");
                    if (rawEntriesPre)
                      rawEntriesPre.textContent = JSON.stringify(
                        raw.entries,
                        null,
                        2
                      );
                    if (rawStrategiesPre)
                      rawStrategiesPre.textContent = JSON.stringify(
                        raw.strategies,
                        null,
                        2
                      );
                  }

                  showMessageModal(
                    "All entries and strategies deleted successfully.",
                    "success"
                  );
                } catch (err) {
                  console.error(err);
                  showMessageModal("Failed to delete all entries.", "error");
                }
              });
            }
          })();

          // === Expose helper functions globally ===
          window.openDB = openDB;
          window.loadEntries = loadEntries;
          window.renderJournalEntries = renderJournalEntries;
          window.ensureDefaults = ensureDefaults;
          window.getAll = getAll;
          window.loadAllRawData = loadAllRawData;

          // --- Delete All Entries Button Handler (Entries + Strategies) ---
          const deleteAllBtn = document.getElementById("deleteAllBtn");
          if (deleteAllBtn) {
            deleteAllBtn.addEventListener("click", async () => {
              if (
                !confirm(
                  "Are you sure you want to delete ALL journal entries and strategies? This cannot be undone."
                )
              )
                return;
              try {
                const idb = await openDB();

                // Clear both object stores
                const tx = idb.transaction(
                  ["entries", "strategies"],
                  "readwrite"
                );
                const entriesStore = tx.objectStore("entries");
                const strategiesStore = tx.objectStore("strategies");

                await Promise.all([
                  new Promise((res, rej) => {
                    const req = entriesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                  new Promise((res, rej) => {
                    const req = strategiesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                ]);

                await ensureDefaults(); // re-add default strategies
                await loadEntries();
                await renderJournalEntries();

                // Update raw data modal
                if (typeof loadAllRawData === "function") {
                  const raw = await loadAllRawData();
                  const rawEntriesPre =
                    document.getElementById("rawEntriesPre");
                  const rawStrategiesPre =
                    document.getElementById("rawStrategiesPre");
                  if (rawEntriesPre)
                    rawEntriesPre.textContent = JSON.stringify(
                      raw.entries,
                      null,
                      2
                    );
                  if (rawStrategiesPre)
                    rawStrategiesPre.textContent = JSON.stringify(
                      raw.strategies,
                      null,
                      2
                    );
                }

                showMessageModal(
                  "All entries and strategies deleted successfully.",
                  "success"
                );
              } catch (err) {
                console.error(err);
                showMessageModal("Failed to delete all entries.", "error");
              }
            });
          }
        })(); // end consolidated IIFE

        //temporaryF
        console.log(
          "Connected:",
          startDateInput,
          endDateInput,
          pairFilter,
          outcomeRadios
        );
      </script>
      <script>
        (function () {
          const addFab = document.getElementById("addEntryFab");
          const modal = document.getElementById("addEntryModal");
          const modalContent = document.getElementById("addEntryModalContent");
          const closeBtn = document.getElementById("closeAddEntryModalBtn");
          const closeFooterBtn = document.getElementById(
            "closeAddEntryModalFooterBtn"
          );

          function openModal() {
            if (!modal) return;
            modal.classList.remove("hidden");
            // trigger reflow then set opacity/scale for animation
            requestAnimationFrame(() => {
              modal.style.opacity = "1";
              modal.classList.remove("opacity-0");
              modalContent.style.transform = "scale(1)";
              modalContent.classList.remove("scale-95");
            });
            // prevent background scroll
            document.documentElement.style.overflow = "hidden";
            document.body.style.overflow = "hidden";
          }
          function closeModal() {
            if (!modal) return;
            // animate out
            modal.style.opacity = "0";
            modal.classList.add("opacity-0");
            modalContent.style.transform = "scale(0.95)";
            modalContent.classList.add("scale-95");
            setTimeout(() => {
              modal.classList.add("hidden");
              // restore scroll
              document.documentElement.style.overflow = "";
              document.body.style.overflow = "";
            }, 200);
          }

          if (addFab)
            addFab.addEventListener("click", (e) => {
              e.preventDefault();
              openModal();
            });

          if (closeBtn)
            closeBtn.addEventListener("click", (e) => {
              e.preventDefault();
              closeModal();
            });
          if (closeFooterBtn)
            closeFooterBtn.addEventListener("click", (e) => {
              e.preventDefault();
              closeModal();
            });

          // close when clicking outside modal content
          if (modal) {
            modal.addEventListener("click", (e) => {
              if (e.target === modal) closeModal();
            });
          }

          // If form had editing state and was previously shown, ensure modal shows when editing
          const journalForm = document.getElementById("journalForm");
          if (journalForm) {
            // Intercept when form gets dataset.editingId set externally: open modal
            const originalSet = Object.getOwnPropertyDescriptor(
              HTMLFormElement.prototype,
              "dataset"
            ).get;
            // can't easily trap dataset changes universally; instead ensure that when populateFormForEdit is called it opens modal.
            // So override the global function if present:
            if (typeof populateFormForEdit === "function") {
              const originalPopulate = populateFormForEdit;
              window.populateFormForEdit = function (entry) {
                originalPopulate(entry);
                openModal();
              };
            }
          }

          // === Expose helper functions globally ===
          window.openDB = openDB;
          window.loadEntries = loadEntries;
          window.renderJournalEntries = renderJournalEntries;
          window.ensureDefaults = ensureDefaults;
          window.getAll = getAll;
          window.loadAllRawData = loadAllRawData;

          // --- Delete All Entries Button Handler (Entries + Strategies) ---
          const deleteAllBtn = document.getElementById("deleteAllBtn");
          if (deleteAllBtn) {
            deleteAllBtn.addEventListener("click", async () => {
              if (
                !confirm(
                  "Are you sure you want to delete ALL journal entries and strategies? This cannot be undone."
                )
              )
                return;
              try {
                const idb = await openDB();

                // Clear both object stores
                const tx = idb.transaction(
                  ["entries", "strategies"],
                  "readwrite"
                );
                const entriesStore = tx.objectStore("entries");
                const strategiesStore = tx.objectStore("strategies");

                await Promise.all([
                  new Promise((res, rej) => {
                    const req = entriesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                  new Promise((res, rej) => {
                    const req = strategiesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                ]);

                await ensureDefaults(); // re-add default strategies
                await loadEntries();
                await renderJournalEntries();

                // Update raw data modal
                if (typeof loadAllRawData === "function") {
                  const raw = await loadAllRawData();
                  const rawEntriesPre =
                    document.getElementById("rawEntriesPre");
                  const rawStrategiesPre =
                    document.getElementById("rawStrategiesPre");
                  if (rawEntriesPre)
                    rawEntriesPre.textContent = JSON.stringify(
                      raw.entries,
                      null,
                      2
                    );
                  if (rawStrategiesPre)
                    rawStrategiesPre.textContent = JSON.stringify(
                      raw.strategies,
                      null,
                      2
                    );
                }

                showMessageModal(
                  "All entries and strategies deleted successfully.",
                  "success"
                );
              } catch (err) {
                console.error(err);
                showMessageModal("Failed to delete all entries.", "error");
              }
            });
          }
        })();
      </script>
      <script>
        (function () {
          const toggle = document.getElementById("darkModeToggle");
          const html = document.documentElement;
          if (!toggle) return;

          // Helper to set initial theme
          function applySavedTheme() {
            const saved = localStorage.getItem("theme");
            if (
              saved === "dark" ||
              (!saved &&
                window.matchMedia &&
                window.matchMedia("(prefers-color-scheme: dark)").matches)
            ) {
              html.classList.add("dark");
            } else {
              html.classList.remove("dark");
            }
            updateIcons();
          }

          // Find icon spans safely (use order as a fallback)
          const spans = Array.from(toggle.querySelectorAll("span"));
          const moonSpan = spans[0] || null;
          const sunSpan = spans[1] || null;

          function updateIcons() {
            try {
              const isDark = html.classList.contains("dark");
              if (moonSpan) moonSpan.style.display = isDark ? "none" : "";
              if (sunSpan) sunSpan.style.display = isDark ? "" : "none";
            } catch (e) {
              /* silent */
            }
          }

          // Toggle handler
          toggle.addEventListener("click", function (e) {
            e.preventDefault();
            html.classList.toggle("dark");
            const isDark = html.classList.contains("dark");
            try {
              localStorage.setItem("theme", isDark ? "dark" : "light");
            } catch (e) {}
            updateIcons();
          });

          // Init on load
          applySavedTheme();

          // Also listen to system theme changes if user hasn't explicitly set theme
          try {
            const mq = window.matchMedia("(prefers-color-scheme: dark)");
            mq.addEventListener
              ? mq.addEventListener("change", (e) => {
                  if (!localStorage.getItem("theme")) applySavedTheme();
                })
              : mq.addListener((e) => {
                  if (!localStorage.getItem("theme")) applySavedTheme();
                });
          } catch (e) {}

          // === Expose helper functions globally ===
          window.openDB = openDB;
          window.loadEntries = loadEntries;
          window.renderJournalEntries = renderJournalEntries;
          window.ensureDefaults = ensureDefaults;
          window.getAll = getAll;
          window.loadAllRawData = loadAllRawData;

          // --- Delete All Entries Button Handler (Entries + Strategies) ---
          const deleteAllBtn = document.getElementById("deleteAllBtn");
          if (deleteAllBtn) {
            deleteAllBtn.addEventListener("click", async () => {
              if (
                !confirm(
                  "Are you sure you want to delete ALL journal entries and strategies? This cannot be undone."
                )
              )
                return;
              try {
                const idb = await openDB();

                // Clear both object stores
                const tx = idb.transaction(
                  ["entries", "strategies"],
                  "readwrite"
                );
                const entriesStore = tx.objectStore("entries");
                const strategiesStore = tx.objectStore("strategies");

                await Promise.all([
                  new Promise((res, rej) => {
                    const req = entriesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                  new Promise((res, rej) => {
                    const req = strategiesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                ]);

                await ensureDefaults(); // re-add default strategies
                await loadEntries();
                await renderJournalEntries();

                // Update raw data modal
                if (typeof loadAllRawData === "function") {
                  const raw = await loadAllRawData();
                  const rawEntriesPre =
                    document.getElementById("rawEntriesPre");
                  const rawStrategiesPre =
                    document.getElementById("rawStrategiesPre");
                  if (rawEntriesPre)
                    rawEntriesPre.textContent = JSON.stringify(
                      raw.entries,
                      null,
                      2
                    );
                  if (rawStrategiesPre)
                    rawStrategiesPre.textContent = JSON.stringify(
                      raw.strategies,
                      null,
                      2
                    );
                }

                showMessageModal(
                  "All entries and strategies deleted successfully.",
                  "success"
                );
              } catch (err) {
                console.error(err);
                showMessageModal("Failed to delete all entries.", "error");
              }
            });
          }
        })();
      </script>
>>>>>>> a0823573854bb126707a7d2b60927a607b5f1138
    </div>

    <script>
      // =========================================================================================================================
      // 1. SQLite Helpers (Replaces IndexedDB logic)
      // =========================================================================================================================

      const DB_NAME = "ForexJournalDB";
      const STORE_ENTRIES = "entries";
      const STORE_STRATEGIES = "strategies";

      let db;

      // Helper to safely get the plugin (assuming standard Capacitor plugin global access)
      const getSqlitePlugin = () => {
          if (window.Capacitor?.Plugins?.Sqlite) {
              return window.Capacitor.Plugins.Sqlite;
          } else {
              // Dummy implementation for web/testing where plugin is not available
              console.warn("Capacitor SQLite Plugin not available. Using a dummy implementation.");
              return {
                  open: async () => ({ database: DB_NAME }), // Returns database name as a substitute for databaseId
                  execute: async (options) => { console.log("Dummy Execute:", options.statements); return { changes: { changes: 0 } }; },
                  query: async (options) => { console.log("Dummy Query:", options.statement); return { values: [] }; },
                  close: async () => { console.log("Dummy Close."); },
                  run: async (options) => { console.log("Dummy Run:", options.statement); return { changes: { changes: 0 } }; },
                  isDatabase: async () => ({ result: false }),
                  dropDatabase: async () => { console.log("Dummy Drop."); },
              };
          }
      };

      const Sqlite = getSqlitePlugin();

      /**
       * Open the SQLite database and initialize the tables.
       */
      async function openDB() {
          try {
              // The `open` method handles creation/opening
              const { database } = await Sqlite.open({
                  database: DB_NAME,
                  encrypted: false,
                  mode: 'full',
                  version: 1,
                  readonly: false
              });
              db = database; // Use the database name as the identifier

              // SQL statements to create tables if they do not exist
              // The 'id' column in entries will be the primary key for auto-increment.
              const statements = `
                  CREATE TABLE IF NOT EXISTS ${STORE_ENTRIES} (
                      id INTEGER PRIMARY KEY,
                      date TEXT NOT NULL,
                      pair TEXT NOT NULL,
                      strategy TEXT NOT NULL,
                      direction TEXT NOT NULL,
                      result TEXT NOT NULL,
                      pips REAL,
                      image TEXT,
                      notes TEXT,
                      timestamp INTEGER NOT NULL
                  );
                  CREATE TABLE IF NOT EXISTS ${STORE_STRATEGIES} (
                      name TEXT PRIMARY KEY NOT NULL,
                      description TEXT
                  );
              `;

              await Sqlite.execute({ database: db, statements: statements });
              console.log("SQLite Database initialized.");
          } catch (err) {
              console.error("SQLite Initialization failed:", err);
              throw err;
          }
      }

      /**
       * Saves an item to a store (table).
       * If item.id is provided, it attempts to update (using UPDATE).
       * @param {string} storeName - The name of the table (STORE_ENTRIES or STORE_STRATEGIES).
       * @param {Object} item - The object to save.
       */
      async function addItem(storeName, item) {
          if (storeName === STORE_ENTRIES) {
              // Save a trade entry
              const sql = item.id
                  ? `
                      UPDATE ${STORE_ENTRIES} SET
                          date=?, pair=?, strategy=?, direction=?, result=?, pips=?, image=?, notes=?, timestamp=?
                      WHERE id=?
                  `
                  : `
                      INSERT INTO ${STORE_ENTRIES}
                          (date, pair, strategy, direction, result, pips, image, notes, timestamp)
                      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                  `;

              const values = item.id
                  ? [
                      item.date, item.pair, item.strategy, item.direction, item.result, item.pips || null, item.image || null, item.notes || null, item.timestamp,
                      item.id
                  ]
                  : [
                      item.date, item.pair, item.strategy, item.direction, item.result, item.pips || null, item.image || null, item.notes || null, item.timestamp
                  ];

              const result = await Sqlite.run({ database: db, statement: sql, values: values });
              return item.id ? item.id : result.changes.lastId;
          } else if (storeName === STORE_STRATEGIES) {
              // Save a strategy. Name is the primary key.
              const sql = `INSERT OR REPLACE INTO ${STORE_STRATEGIES} (name, description) VALUES (?, ?)`;
              await Sqlite.run({ database: db, statement: sql, values: [item.name, item.description || null] });
              return item.name;
          }
      }

      /**
       * Retrieves all items from a store (table).
       * @param {string} storeName - The name of the table.
       * @returns {Promise<Array<Object>>} - The list of items.
       */
      async function getAll(storeName) {
          let orderBy = '';
          if (storeName === STORE_ENTRIES) {
              orderBy = 'ORDER BY timestamp DESC';
          }
          const sql = `SELECT * FROM ${storeName} ${orderBy}`;
          const result = await Sqlite.query({ database: db, statement: sql, values: [] });

          // Rows are returned as an array of objects
          return result.values || [];
      }

      /**
       * Deletes an item from a store (table) by its key (id or name).
       * @param {string} storeName - The name of the table.
       * @param {*} key - The key (id for entries, name for strategies).
       */
      async function deleteItem(storeName, key) {
          const keyColumn = storeName === STORE_ENTRIES ? 'id' : 'name';
          const sql = `DELETE FROM ${storeName} WHERE ${keyColumn} = ?`;
          await Sqlite.run({ database: db, statement: sql, values: [key] });
      }

      /**
       * Clears all data from a store (table).
       * @param {string} storeName - The name of the table.
       */
      async function clear(storeName) {
          const sql = `DELETE FROM ${storeName}`;
          await Sqlite.run({ database: db, statement: sql, values: [] });
      }

      // =========================================================================================================================
      // 2. State & DOM References
      // =========================================================================================================================

      let journalEntries = [];
      let tradingStrategies = [];
      let currencyPairs = [];

      const tradeForm = document.getElementById("tradeForm");
      const strategyForm = document.getElementById("strategyForm");
      const entriesList = document.getElementById("entriesList");
      const strategyList = document.getElementById("strategyList");
      const strategySelect = document.getElementById("strategy");
      const pairSuggestions = document.getElementById("pairSuggestions");

      const exportBtn = document.getElementById("exportBtn");
      const importBtn = document.getElementById("importBtn");
      const deleteAllBtn = document.getElementById("deleteAllBtn");
      const filterText = document.getElementById("filterText");

      const imageFile = document.getElementById("imageFile");
      const imageDataField = document.getElementById("imageData");
      const imagePreview = document.getElementById("imagePreview");
      const imagePreviewContainer = document.getElementById("imagePreviewContainer");
      const clearImageBtn = document.getElementById("clearImageBtn");
      const cancelEditBtn = document.getElementById("cancelEditBtn");

      // =========================================================================================================================
      // 3. Trade Entry Logic
      // =========================================================================================================================

      /**
       * Converts a file (image) to a Base64 string.
       * @param {File} file
       * @returns {Promise<string>}
       */
      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = (error) => reject(error);
          reader.readAsDataURL(file);
        });
      }

      /**
       * Handles trade form submission (Add/Edit).
       */
      tradeForm.addEventListener("submit", async (e) => {
        e.preventDefault();

        const entryId = document.getElementById("entryId").value;
        const date = document.getElementById("tradeDate").value;
        const pair = document.getElementById("currencyPair").value.toUpperCase();
        const strategy = document.getElementById("strategy").value;
        const direction = document.getElementById("direction").value;
        const result = document.getElementById("result").value;
        const pips = parseFloat(document.getElementById("pips").value) || null;
        const notes = document.getElementById("notes").value.trim() || null;
        let image = imageDataField.value || null;

        // Handle new image upload during submission
        if (imageFile.files.length > 0) {
          image = await fileToBase64(imageFile.files[0]);
        }

        const newEntry = {
          // If editing, use the existing ID (SQLite will UPDATE)
          id: entryId ? parseInt(entryId) : undefined,
          date,
          pair,
          strategy,
          direction,
          result,
          pips,
          image,
          notes,
          timestamp: entryId ? journalEntries.find(e => e.id === parseInt(entryId)).timestamp : Date.now(),
        };

        try {
          // The addItem function handles both INSERT and UPDATE based on 'id' presence
          const newId = await addItem(STORE_ENTRIES, newEntry);
          newEntry.id = newId;

          if (entryId) {
            // Update mode: replace the old entry in the state
            const index = journalEntries.findIndex((e) => e.id === newEntry.id);
            if (index > -1) {
              journalEntries[index] = newEntry;
            }
            showToast("Trade updated successfully!");
          } else {
            // Insert mode: add to the front of the state
            journalEntries.unshift(newEntry);
            showToast("Trade saved successfully!");
          }

          // Update the list of pairs
          updateCurrencyPairs(pair);

          // Reset the form and re-render
          tradeForm.reset();
          resetFormForNewEntry();
          await renderJournalEntries();
        } catch (error) {
          console.error("Error saving/updating entry:", error);
          alert("Error saving trade: " + error.message);
        }
      });

      /**
       * Initializes image file listeners for preview/clearing.
       */
      function initImageListeners() {
        // Preview image on file selection
        imageFile.addEventListener("change", (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              imagePreview.src = e.target.result;
              imagePreviewContainer.classList.remove("hidden");
              imageDataField.value = ""; // Clear hidden field if new file is selected
            };
            reader.readAsDataURL(file);
          } else {
            imagePreviewContainer.classList.add("hidden");
            imagePreview.src = "";
          }
        });

        // Clear button to remove the image (either new or existing)
        clearImageBtn.addEventListener("click", () => {
          imageFile.value = "";
          imageDataField.value = "";
          imagePreview.src = "";
          imagePreviewContainer.classList.add("hidden");
        });
      }

      /**
       * Renders the list of journal entries.
       */
      async function renderJournalEntries() {
        const filterValue = filterText.value.toLowerCase();

        const filteredEntries = journalEntries.filter((entry) => {
          const searchString = `${entry.pair} ${entry.strategy} ${entry.notes || ""}`.toLowerCase();
          return searchString.includes(filterValue);
        });

<<<<<<< HEAD
        if (filteredEntries.length === 0) {
          entriesList.innerHTML = `<p class="text-center text-gray-500 dark:text-gray-400">No trades found.</p>`;
=======
      function reloadAppData() {
        console.log("üîÑ Reloading app data...");
        if (window.Capacitor) {
          location.reload(); // Safe in APK
        } else {
          window.location.reload(); // Safe in browser
        }
      }

      console.log(
        "‚úÖ Unified Refresh Helper ready. Use softRefreshUI() or reloadAppData()."
      );
    </script>
    <!-- Color Save Instant Refresh Helper -->
    <script>
      async function afterColorSave() {
        console.log("üé® Color update saved. Refreshing display...");
        if (typeof renderJournalEntries === "function") {
          try {
            await renderJournalEntries();
            console.log("‚úÖ Colors refreshed instantly.");
          } catch (err) {
            console.warn(
              "‚ö†Ô∏è renderJournalEntries failed, fallback to reload",
              err
            );
            reloadAppData();
          }
        } else {
          reloadAppData();
        }
      }
      console.log(
        "‚úÖ afterColorSave() helper active. Call it after saving a color."
      );
    </script>
    <!-- Front-End Patch: Apply strategy color immediately after save -->
    <script>
      async function applyStrategyColorToUI(strategyName, colorValue) {
        if (!strategyName || !colorValue) return;

        // Find all elements related to this strategy
        const elements = document.querySelectorAll(
          `[data-strategy-name="${strategyName}"]`
        );
        if (elements.length === 0) {
          console.debug(
            `INFO: No visible elements found for strategy: ${strategyName}.`
          );
>>>>>>> a0823573854bb126707a7d2b60927a607b5f1138
          return;
        }

        entriesList.innerHTML = filteredEntries
          .map(
            (entry) => `
              <div
                class="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg shadow flex flex-col sm:flex-row justify-between items-start sm:items-center border-l-4 ${
                  entry.result === "Win"
                    ? "border-green-500"
                    : entry.result === "Loss"
                    ? "border-red-500"
                    : "border-yellow-500"
                }"
              >
                <div class="flex-1 min-w-0">
                  <div class="flex items-center space-x-3 mb-1">
                    <span class="text-lg font-bold text-gray-900 dark:text-gray-100">${entry.pair}</span>
                    <span class="px-2 py-0.5 text-xs font-semibold rounded-full ${
                      entry.result === "Win"
                        ? "bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100"
                        : entry.result === "Loss"
                        ? "bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-100"
                        : "bg-yellow-100 text-yellow-800 dark:bg-yellow-800 dark:text-yellow-100"
                    }">${entry.result}</span>
                    ${entry.pips !== null ? `<span class="text-sm text-gray-600 dark:text-gray-300">${entry.pips >= 0 ? "+" : ""}${entry.pips} pips</span>` : ""}
                  </div>
                  <p class="text-sm text-indigo-600 dark:text-indigo-400 font-medium mb-1">${entry.strategy}</p>
                  <p class="text-xs text-gray-500 dark:text-gray-400">${entry.date} - ${entry.direction}</p>
                  ${
                    entry.notes
                      ? `<p class="text-sm text-gray-700 dark:text-gray-300 mt-2 italic">${entry.notes}</p>`
                      : ""
                  }
                  ${
                    entry.image
                      ? `<img src="${entry.image}" alt="Trade Screenshot" class="mt-2 w-20 h-20 object-cover rounded-md cursor-pointer" onclick="viewImage('${entry.image}')" />`
                      : ""
                  }
                </div>
                <div class="flex space-x-2 mt-3 sm:mt-0">
                  <button
                    onclick="editEntry(${entry.id})"
                    class="text-indigo-600 hover:text-indigo-900 dark:text-indigo-400 dark:hover:text-indigo-200 text-sm font-semibold"
                  >
                    Edit
                  </button>
                  <button
                    onclick="deleteEntry(${entry.id})"
                    class="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-200 text-sm font-semibold"
                  >
                    Delete
                  </button>
                </div>
              </div>
            `
          )
          .join("");
      }

      /**
       * Fills the form with data for editing a trade entry.
       * @param {number} id - The ID of the entry to edit.
       */
      function editEntry(id) {
        const entry = journalEntries.find((e) => e.id === id);
        if (!entry) return;

        // Scroll to the form
        window.scrollTo({ top: 0, behavior: "smooth" });

        // Populate form fields
        document.getElementById("entryId").value = entry.id;
        document.getElementById("tradeDate").value = entry.date;
        document.getElementById("currencyPair").value = entry.pair;
        document.getElementById("strategy").value = entry.strategy;
        document.getElementById("direction").value = entry.direction;
        document.getElementById("result").value = entry.result;
        document.getElementById("pips").value = entry.pips;
        document.getElementById("notes").value = entry.notes;

        // Handle image field
        imageFile.value = ""; // Clear file input
        if (entry.image) {
          imageDataField.value = entry.image; // Store base64 in hidden field
          imagePreview.src = entry.image;
          imagePreviewContainer.classList.remove("hidden");
        } else {
          imageDataField.value = "";
          imagePreview.src = "";
          imagePreviewContainer.classList.add("hidden");
        }

        // Change button text and show cancel button
        const submitBtn = tradeForm.querySelector('button[type="submit"]');
        submitBtn.textContent = "Update Trade";
        submitBtn.classList.remove("bg-indigo-600");
        submitBtn.classList.add("bg-orange-500", "hover:bg-orange-600");
        cancelEditBtn.classList.remove("hidden");
      }

      /**
       * Deletes a trade entry by ID.
       * @param {number} id - The ID of the entry to delete.
       */
      async function deleteEntry(id) {
        if (!confirm("Are you sure you want to delete this trade entry?")) {
          return;
        }

        try {
          await deleteItem(STORE_ENTRIES, id);
          journalEntries = journalEntries.filter((e) => e.id !== id);
          await renderJournalEntries();
          showToast("Trade deleted.");
        } catch (error) {
          console.error("Error deleting entry:", error);
          alert("Error deleting trade: " + error.message);
        }
      }

      /**
       * Resets the form after editing or canceling an edit.
       */
      function resetFormForNewEntry() {
        document.getElementById("entryId").value = "";
        const submitBtn = tradeForm.querySelector('button[type="submit"]');
        submitBtn.textContent = "Save Trade";
        submitBtn.classList.remove("bg-orange-500", "hover:bg-orange-600");
        submitBtn.classList.add("bg-indigo-600");
        cancelEditBtn.classList.add("hidden");

        // Reset image fields
        imageFile.value = "";
        imageDataField.value = "";
        imagePreview.src = "";
        imagePreviewContainer.classList.add("hidden");
        document.getElementById("tradeDate").valueAsDate = new Date(); // Reset date to today
      }

      // Filter listener
      filterText.addEventListener("input", renderJournalEntries);
      cancelEditBtn.addEventListener("click", () => {
        tradeForm.reset();
        resetFormForNewEntry();
      });

      // =========================================================================================================================
      // 4. Strategy Management Logic
      // =========================================================================================================================

      /**
       * Handles strategy form submission (Add new strategy).
       */
      strategyForm.addEventListener("submit", async (e) => {
        e.preventDefault();

        const nameInput = document.getElementById("strategyName");
        const name = nameInput.value.trim();

        if (name && !tradingStrategies.some((s) => s.name === name)) {
          const newStrategy = { name: name, description: null };
          try {
            await addItem(STORE_STRATEGIES, newStrategy);
            tradingStrategies.push(newStrategy);
            tradingStrategies.sort((a, b) => a.name.localeCompare(b.name));
            renderStrategies();
            nameInput.value = "";
            showToast(`Strategy '${name}' added.`);
          } catch (error) {
            console.error("Error adding strategy:", error);
            alert("Error adding strategy: " + error.message);
          }
        }
      });

      /**
       * Renders the list of strategies in the management section and updates the select dropdown.
       */
      function renderStrategies() {
        // 1. Render management list
        strategyList.innerHTML = tradingStrategies
          .map(
            (s) => `
              <li class="flex justify-between items-center text-gray-700 dark:text-gray-300 p-2 hover:bg-gray-100 dark:hover:bg-gray-600 rounded-lg">
                <span>${s.name}</span>
                <button
                  onclick="deleteStrategy('${s.name.replace(/'/g, "\\'")}')"
                  class="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 text-sm font-semibold"
                >
                  Delete
                </button>
              </li>
            `
          )
          .join("");

        // 2. Update trade form dropdown
        strategySelect.innerHTML =
          '<option value="">Select a Strategy</option>' +
          tradingStrategies
            .map((s) => `<option value="${s.name}">${s.name}</option>`)
            .join("");
      }

      /**
       * Deletes a strategy by name.
       * @param {string} name - The name of the strategy to delete.
       */
      async function deleteStrategy(name) {
        // Check if any entries use this strategy
        const isUsed = journalEntries.some((e) => e.strategy === name);

        if (isUsed) {
          alert(
            `Cannot delete strategy "${name}" because it is currently used in one or more trade entries.`
          );
          return;
        }

        if (
          !confirm(`Are you sure you want to delete the strategy: "${name}"?`)
        ) {
          return;
        }

        try {
          await deleteItem(STORE_STRATEGIES, name);
          tradingStrategies = tradingStrategies.filter((s) => s.name !== name);
          renderStrategies();
          showToast(`Strategy '${name}' deleted.`);
        } catch (error) {
          console.error("Error deleting strategy:", error);
          alert("Error deleting strategy: " + error.message);
        }
      }

      // =========================================================================================================================
      // 5. Default Data and Utility Logic
      // =========================================================================================================================

      /**
       * Ensures default strategies are present on first run.
       */
      async function ensureDefaults() {
        if (tradingStrategies.length === 0) {
          const defaultStrategies = [
            { name: "Breakout", description: "Trading on price breaking key levels." },
            { name: "Reversal", description: "Trading on market turning points." },
            { name: "Trend Continuation", description: "Trading in the direction of the main trend." },
          ];

          for (const strategy of defaultStrategies) {
            await addItem(STORE_STRATEGIES, strategy);
          }
          tradingStrategies = defaultStrategies; // Update state after adding
        }
      }

      /**
       * Loads all entries and strategies from the database into state variables.
       */
      async function loadData() {
        tradingStrategies = await getAll(STORE_STRATEGIES);
        journalEntries = await getAll(STORE_ENTRIES);
        updateCurrencyPairs();
      }

      /**
       * Scans entries and populates the currency pair datalist.
       */
      function updateCurrencyPairs(newPair = null) {
        const pairs = new Set(journalEntries.map((e) => e.pair));
        if (newPair) {
          pairs.add(newPair);
        }
        currencyPairs = Array.from(pairs).sort();

        pairSuggestions.innerHTML = currencyPairs
          .map((pair) => `<option value="${pair}">`)
          .join("");
      }

      /**
       * Displays a toast notification.
       * @param {string} message
       */
      function showToast(message) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.classList.remove("hidden");
        toast.classList.add("opacity-100");

        setTimeout(() => {
          toast.classList.remove("opacity-100");
          toast.classList.add("opacity-0");
          setTimeout(() => toast.classList.add("hidden"), 300);
        }, 3000);
      }

      /**
       * Opens an image in a new tab/window (for viewing full size).
       * @param {string} base64Image
       */
      function viewImage(base64Image) {
        const newWindow = window.open();
        newWindow.document.write(
          `<img src="${base64Image}" style="max-width: 100%; height: auto;" />`
        );
        newWindow.document.title = "Trade Screenshot";
      }

      // =========================================================================================================================
      // 6. Data Import/Export Logic
      // =========================================================================================================================

      /**
       * Exports all trade entries as a CSV file.
       */
      exportBtn.addEventListener("click", () => {
        if (journalEntries.length === 0) {
          alert("No data to export.");
          return;
        }

        const dataToExport = journalEntries.map((entry) => ({
          ID: entry.id,
          Date: entry.date,
          Pair: entry.pair,
          Strategy: entry.strategy,
          Direction: entry.direction,
          Result: entry.result,
          Pips: entry.pips,
          Notes: entry.notes,
          Timestamp: entry.timestamp,
          // Base64 Image data is too long and complex for CSV, so we omit it for simplicity
          // Image_Base64: entry.image || "",
        }));

        const csv = Papa.unparse(dataToExport);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute(
          "download",
          `forex_journal_export_${new Date().toISOString().slice(0, 10)}.csv`
        );
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        showToast("Export successful!");
      });

      /**
       * Handles importing data from a CSV file.
       */
      importBtn.addEventListener("click", () => {
        if (
          !confirm(
            "Importing data will ADD new entries from the CSV. Ensure your CSV is correctly formatted. Continue?"
          )
        ) {
          return;
        }

        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".csv";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (file) {
            Papa.parse(file, {
              header: true,
              skipEmptyLines: true,
              complete: async (results) => {
                const importedEntries = results.data
                  .filter((row) => row.Date && row.Pair && row.Strategy) // Basic validation
                  .map((row) => ({
                    // We generate a new ID and timestamp for imported items
                    date: row.Date,
                    pair: row.Pair.toUpperCase(),
                    strategy: row.Strategy,
                    direction: row.Direction || "Long",
                    result: row.Result || "Break Even",
                    pips: parseFloat(row.Pips) || null,
                    image: null, // Images are not imported via CSV for simplicity
                    notes: row.Notes || null,
                    timestamp: row.Timestamp ? parseInt(row.Timestamp) : Date.now(),
                  }));

                if (importedEntries.length === 0) {
                  alert("No valid entries found in the CSV file.");
                  return;
                }

                try {
                    let importedCount = 0;
                    for (const entry of importedEntries) {
                        // For imported data, we always treat them as new entries to get a new ID
                        const newId = await addItem(STORE_ENTRIES, entry);
                        entry.id = newId;
                        journalEntries.push(entry);
                        importedCount++;

                        // Add new strategies on the fly
                        if (!tradingStrategies.some(s => s.name === entry.strategy)) {
                            const newStrategy = { name: entry.strategy, description: 'Imported Strategy' };
                            await addItem(STORE_STRATEGIES, newStrategy);
                            tradingStrategies.push(newStrategy);
                        }
                    }

                    // Re-sort and re-render everything
                    journalEntries.sort((a, b) => b.timestamp - a.timestamp);
                    tradingStrategies.sort((a, b) => a.name.localeCompare(b.name));

                    updateCurrencyPairs();
                    renderStrategies();
                    await renderJournalEntries();

                    showToast(`Successfully imported ${importedCount} trade entries!`);
                } catch (error) {
                    console.error("Error during import:", error);
                    alert("Error during data import. Check console for details.");
                }
              },
            });
          }
        };
        input.click();
      });

      /**
       * Clears all data from both tables.
       */
      deleteAllBtn.addEventListener("click", async () => {
        if (
          !confirm(
            "WARNING: This action will permanently DELETE ALL trade entries and ALL strategies. Are you absolutely sure you want to continue? This also clears the previously used IndexedDB database."
          )
        ) {
          return;
        }

        try {
          // 1. Clear IndexedDB (to ensure old data is gone)
          await new Promise((resolve, reject) => {
                // Attempt to open and delete the old IndexedDB database
                const DB_REQUEST = indexedDB.open("ForexJournalDB"); // Assuming this was the old IndexedDB name
                DB_REQUEST.onsuccess = (event) => {
                    event.target.result.close();
                    const deleteRequest = indexedDB.deleteDatabase("ForexJournalDB");
                    deleteRequest.onsuccess = () => {
                        console.log("Old IndexedDB cleared.");
                        resolve();
                    };
                    deleteRequest.onerror = (e) => {
                         // This is often a non-critical error, e.g. if the old DB didn't exist
                        console.warn("Could not clear old IndexedDB:", e.target.error);
                        resolve();
                    };
                    deleteRequest.onblocked = () => {
                        console.warn("Could not clear old IndexedDB: Blocked.");
                        resolve();
                    };
                };
                DB_REQUEST.onerror = (e) => {
                    console.warn("Could not open old IndexedDB:", e.target.error);
                    resolve();
                };
            });

          // 2. Clear SQLite DB
          await Sqlite.execute({
              database: db,
              statements: `
                  DELETE FROM ${STORE_ENTRIES};
                  DELETE FROM ${STORE_STRATEGIES};
              `
          });
          
          // Optionally drop the database and recreate it for a complete clear, but DELETE FROM is usually sufficient.
          // await Sqlite.dropDatabase({ database: db });
          // await openDB();

          // Reset state
          journalEntries = [];
          tradingStrategies = [];
          await renderJournalEntries();
          renderStrategies();
          updateCurrencyPairs();
          await ensureDefaults(); // Re-add defaults after clearing

          showToast("All data has been cleared!");
        } catch (error) {
          console.error("Error clearing database:", error);
          alert("Error clearing all data: " + error.message);
        }
      });

      // =========================================================================================================================
      // 7. Initialization
      // =========================================================================================================================

<<<<<<< HEAD
      /**
       * Main initialization function for the app.
       */
      async function init() {
=======
              if (preInput) {
                if (preInput.files && preInput.files.length) {
                  entry.preTradeImage = await resizeAndConvertToBase64(
                    preInput.files[0]
                  );
                } else if (preInput.dataset && preInput.dataset.existing) {
                  entry.preTradeImage = preInput.dataset.existing;
                }
              }
              if (postInput) {
                if (postInput.files && postInput.files.length) {
                  entry.postTradeImage = await resizeAndConvertToBase64(
                    postInput.files[0]
                  );
                } else if (postInput.dataset && postInput.dataset.existing) {
                  entry.postTradeImage = postInput.dataset.existing;
                }
              } // clear file input datasets so next edit will load fresh

              // ... (Your logic for refreshing the UI) ...

              if (preInput) {
                preInput.value = "";
                delete preInput.dataset.existing;
              }
              if (postInput) {
                postInput.value = "";
                delete postInput.dataset.existing;
              }

              // üí• FIX: Clear all form fields (textareas, inputs, etc.)
              // This stops the old entry data from being submitted as a new entry.
              if (form) {
                form.reset();
              }

              // ... (Rest of the code) ...

              // determine editing or new
              const editingId =
                formEl.dataset.editingId || fd.get("id") || fd.get("entryId");
              if (editingId) {
                entry.id = Number(editingId);
                await putEntry(entry);
              } else {
                // ensure id exists
                entry.id = entry.id ? Number(entry.id) : Date.now();
                await putEntry(entry);
              }

              // refresh UI: call render function if exists, else reload entries if function exists
              if (typeof window.renderJournalEntries === "function") {
                try {
                  await window.renderJournalEntries();
                } catch (e) {}
              } else if (typeof window.loadEntries === "function") {
                try {
                  await window.loadEntries();
                } catch (e) {}
              } else {
                // fallback: reload page
                try {
                  location.reload();
                } catch (e) {}
              }

              // close modal if present
              const modal = document.getElementById("addEntryModal");
              if (modal) modal.classList.add("hidden");

              // clear file input datasets so next edit will load fresh
              if (preInput) {
                preInput.value = "";
                delete preInput.dataset.existing;
              }
              if (postInput) {
                postInput.value = "";
                delete postInput.dataset.existing;
              }

              // show success if function exists
              if (typeof window.showMessageModal === "function") {
                try {
                  window.showMessageModal(
                    "Entry saved successfully.",
                    "success"
                  );
                } catch (e) {}
              } else {
                try {
                  alert("Entry saved successfully.");
                } catch (e) {}
              }
            } catch (err) {
              console.error("handleFormSave error", err);
              try {
                alert("Failed to save entry: " + err.message);
              } catch (e) {}
            }
          }

          // enhance journalList rendering by ensuring thumbnails are set after render
          const origRender = window.renderJournalEntries;
          if (typeof origRender === "function") {
            window.renderJournalEntries = async function () {
              await origRender();
              // apply thumbnails on all rendered cards
              try {
                const list =
                  document.getElementById("journalList") ||
                  document.querySelector(".journal-list");
                if (!list) return;
                const items = list.querySelectorAll("[data-entry-id]");
                for (const el of items) {
                  const id =
                    el.dataset.entryId || el.getAttribute("data-entry-id");
                  if (!id) continue;
                  const data = await getEntryById(Number(id));
                  if (!data) continue;
                  // find img placeholders inside card
                  const preImg = el.querySelector(
                    "#preThumb, .preThumb, .pre-trade-img, img.pre-trade"
                  );
                  const postImg = el.querySelector(
                    "#postThumb, .postThumb, .post-trade-img, img.post-trade"
                  );
                  if (preImg && data.preTradeImage)
                    preImg.src = data.preTradeImage;
                  if (postImg && data.postTradeImage)
                    postImg.src = data.postTradeImage;
                }
              } catch (e) {
                console.warn(e);
              }
            };
          }
        }); // DOMContentLoaded
      })();
    </script>
    <script>
      async function initApp() {
>>>>>>> a0823573854bb126707a7d2b60927a607b5f1138
        const splash = document.getElementById("splash-screen");
        const ring = document.getElementById("splash-ring");
        const percentText = document.getElementById("splash-percent");
        const splashText = document.getElementById("splash-text");

        function updateSplash(progress, text) {
          const percent = Math.min(100, progress);
          const dashOffset = 283 - (283 * percent) / 100;
          ring.style.strokeDashoffset = dashOffset;
          percentText.textContent = `${percent}%`;
          splashText.textContent = text;
        }

        try {
          splash.style.display = "flex";
          updateSplash(0, "Opening database...");

          // 1. Open/Create SQLite DB and Tables
          await openDB();
          updateSplash(20, "Loading all data...");

          // 2. Load all data (strategies & entries)
          await loadData();
          updateSplash(40, "Ensuring default strategies...");

          // 3. Add default strategies if necessary
          await ensureDefaults();
          updateSplash(60, "Rendering strategies...");

          // 4. Render Strategies and Update Pair list
          renderStrategies();
          updateSplash(80, "Rendering journal entries...");

          // 5. Render Journal Entries
          await renderJournalEntries();
          updateSplash(90, "Setting up form...");

          // 6. Set default date to today and initialize listeners
          document.getElementById("tradeDate").valueAsDate = new Date();
          initImageListeners(); // Initialize image handlers
          updateSplash(100, "Ready!");
        } catch (err) {
          console.error("Initialization failed:", err);
          splashText.textContent = "Error loading app üòû";
          ring.classList.add("text-red-500");
        } finally {
          // Short pause for polish
          setTimeout(() => {
            splash.classList.add("opacity-0");
            setTimeout(() => splash.remove(), 700);
          }, 800);
        }
      }

      window.addEventListener("DOMContentLoaded", init);
    </script>
<<<<<<< HEAD
  </body>
</html>
=======
  
<!-- BEGIN RUNTIME OVERRIDE: FORCE BLOB IMAGE SAVING -->
<script>
(function(){
  // Helpers
  async function fileToBlob(file, maxWidth=800) {
    if (!file) return null;
    if (file instanceof Blob) return file;
    return await new Promise((resolve, reject) => {
      try {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            try {
              const canvas = document.createElement('canvas');
              const scale = Math.min(1, maxWidth / img.width);
              canvas.width = Math.round(img.width * scale);
              canvas.height = Math.round(img.height * scale);
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              canvas.toBlob((blob)=>resolve(blob), 'image/jpeg', 0.8);
            } catch (err) { reject(err); }
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      } catch (err) { reject(err); }
    });
  }

  function blobToBase64(blob){
    return new Promise((resolve,reject)=>{
      if (!blob) return resolve(null);
      const r = new FileReader();
      r.onloadend = ()=>{ const parts = r.result.split(','); resolve(parts[1]); };
      r.onerror = reject;
      r.readAsDataURL(blob);
    });
  }

  function setImgSrc(el, data){
    if(!el) return;
    try{
      if (data && (typeof Blob !== 'undefined') && data instanceof Blob){
        if (el.dataset.objurl) { URL.revokeObjectURL(el.dataset.objurl); delete el.dataset.objurl; }
        const url = URL.createObjectURL(data);
        el.src = url;
        el.dataset.objurl = url;
      } else if (data){
        el.src = data;
      } else {
        el.removeAttribute('src');
      }
    } catch(e){ console.warn(e); }
  }

  // Intercept the form submit early in capture phase to prevent existing handlers that convert to base64
  document.addEventListener('submit', async function(ev){
    // Only intercept the main journal form
    try{
      const form = ev.target;
      if (!form || !(form.id === 'journalForm' || form.querySelector('#entryPrice') || form.querySelector('[name=\"entryPrice\"]'))) return;
      // Stop other handlers from running
      ev.stopImmediatePropagation();
      ev.preventDefault();

      // Build entry object (similar to app's logic)
      const fd = new FormData(form);
      const entry = {};
      for (const [k,v] of fd.entries()) entry[k]=v;

      // strategies
      if (typeof window.getSelectedStrategies === 'function') {
        const sel = window.getSelectedStrategies();
        if (sel && sel.length) entry.strategies = sel;
      }

      // handle images: if file selected -> convert to Blob; else if dataset.existingBlob -> reuse DB blob; else if dataset.existing (string) -> keep string
      const preInput = document.getElementById('preTradeImage');
      const postInput = document.getElementById('postTradeImage');

      async function resolveInput(inputEl){
        if (!inputEl) return null;
        if (inputEl.files && inputEl.files.length) {
          return await fileToBlob(inputEl.files[0]);
        }
        if (inputEl.dataset && inputEl.dataset.existingblob === '1') {
          // indicate to reuse existing blob: we set special marker __REUSE_BLOB__
          return '__REUSE_BLOB__';
        }
        if (inputEl.dataset && inputEl.dataset.existing) return inputEl.dataset.existing;
        return null;
      }

      const preResolved = await resolveInput(preInput);
      const postResolved = await resolveInput(postInput);

      // If editing an entry, we should fetch the existing entry to reuse blobs when needed
      let editingId = null;
      if (form.dataset && form.dataset.editingId) editingId = Number(form.dataset.editingId);
      if (!editingId) {
        // try other possible sources
        if (entry.id) editingId = Number(entry.id);
      }

      // If reuse markers present and editingId known, fetch existing and reuse actual blob
      if (editingId && (preResolved==='__REUSE_BLOB__' || postResolved==='__REUSE_BLOB__')){
        if (typeof window.getEntryById === 'function') {
          try{
            const existing = await window.getEntryById(Number(editingId));
            if (preResolved==='__REUSE_BLOB__' && existing && existing.preTradeImage) entry.preTradeImage = existing.preTradeImage;
            else if (preResolved && preResolved!=='__REUSE_BLOB__') entry.preTradeImage = preResolved;
            if (postResolved==='__REUSE_BLOB__' && existing && existing.postTradeImage) entry.postTradeImage = existing.postTradeImage;
            else if (postResolved && postResolved!=='__REUSE_BLOB__') entry.postTradeImage = postResolved;
          } catch(e){ 
            if (preResolved && preResolved!=='__REUSE_BLOB__') entry.preTradeImage = preResolved;
            if (postResolved && postResolved!=='__REUSE_BLOB__') entry.postTradeImage = postResolved;
          }
        } else {
          if (preResolved && preResolved!=='__REUSE_BLOB__') entry.preTradeImage = preResolved;
          if (postResolved && postResolved!=='__REUSE_BLOB__') entry.postTradeImage = postResolved;
        }
      } else {
        if (preResolved && preResolved!=='__REUSE_BLOB__') entry.preTradeImage = preResolved;
        if (postResolved && postResolved!=='__REUSE_BLOB__') entry.postTradeImage = postResolved;
      }

      // If entries should store blob objects directly, keep Blobs. For any string dataURLs, they remain strings.
      // Save entry to DB using existing putItem/addItem/putEntry functions if available
      if (editingId) entry.id = editingId;
      try {
        if (typeof window.putEntry === 'function') {
          await window.putEntry(entry);
        } else if (typeof window.putItem === 'function') {
          await window.putItem('entries', entry);
        } else if (typeof window.addItem === 'function' && !editingId) {
          await window.addItem('entries', entry);
        } else if (typeof window.putItem === 'function') {
          await window.putItem('entries', entry);
        } else {
          // fallback to indexedDB direct put
          if (typeof window.openDB === 'function') {
            const db = await window.openDB();
            const tx = db.transaction('entries','readwrite');
            tx.objectStore('entries').put(entry);
            await tx.complete;
          }
        }
      } catch(err){
        console.error('Override save failed', err);
        try { alert('Failed to save entry (override): '+err.message); } catch(e) {}
        return;
      }

      // Refresh UI: try to call existing refresh functions
      if (typeof window.renderJournalEntries === 'function') {
        try { await window.renderJournalEntries(); } catch(e) {}
      } else if (typeof window.loadEntries === 'function') {
        try { await window.loadEntries(); } catch(e) {}
      } else {
        try { location.reload(); } catch(e) {}
      }

      // Clean up form
      try { form.reset(); } catch(e) {}
      const modal = document.getElementById('addEntryModal');
      if (modal) modal.classList.add('hidden');

      // Show success if available
      if (typeof window.showMessageModal === 'function') {
        try { window.showMessageModal('Entry saved successfully (blob override).','success'); } catch(e) {}
      } else {
        try { console.log('Saved (override)'); } catch(e) {}
      }
    } catch(e){
      console.error('Submit override error', e);
    }
  }, true /* useCapture to run before default handlers */);
  
  // Also patch image thumbnail application to support Blob -> objectURL
  function patchRenderThumbnails(){
    try{
      const list = document.getElementById('journalList') || document.querySelector('.journal-list');
      if (!list) return;
      // when renderJournalEntries runs it will call existing logic which sets src to string;
      // We will post-process cards to convert any Blob stored in DB to objectURLs for img.src
      if (typeof window.renderJournalEntries === 'function') {
        const old = window.renderJournalEntries;
        window.renderJournalEntries = async function(filteredEntries){
          await old(filteredEntries);
          try{
            const items = document.querySelectorAll('[data-entry-id]');
            for (const el of items){
              const id = el.dataset.entryId || el.getAttribute('data-entry-id');
              if (!id) continue;
              if (typeof window.getEntryById === 'function') {
                const data = await window.getEntryById(Number(id));
                if (!data) continue;
                const preImg = el.querySelector('#preThumb, .preThumb, .pre-trade-img, img.pre-trade');
                const postImg = el.querySelector('#postThumb, .postThumb, .post-trade-img, img.post-trade');
                if (preImg) setImgSrc(preImg, data.preTradeImage);
                if (postImg) setImgSrc(postImg, data.postTradeImage);
              }
            }
          } catch(e){ console.warn(e); }
        }
      }
    } catch(e){ console.warn('patchRenderThumbnails failed', e); }
  }
  // Run once DOM ready
  if (document.readyState === 'complete' || document.readyState === 'interactive') patchRenderThumbnails();
  else document.addEventListener('DOMContentLoaded', patchRenderThumbnails);
})();
</script>
<!-- END RUNTIME OVERRIDE -->
</body>
</html>
>>>>>>> a0823573854bb126707a7d2b60927a607b5f1138
