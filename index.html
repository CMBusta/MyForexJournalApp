<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Forex Trading Journal (Offline Ready)</title>
    <link rel="stylesheet" href="./output.css" />
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

    <!-- <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;display=swap"
      rel="stylesheet"
    /> -->
    <style>
      /* 7. UI and Design Polish: Custom Scrollbar Styles */
      body {
        font-family: "Inter", sans-serif;
        transition: background-color 0.3s, color 0.3s;
      }

      .scrollable-list {
        max-height: 70vh;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #4f46e5 #f5f7fa;
      }

      .scrollable-list::-webkit-scrollbar {
        width: 10px;
      }

      .scrollable-list::-webkit-scrollbar-track {
        background: #f5f7fa;
        border-radius: 10px;
      }

      .scrollable-list::-webkit-scrollbar-thumb {
        background-color: #4f46e5;
        border-radius: 10px;
        border: 2px solid #f5f7fa;
      }

      html.dark .scrollable-list {
        scrollbar-color: #7c3aed #262626;
      }

      html.dark .scrollable-list::-webkit-scrollbar-track {
        background: #262626;
      }

      html.dark .scrollable-list::-webkit-scrollbar-thumb {
        background-color: #7c3aed;
        border: 2px solid #262626;
      }

      /* Custom styles for color selector blocks */
      .color-block.selected,
      .shade-block.selected {
        border-width: 3px;
        border-color: #4f46e5;
        /* Indigo-600 */
      }

      html.dark .color-block.selected,
      html.dark .shade-block.selected {
        border-color: #7c3aed;
        /* Violet-600 */
      }

      /* Image viewer styles for pan/zoom */
      #zoomedImage {
        max-width: 95%;
        max-height: 95%;
        transition: transform 0.2s ease-out;
        transform: scale(1);
      }

      /* Hide the ugly file input button but keep functionality */
      input[type="file"]::file-selector-button {
        display: none;
      }
    </style>
    <style>
      @media (min-width: 768px) {
        html {
          font-size: 1.05rem;
        }

        body {
          padding: 2rem !important;
        }

        .container {
          gap: 2rem !important;
        }

        .form-section,
        .journal-list-section {
          width: 50% !important;
        }

        .form-section input,
        .form-section select,
        .form-section textarea {
          font-size: 1rem !important;
          padding: 0.8rem 1rem !important;
        }

        button {
          padding-top: 0.9rem !important;
          padding-bottom: 0.9rem !important;
          padding-left: 1.25rem !important;
          padding-right: 1.25rem !important;
        }

        .scrollable-list {
          max-height: 80vh !important;
        }

        #messageModal > div,
        #strategiesModal > div,
        #rawDataModal > div,
        #strategyDbModal > div {
          max-width: 90% !important;
        }
      }

      @media (min-width: 1024px) {
        html {
          font-size: 1.1rem;
        }

        .form-section,
        .journal-list-section {
          width: 50% !important;
        }
      }
    </style>
    <style>
      @media (max-width: 767px) {
        html {
          font-size: 0.95rem;
        }

        body {
          padding: 1rem !important;
        }

        .container {
          flex-direction: column !important;
          gap: 1rem !important;
        }

        .form-section,
        .journal-list-section {
          width: 100% !important;
          padding: 1rem !important;
        }

        button {
          padding-top: 0.6rem !important;
          padding-bottom: 0.6rem !important;
          padding-left: 0.9rem !important;
          padding-right: 0.9rem !important;
          font-size: 0.9rem !important;
        }

        input,
        select,
        textarea {
          font-size: 0.9rem !important;
          padding: 0.6rem 0.75rem !important;
        }

        .scrollable-list {
          max-height: 75vh !important;
        }

        #messageModal > div,
        #strategiesModal > div,
        #rawDataModal > div,
        #strategyDbModal > div {
          max-width: 95% !important;
          margin: 0 0.5rem !important;
          padding: 1rem !important;
        }

        h1,
        h2,
        h3 {
          font-size: 1.1rem !important;
        }
      }
    </style>
    <style>
      .journal-list-section {
        width: 100% !important;
      }

      #addEntryModalContent {
        max-height: 90vh;
        overflow-y: auto;
      }
    </style>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->

    <script>
      tailwind.config = { darkMode: "class" };
    </script>
    <script defer src="./papaparse.min.js"></script>
    <style>
      .entry-strategies {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        justify-content: flex-end;
        align-items: flex-start;
        max-width: 100%;
        overflow: visible;
      }
      .entry-images {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.5rem;
      }

      #strategyColorPicker::-webkit-color-swatch-wrapper {
        padding: 0;
      }
      #strategyColorPicker::-webkit-color-swatch {
        border: none;
        border-radius: 50%;
      }
    </style>
    <style>
      html,
      body {
        height: 100%;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch; /* Smooth mobile scroll */
        touch-action: pan-y; /* Allow vertical swipe */
      }

      .scrollable-list {
        -webkit-overflow-scrolling: touch; /* Enable iOS/Android scroll */
        overscroll-behavior: contain;
        scroll-behavior: smooth;
        scrollbar-width: none; /* Hide scrollbar (Firefox) */
      }

      .scrollable-list::-webkit-scrollbar {
        display: none; /* Hide scrollbar (WebKit) */
      }
    </style>
    <style>
      /* Ensure body can scroll vertically on touch devices */
      html,
      body {
        overflow-y: auto !important;
        -webkit-overflow-scrolling: touch !important;
      }
    </style>
    <style>
      html,
      body {
        height: auto !important;
        min-height: 100vh !important;
        overflow-y: auto !important;
        -webkit-overflow-scrolling: touch !important;
        touch-action: pan-y !important;
      }

      body {
        display: block !important;
      }

      .scrollable-list {
        -webkit-overflow-scrolling: touch !important;
        overflow-y: auto !important;
        overscroll-behavior: contain;
        scrollbar-width: none;
      }
      .scrollable-list::-webkit-scrollbar {
        display: none;
      }
    </style>
  </head>
  <body
    class="p-4 sm:p-6 min-h-screen relative bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-gray-100"
    style="
      display: block !important;
      overflow-y: auto !important;
      height: auto !important;
      min-height: 100vh !important;
    "
  >
    <!-- üåä Splash Screen -->
    <div
      id="splash-screen"
      class="fixed inset-0 flex flex-col items-center justify-center bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-100 z-[9999] transition-opacity duration-700"
    >
      <!-- Logo -->
      <img
        src="icon.png"
        alt="App Logo"
        class="w-20 h-20 mb-5 rounded-xl shadow-lg animate-bounce"
      />

      <!-- App name -->
      <h1 class="text-2xl font-bold text-indigo-700 dark:text-violet-500 mb-6">
        Forex Journal
      </h1>

      <!-- Circular Progress with Rotating Spinner -->
      <div class="relative w-24 h-24 mb-4">
        <svg class="w-24 h-24 transform -rotate-90" viewBox="0 0 100 100">
          <circle
            cx="50"
            cy="50"
            r="45"
            class="text-gray-300 dark:text-gray-700 fill-none"
            stroke="currentColor"
            stroke-width="8"
          />
          <circle
            id="splash-ring"
            cx="50"
            cy="50"
            r="45"
            class="text-indigo-600 dark:text-violet-500 fill-none stroke-[8] transition-all duration-300 ease-out"
            stroke="currentColor"
            stroke-width="8"
            stroke-dasharray="283"
            stroke-dashoffset="283"
          />
        </svg>

        <!-- Rotating Spinner Overlay -->
        <div class="absolute inset-0 flex items-center justify-center">
          <div
            class="w-16 h-16 border-4 border-indigo-300 dark:border-violet-700 border-t-transparent rounded-full animate-spin"
          ></div>
        </div>

        <!-- Percentage Text -->
        <div class="absolute inset-0 flex items-center justify-center">
          <span
            id="splash-percent"
            class="text-lg font-semibold text-indigo-700 dark:text-violet-400"
            >0%</span
          >
        </div>
      </div>

      <!-- Status Message -->
      <p
        id="splash-text"
        class="text-sm text-gray-600 dark:text-gray-400 animate-pulse"
      >
        Initializing...
      </p>
    </div>

    <div class="mt-4 space-y-2">
      <button
        class="w-full py-2 px-4 bg-violet-600 text-white font-semibold rounded-lg shadow-md hover:bg-violet-700 transition duration-300 flex items-center justify-center space-x-2"
        id="strategiesBtn"
      >
        <svg
          class="w-5 h-5"
          fill="currentColor"
          viewbox="0 0 20 20"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            clip-rule="evenodd"
            d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16ZM6.75 9.25a.75.75 0 0 0 0 1.5h6.5a.75.75 0 0 0 0-1.5h-6.5Z"
            fill-rule="evenodd"
          ></path>
        </svg>
        <span class="md:inline">Strategies</span>
      </button>
      <input accept=".csv" class="hidden" id="csvFileInput" type="file" />
      <button
        class="w-full py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 flex items-center justify-center space-x-2"
        id="importCsvBtn"
      >
        <svg
          class="w-5 h-5"
          fill="currentColor"
          viewbox="0 0 20 20"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            clip-rule="evenodd"
            d="M10 2a.75.75 0 0 1 .75.75v10.63l2.47-2.47a.75.75 0 1 1 1.06 1.06l-3.75 3.75a.75.75 0 0 1-1.06 0l-3.75-3.75a.75.75 0 1 1 1.06-1.06l2.47 2.47V2.75A.75.75 0 0 1 10 2Z"
            fill-rule="evenodd"
          ></path>
        </svg>
        <span class="md:inline">Import (CSV)</span>
      </button>
      <!-- ‚úÖ Hidden CSV file input with broader MIME types for Android compatibility -->
      <input
        accept=".csv,text/csv,text/plain,text/comma-separated-values,application/vnd.ms-excel"
        id="csvFileInput"
        style="display: none"
        type="file"
      />
      <script>
        const importBtn = document.getElementById("importCsvBtn");
        const csvInput = document.getElementById("csvFileInput");

        if (importBtn && csvInput) {
          importBtn.addEventListener("click", () => csvInput.click());

          csvInput.addEventListener("change", (event) => {
            const file = event.target.files[0];
            if (!file) return;

            console.log("Selected file:", file.name);

            const reader = new FileReader();
            reader.onload = function (e) {
              const csvContent = e.target.result;
              console.log("CSV content loaded.");
              // üîß Add your CSV import logic here
            };
            reader.readAsText(file);
          });
        }
      </script>

      <button
        class="bg-green-600 hover:bg-green-700 text-white font-semibold px-4 py-2 rounded-lg shadow-md transition duration-300 hidden"
        id="backupCsvBtn"
      >
        Backup (CSV)
      </button>
      <button
        class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold px-4 py-2 rounded-lg shadow-md transition duration-300 hidden"
        id="restoreCsvBtn"
      >
        Restore (CSV)
      </button>
      <button
        class="bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2 rounded-lg shadow-md transition duration-300"
        id="backupJsonBtn"
      >
        Backup (JSON)
      </button>
      <button
        class="bg-orange-500 hover:bg-orange-600 text-white font-semibold px-4 py-2 rounded-lg shadow-md transition duration-300"
        id="restoreJsonBtn"
      >
        Restore (JSON)
      </button>
      <input
        type="file"
        id="jsonFileInput"
        accept="application/json"
        style="display: none"
      />

      <button
        class="w-full py-2 px-4 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-800 transition duration-300 flex items-center justify-center space-x-2 dark:bg-gray-600 dark:hover:bg-gray-700"
        id="showDbDataBtn"
      >
        <svg
          class="w-5 h-5"
          fill="currentColor"
          viewbox="0 0 20 20"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            clip-rule="evenodd"
            d="M3.5 2.75A.75.75 0 0 0 2.75 3.5v13a.75.75 0 0 0 .75.75h13a.75.75 0 0 0 .75-.75v-13a.75.75 0 0 0-.75-.75h-13ZM15 4.5H5v11h10V4.5Z"
            fill-rule="evenodd"
          ></path>
          <path
            d="M5.5 8a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1H6a.5.5 0 0 1-.5-.5ZM5.5 11a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5Z"
          ></path>
        </svg>
        <span class="md:inline">Show Raw Data</span>
      </button>
      <!-- <button
        class="w-full py-2 px-4 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-300 flex items-center justify-center space-x-2"
        id="strategyDbBtn"
      >
        <svg
          class="w-5 h-5"
          fill="currentColor"
          viewbox="0 0 20 20"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M10 2a8 8 0 100 16 8 8 0 000-16zM9 5h2v5H9V5zm0 6h2v2H9v-2z"
          ></path>
        </svg>
        <span class="md:inline">Manage Strategies (DB)</span>
      </button> -->
      <button
        class="w-full py-2 px-4 bg-gray-400 text-white font-semibold rounded-lg shadow-md hover:bg-gray-500 transition duration-300 hidden"
        id="exportCsvBtn"
      >
        Export CSV (hidden by default)
      </button>
      <button
        class="fixed top-4 right-4 p-3 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-yellow-400 shadow-lg z-30 transition duration-300 hover:scale-105"
        id="darkModeToggle"
      >
        <span class="dark:hidden">üåô</span>
        <span class="hidden dark:inline">‚òÄÔ∏è</span>
      </button>
      <div
        class="container mx-auto p-4 md:p-6 rounded-2xl shadow-xl flex flex-col md:flex-row gap-4 md:gap-8 bg-white dark:bg-gray-900 max-w-7xl"
      >
        <div class="flex justify-center items-center w-full">
          <div
            class="w-full md:w-1/3 p-6 rounded-xl shadow-lg bg-gray-50 dark:bg-gray-800 form-section center"
          >
            <div class="flex items-center justify-center gap-3 mb-6">
              <img
                alt="Forex Journal Logo"
                class="w-14 h-14 rounded-lg shadow-md"
                src="icon.png"
              /><span
                class="text-3xl font-bold text-indigo-700 dark:text-violet-600"
                >Forex Journal</span
              >
            </div>
            <!-- Add Entry Modal (inserted) -->
            <div
              class="fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-black dark:bg-opacity-70 flex items-center justify-center hidden z-50 transition-opacity duration-300 opacity-0"
              id="addEntryModal"
            >
              <div
                class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-3xl w-full mx-4 transform transition-transform duration-300 scale-95"
                id="addEntryModalContent"
              >
                <div class="flex justify-between items-center mb-4">
                  <h2
                    class="text-2xl font-bold text-indigo-700 dark:text-violet-600"
                  >
                    Add Journal Entry
                  </h2>
                  <button
                    class="text-gray-600 dark:text-gray-200 hover:text-gray-900"
                    id="closeAddEntryModalBtn"
                  >
                    ‚úï
                  </button>
                </div>
                <form class="space-y-4" id="journalForm">
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="date"
                      >Date</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="date"
                      name="date"
                      required=""
                      type="date"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="time"
                      >Time (Entry)</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="time"
                      name="time"
                      placeholder="HH:MM or HHMM (e.g., 0445)"
                      required=""
                      type="text"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="pair"
                      >Pair</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="pair"
                      name="pair"
                    >
                      <option value="GBP/USD">GBP/USD</option>
                      <option value="EUR/USD">EUR/USD</option>
                      <option value="USD/JPY">USD/JPY</option>
                      <option value="AUD/USD">AUD/USD</option>
                      <option value="USD/CAD">USD/CAD</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="direction"
                      >Direction</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="direction"
                      name="direction"
                    >
                      <option value="Buy">Buy</option>
                      <option value="Sell">Sell</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="strategyInput"
                      >Strategy</label
                    >
                    <div
                      class="p-3 rounded-lg bg-gray-200 dark:bg-gray-700 grid grid-cols-2 gap-2 md:grid-cols-3"
                      id="indicatorsContainer"
                    ></div>
                    <input
                      class="mt-2 w-full p-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                      id="strategy"
                      name="strategy"
                      placeholder="Select a strategy above"
                      readonly=""
                      type="text"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="timeFrame"
                      >Time Frame</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="timeFrame"
                      name="timeFrame"
                    >
                      <option value="M1">M1</option>
                      <option value="M5">M5</option>
                      <option value="M15">M15</option>
                      <option value="M30">M30</option>
                      <option value="H1">H1</option>
                      <option value="H4">H4</option>
                      <option value="D1">D1</option>
                      <option value="W1">W1</option>
                      <option value="MN">MN</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="entryPrice"
                      >Entry Price</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="entryPrice"
                      name="entryPrice"
                      step="0.00001"
                      type="number"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="slPrice"
                      >SL Price</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="slPrice"
                      name="slPrice"
                      step="0.00001"
                      type="number"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="tpPrice"
                      >TP Price</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="tpPrice"
                      name="tpPrice"
                      step="0.00001"
                      type="number"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="exitPrice"
                      >Exit Price</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="exitPrice"
                      name="exitPrice"
                      step="0.00001"
                      type="number"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="exitReason"
                      >Exit Reason</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="exitReason"
                      name="exitReason"
                    >
                      <option value="TP">TP</option>
                      <option value="SL">SL</option>
                      <option value="Exited Early">Exited Early</option>
                      <option value="Break-Even">Break-Even</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="lotSize"
                      >Lot Size</label
                    >
                    <input
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="lotSize"
                      name="lotSize"
                      step="0.01"
                      type="number"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="setupGrade"
                      >Setup Grade</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="setupGrade"
                      name="setupGrade"
                    >
                      <option value="A">A</option>
                      <option value="B">B</option>
                      <option value="C">C</option>
                      <option value="D">D</option>
                      <option value="F">F</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="didFollowPlan"
                      >Did I Follow My Plan?</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="didFollowPlan"
                      name="didFollowPlan"
                    >
                      <option value="Yes">Yes</option>
                      <option value="No">No</option>
                      <option value="Some">Some</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="emotionalState"
                      >Emotional State</label
                    >
                    <select
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="emotionalState"
                      name="emotionalState"
                    >
                      <option value="Calm">Calm</option>
                      <option value="Doubtful">Doubtful</option>
                      <option value="Slightly Confident">
                        Slightly Confident
                      </option>
                      <option value="Confident">Confident</option>
                      <option value="Stressed">Stressed</option>
                      <option value="Excited">Excited</option>
                      <option value="Greedy">Greedy</option>
                      <option value="Fearful">Fearful</option>
                    </select>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="preTradeImage"
                      >Pre-Trade Screenshot (&lt;1MB)</label
                    >
                    <input
                      accept="image/*"
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="preTradeImage"
                      name="preTradeImage"
                      type="file"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="postTradeImage"
                      >Post-Trade Screenshot (&lt;1MB)</label
                    >
                    <input
                      accept="image/*"
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="postTradeImage"
                      name="postTradeImage"
                      type="file"
                    />
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="lessonsLearned"
                      >Lessons Learned</label
                    >
                    <textarea
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus:border-indigo-500"
                      id="lessonsLearned"
                      name="lessonsLearned"
                      rows="3"
                    ></textarea>
                  </div>
                  <div class="flex flex-col">
                    <label
                      class="text-sm font-medium text-gray-700 dark:text-gray-300"
                      for="notes"
                      >Notes</label
                    >
                    <textarea
                      class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-indigo-500 focus;border-indigo-500"
                      id="notes"
                      name="notes"
                      rows="3"
                    ></textarea>
                  </div>
                  <button
                    class="w-full py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 flex items-center justify-center space-x-2"
                    id="submitBtn"
                    type="submit"
                  >
                    <svg
                      class="w-5 h-5"
                      fill="currentColor"
                      id="submitBtnIcon"
                      viewbox="0 0 20 20"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      <path
                        d="M7.74 3.425a.75.75 0 0 1 .424-.047l7.74 1.72a.75.75 0 0 1 .596.74v.928a1.5 1.5 0 0 1-.806 1.34L14.473 9.42a2.5 2.5 0 0 0-1.282 2.228v.57a.75.75 0 0 1-.364.646L9.67 15.602a3.033 3.033 0 0 1-2.924 0l-3.217-2.31a.75.75 0 0 1-.364-.647v-.57a2.5 2.5 0 0 0-1.282-2.228L.89 7.493a1.5 1.5 0 0 1-.805-1.34V5.118a.75.75 0 0 1 .596-.74l7.74-1.72a.75.75 0 0 1 .424.047Z"
                      ></path>
                    </svg>
                    <span class="md:inline">Add Journal Entry</span>
                  </button>
                </form>
                <div class="mt-4 flex justify-end">
                  <button
                    class="py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300 mr-2"
                    id="closeAddEntryModalFooterBtn"
                  >
                    Close
                  </button>
                  <!-- Keep the original submit button inside the form; footer Close only hides modal -->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div
        class="w-full md:w-2/3 p-6 rounded-xl shadow-lg bg-gray-50 dark:bg-gray-800 journal-list-section"
      >
        <h2
          class="text-2xl font-bold text-center text-indigo-700 dark:text-violet-600 mb-6"
        >
          Journal Entries
        </h2>
        <div
          class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6 p-4 border border-gray-200 dark:border-gray-700 rounded-xl bg-white dark:bg-gray-900 shadow-inner"
          id="metricsDashboard"
        ></div>
        <!-- === Strategy Usage List === -->
        <div
          class="space-y-2 p-4 border border-gray-200 dark:border-gray-700 rounded-xl bg-white dark:bg-gray-900 shadow-inner mt-6"
          id="strategyUsageList"
        >
          <h3
            class="text-lg font-bold text-indigo-700 dark:text-violet-600 mb-2"
          >
            Strategy Usage Count
          </h3>
          <div
            class="grid grid-cols-2 sm:grid-cols-3 gap-3"
            id="strategyUsageContent"
          >
            <!-- Strategy count items will be rendered here -->
          </div>
        </div>
        <div
          class="space-y-4 mb-6 p-4 border border-gray-200 dark:border-gray-700 rounded-xl bg-white dark:bg-gray-900 shadow-inner"
        >
          <div class="flex flex-col">
            <div class="mb-4">
              <input
                class="w-full p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark;border-gray-600 focus:ring-indigo-500 focus;border-indigo-500"
                id="filterInput"
                placeholder="Filter by Pair, Strategy, or Trade ID..."
                type="text"
              />
            </div>
            <!-- Date Range Filter -->
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
              <div class="flex flex-col">
                <label
                  class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-1"
                  for="startDate"
                  >From Date &amp; Time</label
                >
                <input
                  class="p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600"
                  id="startDate"
                  type="datetime-local"
                />
              </div>
              <div class="flex flex-col">
                <label
                  class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-1"
                  for="endDate"
                  >To Date &amp; Time</label
                >
                <input
                  class="p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600"
                  id="endDate"
                  type="datetime-local"
                />
              </div>
            </div>
          </div>
          <!-- Pair Filter -->
          <div class="flex flex-col">
            <label
              class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-1"
              for="pairFilter"
              >Pair</label
            >
            <select
              class="p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600"
              id="pairFilter"
            >
              <option value="All">All</option>
              <option value="EUR/USD">EUR/USD</option>
              <option value="GBP/USD">GBP/USD</option>
              <option value="USD/JPY">USD/JPY</option>
              <option value="AUD/USD">AUD/USD</option>
              <option value="USD/CAD">USD/CAD</option>
              <option value="NZD/USD">NZD/USD</option>
              <option value="USD/CHF">USD/CHF</option>
              <option value="XAU/USD">XAU/USD</option>
            </select>
          </div>
          <label
            class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-1"
            >Trade Outcome</label
          >
          <div class="flex space-x-4 justify-between md:justify-start">
            <label class="inline-flex items-center"
              ><input
                checked=""
                class="form-radio text-indigo-600 h-4 w-4"
                name="tradeOutcomeFilter"
                type="radio"
                value="All"
              /><span class="ml-2 text-sm text-gray-700 dark:text-gray-300"
                >All</span
              ></label
            >
            <label class="inline-flex items-center"
              ><input
                class="form-radio text-green-600 h-4 w-4"
                name="tradeOutcomeFilter"
                type="radio"
                value="Win"
              /><span class="ml-2 text-sm text-gray-700 dark:text-gray-300"
                >Winners</span
              ></label
            >
            <label class="inline-flex items-center"
              ><input
                class="form-radio text-red-600 h-4 w-4"
                name="tradeOutcomeFilter"
                type="radio"
                value="Loss"
              /><span class="ml-2 text-sm text-gray-700 dark:text-gray-300"
                >Losers</span
              ></label
            >
            <label class="inline-flex items-center"
              ><input
                class="form-radio text-yellow-600 h-4 w-4"
                name="tradeOutcomeFilter"
                type="radio"
                value="Break-Even"
              /><span class="ml-2 text-sm text-gray-700 dark:text-gray-300"
                >B/E</span
              ></label
            >
          </div>

          <div
            class="text-center text-gray-500 dark:text-gray-400 hidden"
            id="loading"
          >
            Loading...
          </div>

          <div
            class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4 scrollable-list"
            id="journalList"
          ></div>
          <div
            class="hidden text-center text-gray-500 dark:text-gray-400 mt-4"
            id="noEntries"
          >
            No journal entries yet. Add your first one!
          </div>
        </div>
        <div
          class="fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-black dark:bg-opacity-70 flex items-center justify-center hidden z-50"
          id="messageModal"
        >
          <div
            class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm mx-auto"
          >
            <p
              class="text-center text-gray-700 dark:text-gray-300 mb-4"
              id="modalMessage"
            ></p>
            <button
              class="w-full py-2 px-4 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition"
              id="modalCloseBtn"
            >
              OK
            </button>
          </div>
        </div>
        <div
          class="fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-black dark:bg-opacity-70 flex items-center justify-center hidden z-50"
          id="strategiesModal"
        >
          <div
            class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-md w-full mx-4"
          >
            <h2
              class="text-2xl font-bold text-center text-violet-700 dark:text-violet-600 mb-4"
            >
              Manage Strategies
            </h2>
            <form class="space-y-4 mb-6" id="strategyForm">
              <div class="flex flex-col">
                <label
                  class="text-sm font-medium text-gray-700 dark:text-gray-300"
                  for="strategyName"
                  >Strategy Name</label
                >
                <input
                  class="mt-1 p-2 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-white border-gray-300 dark:border-gray-600 focus:ring-violet-500 focus:border-violet-500"
                  id="strategyName"
                  name="strategyName"
                  required=""
                  type="text"
                />
              </div>
              <div
                class="space-y-4 p-4 border border-gray-200 dark:border-gray-700 rounded-lg bg-gray-100 dark:bg-gray-900"
              >
                <h3
                  class="text-md font-semibold text-gray-700 dark:text-gray-300"
                >
                  Pick Strategy Color
                </h3>
                <label
                  for="strategyColorPicker"
                  class="text-sm font-medium text-gray-700"
                >
                  Color
                </label>
                <input
                  type="color"
                  id="strategyColorPicker"
                  value="#4f46e5"
                  class="w-16 h-16 rounded-full border border-gray-300 shadow-inner cursor-pointer bg-transparent"
                  style="
                    appearance: none;
                    -webkit-appearance: none;
                    padding: 0;
                    border: none;
                    background: none;
                  "
                />
              </div>
              <button
                class="w-full py-2 px-4 bg-violet-600 text-white font-semibold rounded-lg shadow-md hover:bg-violet-700 transition duration-300"
                id="addStrategyBtn"
                type="submit"
              >
                Add Strategy
              </button>
            </form>
            <div
              class="space-y-2 mt-4 max-h-60 overflow-y-auto"
              id="strategiesList"
            ></div>
            <div class="flex justify-end mt-4">
              <button
                class="py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300"
                id="closeStrategiesModalBtn"
              >
                Close
              </button>
            </div>
          </div>
        </div>
        <div
          class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center hidden z-50"
          id="imageModal"
        >
          <button
            class="absolute top-4 right-6 text-white text-4xl font-light opacity-80 hover:opacity-100 transition duration-150 z-50"
            id="closeImageModalBtn"
          >
            √ó
          </button>
          <div
            class="relative w-full h-full flex items-center justify-center overflow-hidden"
            id="imageViewer"
          >
            <img
              alt="Trade Screenshot"
              class="max-w-full max-h-full object-contain"
              id="zoomedImage"
              src=""
              style="cursor: zoom-in; transform: scale(1)"
            />
          </div>
        </div>
        <div
          class="fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-black dark:bg-opacity-70 flex items-center justify-center hidden z-40"
          id="rawDataModal"
        >
          <div
            class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-4xl w-full h-3/4 mx-4 flex flex-col"
          >
            <h2
              class="text-2xl font-bold text-center text-indigo-700 dark:text-violet-600 mb-4 flex-shrink-0"
            >
              Raw IndexedDB Data
            </h2>
            <div
              class="overflow-auto bg-gray-100 dark:bg-gray-700 p-3 rounded-lg flex-grow space-y-4"
            >
              <div id="rawEntriesData">
                <h3
                  class="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2"
                >
                  Journal Entries:
                </h3>
                <pre
                  class="text-xs text-gray-800 dark:text-gray-200 whitespace-pre-wrap break-words p-3 bg-white dark:bg-gray-900 rounded-lg"
                  id="rawEntriesPre"
                ></pre>
              </div>
              <div class="mt-4" id="rawStrategiesData">
                <h3
                  class="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2"
                >
                  Strategies:
                </h3>
                <pre
                  class="text-xs text-gray-800 dark:text-gray-200 whitespace-pre-wrap break-words p-3 bg-white dark:bg-gray-900 rounded-lg"
                  id="rawStrategiesPre"
                ></pre>
              </div>
            </div>
            <div class="flex justify-end mt-4 flex-shrink-0">
              <button
                class="py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300"
                id="closeRawDataModalBtn"
              >
                Close
              </button>
            </div>
            <div class="flex justify-start mt-2">
              <button
                class="py-2 px-4 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 transition duration-300"
                id="deleteAllBtn"
              >
                Delete All Entries
              </button>
            </div>
            <div
              class="fixed inset-0 bg-gray-600 bg-opacity-50 dark:bg-black dark:bg-opacity-70 flex items-center justify-center hidden z-50"
              id="strategyDbModal"
            >
              <div
                class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-xl max-w-3xl w-full h-3/4 mx-4 flex flex-col"
              >
                <h2
                  class="text-2xl font-bold text-center text-indigo-700 dark:text-violet-600 mb-4 flex-shrink-0"
                >
                  Strategy Database Viewer
                </h2>
                <div class="flex justify-between mb-4">
                  <button
                    class="py-2 px-4 bg-green-600 text-white rounded-lg shadow hover:bg-green-700 transition"
                    id="addNewStrategyDbBtn"
                  >
                    Add New Strategy
                  </button>
                  <button
                    class="py-2 px-4 bg-blue-600 text-white rounded-lg shadow hover:bg-blue-700 transition"
                    id="refreshStrategyDbBtn"
                  >
                    Refresh
                  </button>
                </div>
                <div
                  class="overflow-auto bg-gray-100 dark:bg-gray-700 p-3 rounded-lg flex-grow space-y-4"
                >
                  <div id="strategyDbList"></div>
                </div>
                <div class="flex justify-end mt-4 flex-shrink-0">
                  <button
                    class="py-2 px-4 bg-gray-500 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition duration-300"
                    id="closeStrategyDbModalBtn"
                  >
                    Close
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <button
        class="fixed bottom-6 right-6 z-40 w-16 h-16 rounded-full bg-indigo-600 text-white text-3xl shadow-xl flex items-center justify-center hover:bg-indigo-700 transition-transform transform hover:scale-110 dark:bg-violet-600 dark:hover:bg-violet-700"
        id="addEntryFab"
        title="Add New Entry"
      >
        +
      </button>
      <div
        class="fixed inset-0 bg-gray-800 bg-opacity-50 dark:bg-black dark:bg-opacity-70 hidden z-50 flex items-center justify-center transition-opacity duration-300 ease-out"
        id="addEntryModal"
      >
        <div
          class="bg-white dark:bg-gray-900 p-6 rounded-2xl shadow-2xl w-full max-w-2xl mx-4 transform transition-all duration-300 ease-out scale-95 opacity-0"
          id="addEntryModalContent"
        >
          <div class="flex justify-between items-center mb-4">
            <h2 class="text-2xl font-bold text-indigo-700 dark:text-violet-500">
              Add New Journal Entry
            </h2>
            <button
              class="text-gray-500 dark:text-gray-300 text-2xl hover:text-red-500"
              id="closeAddEntryModalBtn"
            >
              √ó
            </button>
          </div>
          <div id="addEntryFormContainer"></div>
        </div>
      </div>
      <div
        class="fixed top-4 left-1/2 transform -translate-x-1/2 bg-green-600 text-white px-6 py-2 rounded-lg shadow-lg opacity-0 transition-opacity duration-500 z-50"
        id="toast"
      >
        Entry saved successfully!
      </div>
      <!-- Chart.js and Data Labels Plugin -->
      <script>
        let dbInstance = null;

        /* === Consolidated fixed app JS (preserves original GUI structure) === */

        (function () {
          // DOM refs used in original HTML
          const journalForm = document.getElementById("journalForm");
          const journalList = document.getElementById("journalList");
          const loadingDiv = document.getElementById("loading");
          const noEntriesDiv = document.getElementById("noEntries");
          const submitBtn = document.getElementById("submitBtn");
          const submitBtnIcon = document.getElementById("submitBtnIcon");
          const strategiesBtn = document.getElementById("strategiesBtn");
          const strategiesModal = document.getElementById("strategiesModal");
          const closeStrategiesModalBtn = document.getElementById(
            "closeStrategiesModalBtn"
          );
          // === Strategies Modal Handling ===
          document.addEventListener("DOMContentLoaded", () => {
            const strategiesBtn = document.getElementById("strategiesBtn");
            const strategiesModal = document.getElementById("strategiesModal");
            const closeStrategiesModalBtn = document.getElementById(
              "closeStrategiesModalBtn"
            );

            if (strategiesBtn && strategiesModal && closeStrategiesModalBtn) {
              strategiesBtn.addEventListener("click", () => {
                strategiesModal.classList.remove("hidden");
              });

              closeStrategiesModalBtn.addEventListener("click", () => {
                strategiesModal.classList.add("hidden");
              });
            }
          });

          const strategyForm = document.getElementById("strategyForm");
          const strategiesList = document.getElementById("strategiesList");
          const strategyNameInput = document.getElementById("strategyName");
          const addStrategyBtn = document.getElementById("addStrategyBtn");
          const importCsvBtn = document.getElementById("importCsvBtn");
          const csvFileInput = document.getElementById("csvFileInput");
          const showDbDataBtn = document.getElementById("showDbDataBtn");
          const rawDataModal = document.getElementById("rawDataModal");
          const rawEntriesPre = document.getElementById("rawEntriesPre");
          const rawStrategiesPre = document.getElementById("rawStrategiesPre");
          const closeRawDataModalBtn = document.getElementById(
            "closeRawDataModalBtn"
          );
          const metricsDashboard = document.getElementById("metricsDashboard");

          const colorSelectorDiv = document.getElementById("colorSelector");
          const shadeSelectorDiv = document.getElementById("shadeSelector");
          const selectedColorBaseInput =
            document.getElementById("selectedColorBase");
          const selectedColorShadeInput =
            document.getElementById("selectedColorShade");
          const preTradeImageInput = document.getElementById("preTradeImage");
          const postTradeImageInput = document.getElementById("postTradeImage");
          const imageModal = document.getElementById("imageModal");
          const closeImageModalBtn =
            document.getElementById("closeImageModalBtn");
          const zoomedImage = document.getElementById("zoomedImage");
          const darkModeToggle = document.getElementById("darkModeToggle");
          const backupJsonBtn = document.getElementById("backupJsonBtn");
          const restoreJsonBtn = document.getElementById("restoreJsonBtn");

          // Some elements may be undefined depending on GUI sections; guard them
          function $(id) {
            return document.getElementById(id);
          }

          // IndexedDB constants
          const DB_NAME = "ForexJournalDB";
          const DB_VERSION = 2;
          const STORE_ENTRIES = "entries";
          const STORE_STRATEGIES = "strategies";

          // let db = null;
          let currentStrategies = [];
          let currentEntries = [];

          // --- IndexedDB helpers ---
          let db = null;

          async function openDB() {
            // ‚úÖ Reuse an already-open database connection
            if (db) return db;

            return new Promise((resolve, reject) => {
              const request = indexedDB.open(DB_NAME, DB_VERSION);

              request.onupgradeneeded = (event) => {
                const dbInstance = event.target.result;

                // Entries store
                if (!dbInstance.objectStoreNames.contains(STORE_ENTRIES)) {
                  const es = dbInstance.createObjectStore(STORE_ENTRIES, {
                    keyPath: "id",
                    autoIncrement: true,
                  });
                  es.createIndex("dateTime", ["date", "time"], {
                    unique: false,
                  });
                }

                // Strategies store
                if (!dbInstance.objectStoreNames.contains(STORE_STRATEGIES)) {
                  dbInstance.createObjectStore(STORE_STRATEGIES, {
                    keyPath: "id",
                  });
                }
              };

              request.onsuccess = (event) => {
                db = event.target.result;

                // ‚úÖ Keep connection open; reopen automatically if it closes
                db.onclose = () => {
                  console.warn("IndexedDB connection closed ‚Äî reopening...");
                  db = null;
                };

                resolve(db);
              };

              request.onerror = (event) => reject(event.target.error);
            });
          }

          function txRequestPromise(req) {
            return new Promise((res, rej) => {
              req.onsuccess = () => res(req.result);
              req.onerror = () => rej(req.error);
            });
          }

          async function putItem(storeName, item) {
            const idb = await openDB();
            const tx = idb.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            return txRequestPromise(store.put(item));
          }
          async function addItem(storeName, item) {
            const idb = await openDB();
            const tx = idb.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            return txRequestPromise(store.add(item));
          }
          async function deleteItem(storeName, key) {
            const idb = await openDB();
            const tx = idb.transaction(storeName, "readwrite");
            const store = tx.objectStore(storeName);
            return txRequestPromise(store.delete(key));
          }
          async function getAll(storeName) {
            const idb = await openDB();
            const tx = idb.transaction(storeName, "readonly");
            const store = tx.objectStore(storeName);
            return txRequestPromise(store.getAll());
          }

          async function getById(storeName, id) {
            const idb = await openDB();
            const tx = idb.transaction(storeName, "readonly");
            const store = tx.objectStore(storeName);
            return new Promise((resolve, reject) => {
              const req = store.get(id);
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            });
          }

          // --- Defaults loader ---
          async function ensureDefaults() {
            let s = await getAll(STORE_STRATEGIES);
            if (!s || s.length === 0) {
              const defaults = [
                {
                  id: 1,
                  name: "Asian Range Breakout",
                  colorClass:
                    "text-indigo-600 bg-indigo-100 dark:bg-indigo-800 dark:text-indigo-300",
                  colorBase: "indigo",
                  colorShade: "600",
                },
                {
                  id: 2,
                  name: "NY Reversal",
                  colorClass:
                    "text-violet-600 bg-violet-100 dark:bg-violet-800 dark:text-violet-300",
                  colorBase: "violet",
                  colorShade: "600",
                },
                {
                  id: 3,
                  name: "Trend Continuation",
                  colorClass:
                    "text-green-600 bg-green-100 dark:bg-green-800 dark:text-green-300",
                  colorBase: "green",
                  colorShade: "600",
                },
              ];
              for (const d of defaults) await putItem(STORE_STRATEGIES, d);
            }
          }

          // --- Loaders ---
          async function loadStrategies() {
            currentStrategies = await getAll(STORE_STRATEGIES);
            renderStrategySelectors();
            renderStrategiesList();
            return currentStrategies;
          }

          async function loadEntries() {
            currentEntries = await getAll(STORE_ENTRIES);
            currentEntries.sort((a, b) => {
              const da = new Date(
                (a.date || "1970-01-01") + "T" + (a.time || "00:00") + ":00"
              );
              const dbd = new Date(
                (b.date || "1970-01-01") + "T" + (b.time || "00:00") + ":00"
              );
              return dbd - da;
            });
            return currentEntries;
          }

          // --- UI helpers ---
          function showMessageModal(message, type = "info") {
            const modal = $("messageModal");
            const text = $("modalMessage");
            if (modal && text) {
              text.textContent = message;
              modal.classList.remove("hidden");
              if (type === "success") {
                setTimeout(() => modal.classList.add("hidden"), 2200);
              }
            } else {
              alert(message);
            }
          }
          function hideMessageModal() {
            const m = $("messageModal");
            if (m) m.classList.add("hidden");
          }
          const modalCloseBtn = $("modalCloseBtn");
          if (modalCloseBtn)
            modalCloseBtn.addEventListener("click", hideMessageModal);

          // --- Strategy rendering ---
          function renderStrategySelectors() {
            const container = $("indicatorsContainer");
            if (!container) return;
            container.innerHTML = "";
            const currentValue = $("strategy")
              ? $("strategy").value.trim()
              : "";
            let selectedStrategies = currentValue
              ? currentValue.split(" + ").map((s) => s.trim())
              : [];
            currentStrategies.forEach((s) => {
              const button = document.createElement("button");
              button.type = "button";
              button.className =
                s.colorClass +
                " text-xs font-semibold px-3 py-1 rounded-full shadow-sm hover:opacity-80 transition";
              button.textContent = s.name;
              if (selectedStrategies.includes(s.name)) {
                button.classList.add(
                  "ring-2",
                  "ring-offset-2",
                  "ring-indigo-500",
                  "dark:ring-violet-400"
                );
              }
              button.onclick = () => {
                if (selectedStrategies.includes(s.name)) {
                  selectedStrategies = selectedStrategies.filter(
                    (name) => name !== s.name
                  );
                  button.classList.remove(
                    "ring-2",
                    "ring-offset-2",
                    "ring-indigo-500",
                    "dark:ring-violet-400"
                  );
                } else {
                  selectedStrategies.push(s.name);
                  button.classList.add(
                    "ring-2",
                    "ring-offset-2",
                    "ring-indigo-500",
                    "dark:ring-violet-400"
                  );
                }
                if ($("strategy"))
                  $("strategy").value = selectedStrategies.join(" + ");
              };
              container.appendChild(button);
            });
          }

          function renderStrategiesList() {
            const list = document.getElementById("strategiesList");
            if (!list) return;
            list.innerHTML = "";

            if (!currentStrategies || currentStrategies.length === 0) {
              list.innerHTML =
                '<p class="text-sm text-gray-500">No strategies defined.</p>';
              return;
            }

            currentStrategies.forEach((s) => {
              const div = document.createElement("div");
              div.className =
                "flex items-center justify-between p-2 border rounded-md bg-gray-50 dark:bg-gray-800";

              // üß© note the updated data-action="edit-strategy"
              div.innerHTML = `
      <div>
        <span class="px-2 py-1 rounded text-xs" style="background:${
          s.colorHex || "#4f46e5"
        }; color:white">${s.name}</span>
      </div>
      <div class="flex gap-2">
        <button class="text-sm text-indigo-600" 
                data-id="${s.id}" 
                data-action="edit-strategy">
          Edit
        </button>
        <button class="text-sm text-red-600" 
                data-id="${s.id}" 
                data-action="del">
          Delete
        </button>
      </div>
    `;

              list.appendChild(div);
            });

            // Attach event listeners to the buttons
            list.querySelectorAll("button").forEach((btn) => {
              btn.addEventListener("click", async (ev) => {
                ev.stopPropagation(); // prevent overlap with other click handlers
                const id = parseInt(btn.dataset.id);
                const action = btn.dataset.action;

                if (action === "del") {
                  if (!confirm("Delete strategy?")) return;
                  await deleteItem(STORE_STRATEGIES, id);
                  await loadStrategies();
                  showMessageModal("Strategy deleted", "success");
                }
                // üß© note: changed from "edit" ‚Üí "edit-strategy"
                else if (action === "edit-strategy") {
                  const s = await getById(STORE_STRATEGIES, id);
                  if (!s) return;

                  // Fill in form fields
                  strategyNameInput.value = s.name;

                  const colorPicker = document.getElementById(
                    "strategyColorPicker"
                  );
                  if (s.colorHex) {
                    colorPicker.value = s.colorHex;
                  } else {
                    colorPicker.value = "#4f46e5";
                  }

                  // Update the submit button to show ‚ÄúUpdate Strategy‚Äù
                  addStrategyBtn.textContent = "Update Strategy";

                  // Mark the form as editing mode
                  strategyForm.dataset.editingId = s.id;
                }
              });
            });
          }

          strategyForm.addEventListener("submit", async (ev) => {
            ev.preventDefault();

            const name = document.getElementById("strategyName").value.trim();
            const colorHex = document.getElementById(
              "strategyColorPicker"
            ).value;
            const addStrategyBtn = document.getElementById("addStrategyBtn");

            if (!name) return;

            // --- EDIT MODE ---
            if (strategyForm.dataset.editingId) {
              const id = parseInt(strategyForm.dataset.editingId);
              const existing = currentStrategies.find((x) => x.id === id);
              if (existing) {
                existing.name = name;
                existing.colorHex = colorHex;
                await putItem(STORE_STRATEGIES, existing);
              }
              delete strategyForm.dataset.editingId;
              addStrategyBtn.textContent = "Add Strategy";
              showMessageModal("Strategy updated successfully!", "success");
            }
            // --- ADD MODE ---
            else {
              const newStrategy = {
                id: Date.now(),
                name,
                colorHex,
              };
              await addItem(STORE_STRATEGIES, newStrategy);
              showMessageModal("Strategy added successfully!", "success");
            }

            // Refresh + reset
            await loadStrategies();
            strategyForm.reset();
            document.getElementById("strategyColorPicker").value = "#4f46e5";
          });

          // --- Entries rendering ---

          function createStrategyChips(entry) {
            if (!entry || !entry.strategy) return "";
            const names = entry.strategy
              .split(/\s*\+\s*/)
              .map((x) => x.trim())
              .filter(Boolean);
            const chips = names.map((n) => {
              const s = currentStrategies.find((x) => x.name === n);
              if (s) {
                // Prefer hex color if available (user-created strategies)
                if (s.colorHex) {
                  // use inline background and pick contrasting text (white) for simplicity
                  return `<span style="background:${s.colorHex}; color:white" class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium shadow-sm">${n}</span>`;
                }
                // Fallback to existing Tailwind color classes (defaults)
                if (s.colorClass) {
                  return `<span class="${s.colorClass} inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium">${n}</span>`;
                }
              }
              return `<span class="bg-gray-200 text-gray-800 inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium">${n}</span>`;
            });
            return chips.join(
              ' <span class="text-gray-600 dark:text-gray-400 mx-1">+</span> '
            );
          }
          window.showImageModal = function (src) {
            const imgModal = $("imageModal");
            const zoom = $("zoomedImage");
            if (!imgModal || !zoom) return;
            zoom.src = src;
            imgModal.classList.remove("hidden");
          };

          const closeImgBtn = $("closeImageModalBtn");
          if (closeImgBtn)
            closeImgBtn.addEventListener("click", () => {
              const m = $("imageModal");
              if (m) m.classList.add("hidden");
            });

          function renderEntryCard(entry) {
            const outcomeColor =
              entry.outcome === "Win"
                ? "border-green-500"
                : entry.outcome === "Loss"
                ? "border-red-500"
                : "border-yellow-500";
            const outcomeTextColor =
              entry.outcome === "Win"
                ? "text-green-500"
                : entry.outcome === "Loss"
                ? "text-red-500"
                : "text-yellow-500";
            const preThumb = entry.preTradeImage
              ? `<img src="${entry.preTradeImage}" alt="Pre Trade" class="w-20 h-20 object-cover rounded-lg cursor-zoom-in hover:opacity-80 transition" onclick="showImageModal('${entry.preTradeImage}')">`
              : "";
            const postThumb = entry.postTradeImage
              ? `<img src="${entry.postTradeImage}" alt="Post Trade" class="w-20 h-20 object-cover rounded-lg cursor-zoom-in hover:opacity-80 transition" onclick="showImageModal('${entry.postTradeImage}')">`
              : "";
            return `
              <div class="p-4 rounded-xl shadow-lg border-l-4 ${outcomeColor} bg-white dark:bg-gray-900 transition duration-300 hover:shadow-xl">
                <div class="flex justify-between items-start mb-2">
                  <div class="flex flex-col">
                    <h3 class="text-lg font-bold text-gray-900 dark:text-gray-100">${
                      entry.pair
                    }
                      <span class="text-sm font-normal text-gray-500 dark:text-gray-400">(${
                        entry.timeFrame
                      })</span></h3>
                    <p class="text-sm text-gray-500 dark:text-gray-400">${
                      entry.date
                    } at ${entry.time}</p>
                  </div>
                  <div class="text-right">
                    <p class="text-xl font-extrabold ${outcomeTextColor}">${
              entry.rMultiple || "0.00"
            } R</p>
                    <div class="entry-strategies mt-1">${
                      createStrategyChips(entry) ||
                      '<span class="text-gray-500">N/A</span>'
                    }</div>
                  </div>
                </div>
                <div class="entry-images mb-3">
                  ${preThumb}
                  ${postThumb}
                </div>
                <div class="grid grid-cols-2 gap-2 text-sm mb-3 text-gray-700 dark:text-gray-300">
                  <div><span class="font-semibold">Direction:</span>
                      <span class="font-medium ${
                        entry.direction === "Buy"
                          ? "text-green-600"
                          : "text-red-600"
                      }">${entry.direction}</span>
                  </div>
                  <div><span class="font-semibold">Exit:</span> ${
                    entry.exitReason
                  }</div>
                  <div><span class="font-semibold">Entry:</span> ${
                    entry.entryPrice
                  }</div>
                  <div><span class="font-semibold">Exit Price:</span> ${
                    entry.exitPrice
                  }</div>
                </div>
                <details class="trade-details mt-2 border-t pt-3 border-gray-200 dark:border-gray-700">
                  <summary class="cursor-pointer text-sm font-semibold hover:text-indigo-800 dark:hover:text-violet-400 transition">
                    View Details
                  </summary>
                  <div class="mt-3 space-y-2 text-sm text-gray-700 dark:text-gray-300">
                    <p><span class="font-semibold">Stop Loss:</span> ${
                      entry.slPrice
                    } /
                       <span class="font-semibold">Take Profit:</span> ${
                         entry.tpPrice
                       }</p>
                    <p><span class="font-semibold">Lot Size:</span> ${
                      entry.lotSize
                    }</p>
                    <p><span class="font-semibold">Grade:</span> ${
                      entry.setupGrade
                    } /
                       <span class="font-semibold">Follow Plan:</span> ${
                         entry.didFollowPlan
                       }</p>
                    <p><span class="font-semibold">Emotion:</span> ${
                      entry.emotionalState
                    }</p>
                    <p class="mt-2"><span class="font-semibold block mb-1">Lessons Learned:</span>
                       ${entry.lessonsLearned || "N/A"}</p>
                    <p><span class="font-semibold block mb-1">Notes:</span>
                       ${entry.notes || "N/A"}</p>
                  </div>
                </details>
                <div class="flex justify-end space-x-2 mt-4 pt-3 border-t border-gray-200 dark:border-gray-700">
                  <button class="text-indigo-600 hover:text-indigo-800 dark:text-violet-400 dark:hover:text-violet-600 transition text-sm" data-action="edit" data-id="${
                    entry.id
                  }">Edit</button>
                  <button class="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-600 transition text-sm" data-action="delete" data-id="${
                    entry.id
                  }">Delete</button>
                </div>
              </div>
            `;
          }

          async function renderJournalEntries(filteredEntries = null) {
            if (loadingDiv) loadingDiv.classList.remove("hidden");
            if (!filteredEntries) {
              await loadEntries();
              filteredEntries = currentEntries;
            }
            renderMetrics(calculateMetrics(filteredEntries));
            renderStrategyUsage(filteredEntries);

            journalList.innerHTML = "";
            if (!filteredEntries || filteredEntries.length === 0) {
              if (noEntriesDiv) noEntriesDiv.classList.remove("hidden");
            } else {
              if (noEntriesDiv) noEntriesDiv.classList.add("hidden");
              filteredEntries.forEach((entry) => {
                journalList.innerHTML += renderEntryCard(entry);
              });
              // attach edit/delete handlers
              journalList
                .querySelectorAll("button[data-action]")
                .forEach((btn) => {
                  btn.addEventListener("click", async (ev) => {
                    const id = parseInt(btn.dataset.id);
                    const action = btn.dataset.action;
                    if (action === "delete") {
                      if (!confirm("Delete this entry?")) return;
                      await deleteItem(STORE_ENTRIES, id);
                      await loadEntries();
                      await renderJournalEntries();
                      showMessageModal("Entry deleted", "success");
                    } else if (action === "edit") {
                      const entry = await getById(STORE_ENTRIES, id);
                      if (!entry) return;

                      console.log("üìù Editing journal entry:", entry);

                      // ‚úÖ Use your existing modal and form population function
                      populateFormForEdit(entry);
                    }
                  });
                });
            }
            if (loadingDiv) loadingDiv.classList.add("hidden");
          }
          // === Filtering Functionality ===
          const filterInput = document.getElementById("filterInput");
          const startDateInput = document.getElementById("startDate");
          const endDateInput = document.getElementById("endDate");
          const pairFilter = document.getElementById("pairFilter");
          const outcomeRadios = document.querySelectorAll(
            'input[name="tradeOutcomeFilter"]'
          );
          // === FILTER TRIGGER DELAY ===
          // This prevents the filter from firing too many times in a row.
          let filterTimeout;

          function triggerFilters() {
            // Cancel the previous scheduled call (if any)
            clearTimeout(filterTimeout);

            // Wait 300 milliseconds after the last change before running filters
            filterTimeout = setTimeout(() => {
              applyFilters();
            }, 300);
          }

          // === FIXED FILTER FUNCTION ===
          async function applyFilters() {
            // Get all saved journal entries
            let entries = await getAll(STORE_ENTRIES);

            // Make sure each entry has an outcome (Winner, Loser, etc.)
            entries.forEach((e) => {
              if (!e.outcome) calculateR(e);
            });

            // Read all filter input fields
            const filterText = filterInput.value.trim().toLowerCase();
            const startDate = startDateInput.value
              ? new Date(startDateInput.value)
              : null;
            const endDate = endDateInput.value
              ? new Date(endDateInput.value)
              : null;
            const selectedPair = pairFilter.value;
            const selectedOutcome =
              [...outcomeRadios].find((r) => r.checked)?.value || "All";

            // Filter the entries
            const filtered = entries.filter((e) => {
              // --- Ensure date & time parse correctly ---
              let entryDateTime = null;
              if (e.date) {
                // Detect format (YYYY-MM-DD or MM/DD/YYYY)
                if (e.date.includes("-")) {
                  let [year, month, day] = e.date.split("-");
                  let timePart = (e.time || "00:00")
                    .toString()
                    .replace(/^(\d{1,2})(\d{2})$/, "$1:$2");
                  entryDateTime = new Date(
                    `${year}-${month}-${day}T${timePart}:00`
                  );
                } else if (e.date.includes("/")) {
                  let [month, day, year] = e.date.split("/");
                  let timePart = (e.time || "00:00")
                    .toString()
                    .replace(/^(\d{1,2})(\d{2})$/, "$1:$2");
                  entryDateTime = new Date(
                    `${year}-${month}-${day}T${timePart}:00`
                  );
                }
              }

              // --- Date range filter ---
              if (startDate && entryDateTime && entryDateTime < startDate)
                return false;
              if (endDate && entryDateTime && entryDateTime > endDate)
                return false;

              // --- Pair filter ---
              if (
                selectedPair !== "All" &&
                e.pair &&
                e.pair.trim() !== selectedPair.trim()
              )
                return false;

              // --- Outcome filter ---
              const entryOutcome = (e.outcome || "").toLowerCase();
              if (
                selectedOutcome !== "All" &&
                entryOutcome !== selectedOutcome.toLowerCase()
              )
                return false;

              // --- Text search filter ---
              if (
                filterText &&
                !(
                  (e.pair && e.pair.toLowerCase().includes(filterText)) ||
                  (e.strategy &&
                    e.strategy.toLowerCase().includes(filterText)) ||
                  (e.notes && e.notes.toLowerCase().includes(filterText))
                )
              )
                return false;

              return true;
            });

            // Render the results
            renderJournalEntries(filtered);
          }

          // === Filter Event Listeners ===
          // === FILTER EVENT LISTENERS ===
          if (filterInput)
            filterInput.addEventListener("input", triggerFilters);
          if (startDateInput)
            startDateInput.addEventListener("change", triggerFilters);
          if (endDateInput)
            endDateInput.addEventListener("change", triggerFilters);
          if (pairFilter) pairFilter.addEventListener("change", triggerFilters);
          outcomeRadios.forEach((r) =>
            r.addEventListener("change", triggerFilters)
          );

          function populateFormForEdit(entry) {
  try {
    const modal = document.getElementById("addEntryModal");
    const modalContent = document.getElementById("addEntryModalContent");
    
    // Show the modal
    modal.classList.remove("hidden");
    modal.classList.add("flex");
    modal.style.opacity = "1";
    modalContent.style.transform = "scale(1)";
    modalContent.style.opacity = "1";

    // Prefill input fields with current entry data
    document.getElementById("date").value = entry.date || "";
    document.getElementById("time").value = entry.time || "";
    document.getElementById("pair").value = entry.pair || "GBP/USD";
    document.getElementById("direction").value = entry.direction || "Buy";
    document.getElementById("strategy").value = entry.strategy || "";
    document.getElementById("timeFrame").value = entry.timeFrame || "M1";
    document.getElementById("entryPrice").value = entry.entryPrice || "";
    document.getElementById("slPrice").value = entry.slPrice || "";
    document.getElementById("tpPrice").value = entry.tpPrice || "";
    document.getElementById("exitPrice").value = entry.exitPrice || "";
    document.getElementById("exitReason").value = entry.exitReason || "TP";
    document.getElementById("lotSize").value = entry.lotSize || "";
    document.getElementById("setupGrade").value = entry.setupGrade || "A";
    document.getElementById("didFollowPlan").value = entry.didFollowPlan || "Yes";
    document.getElementById("emotionalState").value = entry.emotionalState || "Calm";
    document.getElementById("lessonsLearned").value = entry.lessonsLearned || "";
    document.getElementById("notes").value = entry.notes || "";

    // Set the entry ID for editing mode
    journalForm.dataset.editingId = entry.id;
    submitBtn.querySelector("span").textContent = "Save Changes";

    // Re-render strategy selectors (highlighting selected strategies)
    renderStrategySelectors();
    
    // Highlight selected strategies
    const selectedStrategies = (entry.strategy || "")
      .split(" + ")
      .map((s) => s.trim());
    document
      .querySelectorAll("#indicatorsContainer button")
      .forEach((btn) => {
        if (selectedStrategies.includes(btn.textContent.trim())) {
          btn.classList.add(
            "ring-2",
            "ring-offset-2",
            "ring-indigo-500",
            "dark:ring-violet-400"
          );
        } else {
          btn.classList.remove(
            "ring-2",
            "ring-offset-2",
            "ring-indigo-500",
            "dark:ring-violet-400"
          );
        }
      });

    // Set the image fields only if there are uploaded images
    const preImageField = document.getElementById("preTradeImage");
    const postImageField = document.getElementById("postTradeImage");

    // If there is an existing image for preTradeImage, keep it
    if (entry.preTradeImage) {
      preImageField.setAttribute("src", entry.preTradeImage);
      preImageField.setAttribute("alt", "Pre-Trade Image");
    }

    // If there is an existing image for postTradeImage, keep it
    if (entry.postTradeImage) {
      postImageField.setAttribute("src", entry.postTradeImage);
      postImageField.setAttribute("alt", "Post-Trade Image");
    }

  } catch (err) {
    console.error(err);
  }
}


          // Handle form submit (add or update)
          if (journalForm) {
            journalForm.addEventListener("submit", async (ev) => {
              ev.preventDefault();

              const form = ev.target;
              const obj = {};

              // Collect form data (simplified for clarity)
              new FormData(form).forEach((v, k) => (obj[k] = v));

              // Convert images to Base64 or preserve old ones
              const editingId = form.dataset.editingId
                ? parseInt(form.dataset.editingId)
                : null;
              let existing = null;

              if (editingId) {
                existing = await getAll("entries").then((list) =>
                  list.find((x) => x.id === editingId)
                );
              }

              const preFile = document.getElementById("preTradeImage").files[0];
              const postFile =
                document.getElementById("postTradeImage").files[0];

              // Helper to convert file to base64
              async function fileToBase64(file) {
                return new Promise((res, rej) => {
                  if (!file) return res("");
                  const reader = new FileReader();
                  reader.onload = () => res(reader.result);
                  reader.onerror = rej;
                  reader.readAsDataURL(file);
                });
              }

              // ‚úÖ Preserve or update images correctly
              obj.preTradeImage =
                (await fileToBase64(preFile)) || existing?.preTradeImage || "";
              obj.postTradeImage =
                (await fileToBase64(postFile)) ||
                existing?.postTradeImage ||
                "";

              if (editingId) {
                // ‚úÖ Update existing entry
                obj.id = editingId;
                await putItem("entries", obj);
                delete form.dataset.editingId; // clear editing mode
                showMessageModal("Entry updated successfully!", "success");
              } else {
                // ‚úÖ Add new entry
                await addItem("entries", obj);
                showMessageModal("New entry added successfully!", "success");
              }

              // Refresh UI
              // 1. Reset the form immediately (This is fast)
              form.reset();
              const modal = document.getElementById("addEntryModal");
              if (modal) modal.classList.add("hidden"); // 2. DEFER THE SLOW RENDER

              // This runs *after* the success message modal (A or B) has been clicked and closed.
              setTimeout(async () => {
                await renderJournalEntries();
              }, 50);
            });
          }

          // --- File to base64 ---
          function fileToBase64(file) {
            return new Promise((res, rej) => {
              if (!file) return res(null);
              const MAX_SIZE = 1048576;
              if (file.size > MAX_SIZE) {
                showMessageModal("File too large (>1MB).", "error");
                return res(null);
              }
              const reader = new FileReader();
              reader.onload = () => res(reader.result);
              reader.onerror = () => res(null);
              reader.readAsDataURL(file);
            });
          }

          // --- R calculation ---
          function calculateR(entry) {
            const entryPrice = parseFloat(entry.entryPrice);
            const exitPrice = parseFloat(entry.exitPrice);
            const slPrice = parseFloat(entry.slPrice);
            if (
              isNaN(entryPrice) ||
              isNaN(exitPrice) ||
              isNaN(slPrice) ||
              slPrice === entryPrice
            ) {
              entry.rMultiple = "0.00";
              entry.outcome = "Invalid";
              return 0;
            }
            const isJPY = entry.pair && entry.pair.includes("JPY");
            const multiplier = isJPY ? 100 : 10000;
            const riskInPips = Math.abs(entryPrice - slPrice) * multiplier;
            if (riskInPips === 0) {
              entry.rMultiple = "0.00";
              entry.outcome = "Break-Even";
              return 0;
            }
            let profitInPips =
              entry.direction === "Buy"
                ? (exitPrice - entryPrice) * multiplier
                : (entryPrice - exitPrice) * multiplier;
            const rMultiple = profitInPips / riskInPips;
            const R_THRESHOLD = 0.1;
            if (rMultiple > R_THRESHOLD) entry.outcome = "Win";
            else if (rMultiple < -R_THRESHOLD) entry.outcome = "Loss";
            else entry.outcome = "Break-Even";
            entry.rMultiple = rMultiple.toFixed(2);
            return rMultiple;
          }

          // --- Metrics ---
          function calculateMetrics(entries) {
            const totalTrades = entries.length;
            let totalRScore = 0;
            let winningTrades = 0;
            for (const entry of entries) {
              const r = calculateR(entry);
              totalRScore += r;
              if (entry.outcome === "Win") winningTrades++;
            }
            const winRate =
              totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;
            const avgRR = totalTrades > 0 ? totalRScore / totalTrades : 0;
            return {
              winRate: winRate.toFixed(1),
              totalTrades,
              totalRScore: totalRScore.toFixed(2),
              avgRR: avgRR.toFixed(2),
            };
          }

          function renderMetrics(metrics) {
            if (!metricsDashboard) return;
            function card(title, value, colorClass = "") {
              return `<div class="p-3 rounded-xl flex flex-col items-center justify-center ${colorClass} shadow-md border-2 border-transparent"><div class="text-xs font-semibold uppercase opacity-80">${title}</div><div class="text-2xl font-bold mt-1">${value}</div></div>`;
            }
            metricsDashboard.innerHTML = `
              ${card(
                "Total Trades",
                metrics.totalTrades,
                "bg-indigo-100 dark:bg-indigo-900 text-indigo-700 dark:text-indigo-300"
              )}
              ${card(
                "Win Rate",
                metrics.winRate + "%",
                metrics.winRate >= 50
                  ? "bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300"
                  : "bg-yellow-100 dark:bg-yellow-900 text-yellow-700 dark:text-yellow-300"
              )}
              ${card(
                "Total R-Score",
                metrics.totalRScore,
                metrics.totalRScore >= 0
                  ? "bg-teal-100 dark:bg-teal-900 text-teal-700 dark:text-teal-300"
                  : "bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300"
              )}
              ${card(
                "Avg R-Multiple",
                metrics.avgRR,
                metrics.avgRR >= 0
                  ? "bg-teal-100 dark:bg-teal-900 text-teal-700 dark:text-teal-300"
                  : "bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300"
              )}
            `;
          }

          // === Strategy Usage Rendering ===
          function renderStrategyUsage(entries) {
            const container = document.getElementById("strategyUsageContent");
            if (!container) return;
            container.innerHTML = "";

            const counts = {};
            entries.forEach((e) => {
              if (!e.strategy) return;
              e.strategy
                .split("+")
                .map((s) => s.trim())
                .filter(Boolean)
                .forEach((str) => {
                  counts[str] = (counts[str] || 0) + 1;
                });

              // === AUTO-SAVE STRATEGIES FROM USAGE LIST (unique, case-insensitive, cleans duplicates, with logs) ===
              (async () => {
                try {
                  const db = await openDB();
                  const tx = db.transaction(STORE_STRATEGIES, "readwrite");
                  const store = tx.objectStore(STORE_STRATEGIES);
                  const existing = await txRequestPromise(store.getAll());

                  // üßπ Clean existing duplicates (case-insensitive)
                  const seen = new Set();
                  for (const s of existing) {
                    const lower = s.name.toLowerCase().trim();
                    if (seen.has(lower)) {
                      await store.delete(s.id);
                      console.log("üßπ Deleted duplicate strategy:", s.name);
                    } else {
                      seen.add(lower);
                    }
                  }

                  // Normalize existing strategy names (case-insensitive)
                  const refreshed = await txRequestPromise(store.getAll());
                  const existingNamesLower = refreshed.map((s) =>
                    s.name.toLowerCase().trim()
                  );

                  // Get unique strategy names from current counts, ignoring case
                  const uniqueNames = Object.keys(counts).reduce(
                    (acc, name) => {
                      const lower = name.toLowerCase().trim();
                      if (!acc.some((n) => n.toLowerCase() === lower))
                        acc.push(name.trim());
                      return acc;
                    },
                    []
                  );

                  for (const strategyName of uniqueNames) {
                    // ‚úÖ Add only if it doesn‚Äôt already exist (case-insensitive)
                    if (
                      !existingNamesLower.includes(
                        strategyName.toLowerCase().trim()
                      )
                    ) {
                      const colors = [
                        "indigo",
                        "violet",
                        "green",
                        "blue",
                        "orange",
                        "pink",
                      ];
                      const shades = ["500", "600", "700"];
                      const colorBase =
                        colors[Math.floor(Math.random() * colors.length)];
                      const colorShade =
                        shades[Math.floor(Math.random() * shades.length)];
                      const colorClass = `text-${colorBase}-${colorShade} bg-${colorBase}-100 dark:bg-${colorBase}-800 dark:text-${colorBase}-300`;

                      await putItem(STORE_STRATEGIES, {
                        id: Date.now() + Math.floor(Math.random() * 10000),
                        name: strategyName.trim(),
                        colorClass,
                        colorBase,
                        colorShade,
                      });
                      console.log("‚úÖ Added new strategy:", strategyName);
                    }
                  }
                } catch (err) {
                  console.error("‚ö†Ô∏è Error in auto-save strategies block:", err);
                }
              })();
            });

            // Convert to array and sort descending
            let sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);

            let showingAll = false;
            const renderList = () => {
              container.innerHTML = "";
              const display = showingAll ? sorted : sorted.slice(0, 5);
              display.forEach(([name, count]) => {
                const s = currentStrategies.find((x) => x.name === name);
                const colorClass = s
                  ? s.colorClass
                  : "bg-gray-200 text-gray-800";
                const div = document.createElement("div");
                div.className = `${colorClass} px-3 py-2 rounded-lg text-sm font-semibold flex items-center justify-between`;
                div.innerHTML = `
                <span>${name}</span>
                <span class="text-xs font-bold bg-white/30 dark:bg-black/20 px-2 py-0.5 rounded-md">${count}</span>
              `;
                container.appendChild(div);
              });
            };

            // Toggle button
            let toggleBtn = document.getElementById("toggleStrategyListBtn");
            if (!toggleBtn) {
              toggleBtn = document.createElement("button");
              toggleBtn.id = "toggleStrategyListBtn";
              toggleBtn.className =
                "mt-3 text-sm font-semibold text-indigo-600 dark:text-violet-400 hover:underline";
              toggleBtn.textContent = "Show All Strategies";
              toggleBtn.addEventListener("click", () => {
                showingAll = !showingAll;
                toggleBtn.textContent = showingAll
                  ? "Show Top 5 Only"
                  : "Show All Strategies";
                renderList();
              });
              container.parentElement.appendChild(toggleBtn);
            }

            renderList();
          }

          // --- Render functions for selectors already defined earlier ---
          function renderStrategySelectorsWrapper() {
            renderStrategySelectors();
          }

          // --- Save strategies array by clearing and repopulating store ---
          async function saveStrategies(strategies) {
            const idb = await openDB();
            const tx = idb.transaction(STORE_STRATEGIES, "readwrite");
            const store = tx.objectStore(STORE_STRATEGIES);
            await new Promise((res) => {
              const c = store.clear();
              c.onsuccess = () => res();
              c.onerror = () => res();
            });
            for (const s of strategies) {
              await new Promise((res) => {
                const r = store.put(s);
                r.onsuccess = () => res();
                r.onerror = () => res();
              });
            }
            currentStrategies = strategies;
            renderStrategySelectors();
            renderStrategiesList();
          }

          // --- Load all raw data (for backup) ---
          async function loadAllRawData() {
            const entries = await getAll(STORE_ENTRIES);
            const strategies = await getAll(STORE_STRATEGIES);
            return { entries, strategies };
          }

          async function overwriteEntries(newEntries) {
            const idb = await openDB();
            const tx = idb.transaction(STORE_ENTRIES, "readwrite");
            const store = tx.objectStore(STORE_ENTRIES);
            await new Promise((res) => {
              const c = store.clear();
              c.onsuccess = () => res();
              c.onerror = () => res();
            });
            for (const entry of newEntries) {
              const copy = Object.assign({}, entry);
              if (copy.id) delete copy.id;
              await addItem(STORE_ENTRIES, copy);
            }
          }

          // --- Backup & Restore JSON handlers ---
          if (backupJsonBtn)
            backupJsonBtn.addEventListener("click", async () => {
              try {
                const data = await loadAllRawData();
                const jsonData = JSON.stringify(data, null, 2);

                // ‚úÖ Detect Android WebView bridge
                if (
                  window.Android &&
                  typeof window.Android.saveBackupBase64 === "function"
                ) {
                  const base64Data = btoa(
                    unescape(encodeURIComponent(jsonData))
                  );
                  window.Android.saveBackupBase64(base64Data);
                  alert("‚úÖ Backup saved to Downloads (Android)");
                } else {
                  // ‚úÖ Fallback for desktop browsers
                  const blob = new Blob([jsonData], {
                    type: "application/json",
                  });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement("a");
                  a.href = url;
                  a.download = `forex_journal_backup_${
                    new Date().toISOString().split("T")[0]
                  }.json`;
                  a.click();
                  URL.revokeObjectURL(url);
                  showMessageModal(
                    "Backup (JSON) file created successfully.",
                    "success"
                  );
                }
              } catch (err) {
                console.error(err);
                showMessageModal("Failed to create JSON backup.", "error");
              }
            });

          // Hidden file input for JSON restore (guarantee it exists)
          let jsonFileInput = document.querySelector(
            'input[type="file"][accept=".json"]'
          );
          if (!jsonFileInput) {
            jsonFileInput = document.createElement("input");
            jsonFileInput.type = "file";
            jsonFileInput.accept = ".json";
            jsonFileInput.classList.add("hidden");
            document.body.appendChild(jsonFileInput);
          }
          if (restoreJsonBtn)
            restoreJsonBtn.addEventListener("click", () =>
              jsonFileInput.click()
            );

          jsonFileInput.addEventListener("change", async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
              const text = await file.text();
              const data = JSON.parse(text);
              if (!data.entries || !data.strategies) {
                showMessageModal("Invalid backup file format.", "error");
                return;
              }
              await overwriteEntries(data.entries);
              await saveStrategies(data.strategies);
              await loadEntries();
              await renderJournalEntries();
              showMessageModal(
                "Database restored successfully from JSON.",
                "success"
              );
            } catch (err) {
              console.error(err);
              showMessageModal("Failed to restore from JSON.", "error");
            } finally {
              jsonFileInput.value = "";
            }
          });

          // --- CSV import/export (using PapaParse if available) ---
          function downloadBlob(dataStr, filename, mime) {
            const blob = new Blob([dataStr], {
              type: mime || "application/octet-stream",
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
          }

          if (window.Papa) {
            if (document.getElementById("backupCsvBtn"))
              document
                .getElementById("backupCsvBtn")
                .addEventListener("click", async () => {
                  try {
                    const all = await getAll(STORE_ENTRIES);
                    if (!all || all.length === 0) {
                      showMessageModal("No entries to export.", "info");
                      return;
                    }
                    const rows = all.map((e) => ({
                      id: e.id,
                      date: e.date,
                      time: e.time,
                      pair: e.pair,
                      direction: e.direction,
                      strategy: e.strategy,
                      timeFrame: e.timeFrame,
                      entryPrice: e.entryPrice,
                      slPrice: e.slPrice,
                      tpPrice: e.tpPrice,
                      exitPrice: e.exitPrice,
                      exitReason: e.exitReason,
                      lotSize: e.lotSize,
                      setupGrade: e.setupGrade,
                      didFollowPlan: e.didFollowPlan,
                      emotionalState: e.emotionalState,
                      preTradeImage: e.preTradeImage || "",
                      postTradeImage: e.postTradeImage || "",
                      lessonsLearned: e.lessonsLearned || "",
                      notes: e.notes || "",
                    }));
                    const csv = window.Papa.unparse(rows);
                    downloadBlob(
                      csv,
                      `forex_journal_${
                        new Date().toISOString().split("T")[0]
                      }.csv`,
                      "text/csv;charset=utf-8;"
                    );
                    showMessageModal("CSV exported.", "success");
                  } catch (err) {
                    console.error(err);
                    showMessageModal("CSV export failed.", "error");
                  }
                });
            // import
            if (importCsvBtn && csvFileInput) {
              importCsvBtn.addEventListener("click", () =>
                csvFileInput.click()
              );
              csvFileInput.addEventListener("change", (ev) => {
                const f = ev.target.files[0];
                if (!f) return;
                window.Papa.parse(f, {
                  header: true,
                  skipEmptyLines: true,
                  complete: async (results) => {
                    const rows = results.data;
                    for (const r of rows) {
                      const entry = {
                        date: r.date || "",
                        time: r.time || "",
                        pair: r.pair || "GBP/USD",
                        direction: r.direction || "Buy",
                        strategy: r.strategy || "",
                        timeFrame: r.timeFrame || "M1",
                        entryPrice: r.entryPrice || "",
                        slPrice: r.slPrice || "",
                        tpPrice: r.tpPrice || "",
                        exitPrice: r.exitPrice || "",
                        exitReason: r.exitReason || "TP",
                        lotSize: r.lotSize || "",
                        setupGrade: r.setupGrade || "A",
                        didFollowPlan: r.didFollowPlan || "Yes",
                        emotionalState: r.emotionalState || "Calm",
                        preTradeImage: r.preTradeImage || "",
                        postTradeImage: r.postTradeImage || "",
                        lessonsLearned: r.lessonsLearned || "",
                        notes: r.notes || "",
                      };
                      if (entry.id) delete entry.id;
                      await addItem(STORE_ENTRIES, entry);
                    }
                    await loadEntries();
                    renderJournalEntries();
                    showMessageModal("CSV imported.", "success");
                    csvFileInput.value = "";
                  },
                  error: (err) => {
                    console.error(err);
                    showMessageModal("CSV import failed.", "error");
                    csvFileInput.value = "";
                  },
                });
              });
            }
          } else {
            // fallback: attach simple handlers for UI buttons if Papa not present
            if (importCsvBtn)
              importCsvBtn.addEventListener("click", () =>
                showMessageModal(
                  "PapaParse not loaded. CSV import disabled.",
                  "error"
                )
              );
            if (document.getElementById("backupCsvBtn"))
              document
                .getElementById("backupCsvBtn")
                .addEventListener("click", () =>
                  showMessageModal(
                    "PapaParse not loaded. CSV export disabled.",
                    "error"
                  )
                );
          }

          // --- Raw data modal handlers ---
          if (showDbDataBtn)
            showDbDataBtn.addEventListener("click", async () => {
              const entries = await getAll(STORE_ENTRIES);
              const strategies = await getAll(STORE_STRATEGIES);
              if (rawEntriesPre)
                rawEntriesPre.textContent = JSON.stringify(entries, null, 2);
              if (rawStrategiesPre)
                rawStrategiesPre.textContent = JSON.stringify(
                  strategies,
                  null,
                  2
                );
              if (rawDataModal) rawDataModal.classList.remove("hidden");
            });
          if (closeRawDataModalBtn)
            closeRawDataModalBtn.addEventListener("click", () =>
              rawDataModal.classList.add("hidden")
            );

          // --- Strategies modal open/close ---
          if (strategiesBtn)
            strategiesBtn.addEventListener("click", async () => {
              await loadStrategies();
              if (strategiesModal) strategiesModal.classList.remove("hidden");
            });
          if (closeStrategiesModalBtn)
            closeStrategiesModalBtn.addEventListener("click", () =>
              strategiesModal.classList.add("hidden")
            );

          // --- Strategy add form ---
          if (strategyForm)
            strategyForm.addEventListener("submit", async (ev) => {
              ev.preventDefault();
              const name = (
                (strategyNameInput && strategyNameInput.value) ||
                ""
              ).trim();
              if (!name) {
                showMessageModal("Enter strategy name.", "error");
                return;
              }
              const newStrategy = {
                id: Date.now(),
                name,
                colorClass:
                  "text-indigo-600 bg-indigo-100 dark:bg-indigo-800 dark:text-indigo-300",
                colorBase: "indigo",
                colorShade: "600",
              };
              await putItem(STORE_STRATEGIES, newStrategy);
              strategyNameInput.value = "";
              await loadStrategies();
              showMessageModal("New strategy added to the DB.", "success");
            });

          // --- Helpers: normalize time ---
          function normalizeTimeFormat(timeStr) {
            if (!timeStr) return "";
            const cleanStr = timeStr.toString().replace(/[^0-9]/g, "");
            if (cleanStr.length === 4)
              return `${cleanStr.substring(0, 2)}:${cleanStr.substring(2, 4)}`;
            return timeStr;
          }

          // --- Filters (basic) ---

          // --- Raw Data modal show/hide already wired earlier ---

          // --- Init ---
          (async function init() {
            try {
              await openDB();
              await ensureDefaults();
              await loadStrategies();
              await loadEntries();
              await renderJournalEntries();
              console.log("Initialization complete.");
            } catch (err) {
              console.error("Init error", err);
              showMessageModal(
                "Initialization failed: Could not load data.",
                "error"
              );
            }

            // === Expose helper functions globally ===
            window.openDB = openDB;
            window.loadEntries = loadEntries;
            window.renderJournalEntries = renderJournalEntries;
            window.ensureDefaults = ensureDefaults;
            window.getAll = getAll;
            window.loadAllRawData = loadAllRawData;

            // --- Delete All Entries Button Handler (Entries + Strategies) ---
            const deleteAllBtn = document.getElementById("deleteAllBtn");
            if (deleteAllBtn) {
              deleteAllBtn.addEventListener("click", async () => {
                if (
                  !confirm(
                    "Are you sure you want to delete ALL journal entries and strategies? This cannot be undone."
                  )
                )
                  return;
                try {
                  const idb = await openDB();

                  // Clear both object stores
                  const tx = idb.transaction(
                    ["entries", "strategies"],
                    "readwrite"
                  );
                  const entriesStore = tx.objectStore("entries");
                  const strategiesStore = tx.objectStore("strategies");

                  await Promise.all([
                    new Promise((res, rej) => {
                      const req = entriesStore.clear();
                      req.onsuccess = () => res();
                      req.onerror = () => rej(req.error);
                    }),
                    new Promise((res, rej) => {
                      const req = strategiesStore.clear();
                      req.onsuccess = () => res();
                      req.onerror = () => rej(req.error);
                    }),
                  ]);

                  await ensureDefaults(); // re-add default strategies
                  await loadEntries();
                  await renderJournalEntries();

                  // Update raw data modal
                  if (typeof loadAllRawData === "function") {
                    const raw = await loadAllRawData();
                    const rawEntriesPre =
                      document.getElementById("rawEntriesPre");
                    const rawStrategiesPre =
                      document.getElementById("rawStrategiesPre");
                    if (rawEntriesPre)
                      rawEntriesPre.textContent = JSON.stringify(
                        raw.entries,
                        null,
                        2
                      );
                    if (rawStrategiesPre)
                      rawStrategiesPre.textContent = JSON.stringify(
                        raw.strategies,
                        null,
                        2
                      );
                  }

                  showMessageModal(
                    "All entries and strategies deleted successfully.",
                    "success"
                  );
                } catch (err) {
                  console.error(err);
                  showMessageModal("Failed to delete all entries.", "error");
                }
              });
            }
          })();

          // === Expose helper functions globally ===
          window.openDB = openDB;
          window.loadEntries = loadEntries;
          window.renderJournalEntries = renderJournalEntries;
          window.ensureDefaults = ensureDefaults;
          window.getAll = getAll;
          window.loadAllRawData = loadAllRawData;

          // --- Delete All Entries Button Handler (Entries + Strategies) ---
          const deleteAllBtn = document.getElementById("deleteAllBtn");
          if (deleteAllBtn) {
            deleteAllBtn.addEventListener("click", async () => {
              if (
                !confirm(
                  "Are you sure you want to delete ALL journal entries and strategies? This cannot be undone."
                )
              )
                return;
              try {
                const idb = await openDB();

                // Clear both object stores
                const tx = idb.transaction(
                  ["entries", "strategies"],
                  "readwrite"
                );
                const entriesStore = tx.objectStore("entries");
                const strategiesStore = tx.objectStore("strategies");

                await Promise.all([
                  new Promise((res, rej) => {
                    const req = entriesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                  new Promise((res, rej) => {
                    const req = strategiesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                ]);

                await ensureDefaults(); // re-add default strategies
                await loadEntries();
                await renderJournalEntries();

                // Update raw data modal
                if (typeof loadAllRawData === "function") {
                  const raw = await loadAllRawData();
                  const rawEntriesPre =
                    document.getElementById("rawEntriesPre");
                  const rawStrategiesPre =
                    document.getElementById("rawStrategiesPre");
                  if (rawEntriesPre)
                    rawEntriesPre.textContent = JSON.stringify(
                      raw.entries,
                      null,
                      2
                    );
                  if (rawStrategiesPre)
                    rawStrategiesPre.textContent = JSON.stringify(
                      raw.strategies,
                      null,
                      2
                    );
                }

                showMessageModal(
                  "All entries and strategies deleted successfully.",
                  "success"
                );
              } catch (err) {
                console.error(err);
                showMessageModal("Failed to delete all entries.", "error");
              }
            });
          }
        })(); // end consolidated IIFE

        //temporaryF
        console.log(
          "Connected:",
          startDateInput,
          endDateInput,
          pairFilter,
          outcomeRadios
        );
      </script>
      <script>
        (function () {
          const addFab = document.getElementById("addEntryFab");
          const modal = document.getElementById("addEntryModal");
          const modalContent = document.getElementById("addEntryModalContent");
          const closeBtn = document.getElementById("closeAddEntryModalBtn");
          const closeFooterBtn = document.getElementById(
            "closeAddEntryModalFooterBtn"
          );

          function openModal() {
            if (!modal) return;
            modal.classList.remove("hidden");
            // trigger reflow then set opacity/scale for animation
            requestAnimationFrame(() => {
              modal.style.opacity = "1";
              modal.classList.remove("opacity-0");
              modalContent.style.transform = "scale(1)";
              modalContent.classList.remove("scale-95");
            });
            // prevent background scroll
            document.documentElement.style.overflow = "hidden";
            document.body.style.overflow = "hidden";
          }
          function closeModal() {
            if (!modal) return;
            // animate out
            modal.style.opacity = "0";
            modal.classList.add("opacity-0");
            modalContent.style.transform = "scale(0.95)";
            modalContent.classList.add("scale-95");
            setTimeout(() => {
              modal.classList.add("hidden");
              // restore scroll
              document.documentElement.style.overflow = "";
              document.body.style.overflow = "";
            }, 200);
          }

          if (addFab)
            addFab.addEventListener("click", (e) => {
              e.preventDefault();
              openModal();
            });

          if (closeBtn)
            closeBtn.addEventListener("click", (e) => {
              e.preventDefault();
              closeModal();
            });
          if (closeFooterBtn)
            closeFooterBtn.addEventListener("click", (e) => {
              e.preventDefault();
              closeModal();
            });

          // close when clicking outside modal content
          if (modal) {
            modal.addEventListener("click", (e) => {
              if (e.target === modal) closeModal();
            });
          }

          // If form had editing state and was previously shown, ensure modal shows when editing
          const journalForm = document.getElementById("journalForm");
          if (journalForm) {
            // Intercept when form gets dataset.editingId set externally: open modal
            const originalSet = Object.getOwnPropertyDescriptor(
              HTMLFormElement.prototype,
              "dataset"
            ).get;
            // can't easily trap dataset changes universally; instead ensure that when populateFormForEdit is called it opens modal.
            // So override the global function if present:
            if (typeof populateFormForEdit === "function") {
              const originalPopulate = populateFormForEdit;
              window.populateFormForEdit = function (entry) {
                originalPopulate(entry);
                openModal();
              };
            }
          }

          // === Expose helper functions globally ===
          window.openDB = openDB;
          window.loadEntries = loadEntries;
          window.renderJournalEntries = renderJournalEntries;
          window.ensureDefaults = ensureDefaults;
          window.getAll = getAll;
          window.loadAllRawData = loadAllRawData;

          // --- Delete All Entries Button Handler (Entries + Strategies) ---
          const deleteAllBtn = document.getElementById("deleteAllBtn");
          if (deleteAllBtn) {
            deleteAllBtn.addEventListener("click", async () => {
              if (
                !confirm(
                  "Are you sure you want to delete ALL journal entries and strategies? This cannot be undone."
                )
              )
                return;
              try {
                const idb = await openDB();

                // Clear both object stores
                const tx = idb.transaction(
                  ["entries", "strategies"],
                  "readwrite"
                );
                const entriesStore = tx.objectStore("entries");
                const strategiesStore = tx.objectStore("strategies");

                await Promise.all([
                  new Promise((res, rej) => {
                    const req = entriesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                  new Promise((res, rej) => {
                    const req = strategiesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                ]);

                await ensureDefaults(); // re-add default strategies
                await loadEntries();
                await renderJournalEntries();

                // Update raw data modal
                if (typeof loadAllRawData === "function") {
                  const raw = await loadAllRawData();
                  const rawEntriesPre =
                    document.getElementById("rawEntriesPre");
                  const rawStrategiesPre =
                    document.getElementById("rawStrategiesPre");
                  if (rawEntriesPre)
                    rawEntriesPre.textContent = JSON.stringify(
                      raw.entries,
                      null,
                      2
                    );
                  if (rawStrategiesPre)
                    rawStrategiesPre.textContent = JSON.stringify(
                      raw.strategies,
                      null,
                      2
                    );
                }

                showMessageModal(
                  "All entries and strategies deleted successfully.",
                  "success"
                );
              } catch (err) {
                console.error(err);
                showMessageModal("Failed to delete all entries.", "error");
              }
            });
          }
        })();
      </script>
      <script>
        (function () {
          const toggle = document.getElementById("darkModeToggle");
          const html = document.documentElement;
          if (!toggle) return;

          // Helper to set initial theme
          function applySavedTheme() {
            const saved = localStorage.getItem("theme");
            if (
              saved === "dark" ||
              (!saved &&
                window.matchMedia &&
                window.matchMedia("(prefers-color-scheme: dark)").matches)
            ) {
              html.classList.add("dark");
            } else {
              html.classList.remove("dark");
            }
            updateIcons();
          }

          // Find icon spans safely (use order as a fallback)
          const spans = Array.from(toggle.querySelectorAll("span"));
          const moonSpan = spans[0] || null;
          const sunSpan = spans[1] || null;

          function updateIcons() {
            try {
              const isDark = html.classList.contains("dark");
              if (moonSpan) moonSpan.style.display = isDark ? "none" : "";
              if (sunSpan) sunSpan.style.display = isDark ? "" : "none";
            } catch (e) {
              /* silent */
            }
          }

          // Toggle handler
          toggle.addEventListener("click", function (e) {
            e.preventDefault();
            html.classList.toggle("dark");
            const isDark = html.classList.contains("dark");
            try {
              localStorage.setItem("theme", isDark ? "dark" : "light");
            } catch (e) {}
            updateIcons();
          });

          // Init on load
          applySavedTheme();

          // Also listen to system theme changes if user hasn't explicitly set theme
          try {
            const mq = window.matchMedia("(prefers-color-scheme: dark)");
            mq.addEventListener
              ? mq.addEventListener("change", (e) => {
                  if (!localStorage.getItem("theme")) applySavedTheme();
                })
              : mq.addListener((e) => {
                  if (!localStorage.getItem("theme")) applySavedTheme();
                });
          } catch (e) {}

          // === Expose helper functions globally ===
          window.openDB = openDB;
          window.loadEntries = loadEntries;
          window.renderJournalEntries = renderJournalEntries;
          window.ensureDefaults = ensureDefaults;
          window.getAll = getAll;
          window.loadAllRawData = loadAllRawData;

          // --- Delete All Entries Button Handler (Entries + Strategies) ---
          const deleteAllBtn = document.getElementById("deleteAllBtn");
          if (deleteAllBtn) {
            deleteAllBtn.addEventListener("click", async () => {
              if (
                !confirm(
                  "Are you sure you want to delete ALL journal entries and strategies? This cannot be undone."
                )
              )
                return;
              try {
                const idb = await openDB();

                // Clear both object stores
                const tx = idb.transaction(
                  ["entries", "strategies"],
                  "readwrite"
                );
                const entriesStore = tx.objectStore("entries");
                const strategiesStore = tx.objectStore("strategies");

                await Promise.all([
                  new Promise((res, rej) => {
                    const req = entriesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                  new Promise((res, rej) => {
                    const req = strategiesStore.clear();
                    req.onsuccess = () => res();
                    req.onerror = () => rej(req.error);
                  }),
                ]);

                await ensureDefaults(); // re-add default strategies
                await loadEntries();
                await renderJournalEntries();

                // Update raw data modal
                if (typeof loadAllRawData === "function") {
                  const raw = await loadAllRawData();
                  const rawEntriesPre =
                    document.getElementById("rawEntriesPre");
                  const rawStrategiesPre =
                    document.getElementById("rawStrategiesPre");
                  if (rawEntriesPre)
                    rawEntriesPre.textContent = JSON.stringify(
                      raw.entries,
                      null,
                      2
                    );
                  if (rawStrategiesPre)
                    rawStrategiesPre.textContent = JSON.stringify(
                      raw.strategies,
                      null,
                      2
                    );
                }

                showMessageModal(
                  "All entries and strategies deleted successfully.",
                  "success"
                );
              } catch (err) {
                console.error(err);
                showMessageModal("Failed to delete all entries.", "error");
              }
            });
          }
        })();
      </script>
    </div>
    <script>


      function renderMostUsedStrategies(filteredEntries) {
        const card = document.getElementById("mostUsedStrategiesCard");
        if (!card) return;

        if (!filteredEntries || filteredEntries.length === 0) {
          card.classList.add("hidden");
          return;
        }
    </script>
    <script>
      async function renderMostUsedStrategiesChart(entries) {
        const card = document.getElementById("mostUsedStrategiesCard");
        if (!card) return;

        const strategyCount = {};
        (entries || []).forEach((entry) => {
          if (!entry.strategy) return;
          entry.strategy
            .split("+")
            .map((s) => s.trim())
            .forEach((strat) => {
              if (!strat) return;
              strategyCount[strat] = (strategyCount[strat] || 0) + 1;
            });
        });

        const strategies = Object.keys(strategyCount);
        if (strategies.length === 0) {
          card.classList.remove("hidden");
          card.innerHTML =
            '<p class="text-sm text-gray-500 dark:text-gray-300 text-center">No strategy data available.</p>';
          return;
        }

        strategies.sort((a, b) => strategyCount[b] - strategyCount[a]);
        const counts = strategies.map((s) => strategyCount[s]);
        const total = counts.reduce((a, b) => a + b, 0);
        const percentages = counts.map((c) => ((c / total) * 100).toFixed(1));

        // Derive Tailwind-like colors from strategy colorClass
        const colors = strategies.map((s) => {
          const stratObj = currentStrategies.find((x) => x.name === s);
          if (!stratObj) return "#6366F1";
          if (stratObj.colorClass.includes("indigo")) return "#6366F1";
          if (stratObj.colorClass.includes("violet")) return "#8B5CF6";
          if (stratObj.colorClass.includes("green")) return "#10B981";
          if (stratObj.colorClass.includes("blue")) return "#3B82F6";
          if (stratObj.colorClass.includes("red")) return "#EF4444";
          if (stratObj.colorClass.includes("yellow")) return "#F59E0B";
          if (stratObj.colorClass.includes("teal")) return "#14B8A6";
          if (stratObj.colorClass.includes("pink")) return "#EC4899";
          return "#6366F1";
        });

        card.classList.remove("hidden");
        card.innerHTML =
          '<canvas id="mostUsedStrategiesChart" height="' +
          strategies.length * 40 +
          '"></canvas>';

        const ctx = document
          .getElementById("mostUsedStrategiesChart")
          .getContext("2d");

        new Chart(ctx, {
          type: "bar",
          data: {
            labels: strategies,
            datasets: [
              {
                data: percentages,
                backgroundColor: colors,
                borderRadius: 8,
                barThickness: 20,
              },
            ],
          },
          options: {
            indexAxis: "y",
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: { label: (ctx) => ctx.parsed.x + "%" },
              },
              datalabels: {
                color: "#111",
                anchor: "end",
                align: "end",
                font: { weight: "bold" },
                formatter: (val) => val + "%",
              },
            },
            scales: {
              x: {
                beginAtZero: true,
                title: { display: true, text: "Usage (%)" },
                grid: { display: false },
              },
              y: { grid: { display: false } },
            },
          },
          plugins: [ChartDataLabels],
        });
      }

      // Hook chart into entry rendering and on initial load
      const originalRenderJournalEntries = renderJournalEntries;
      renderJournalEntries = async function (filteredEntries = null) {
        await originalRenderJournalEntries(filteredEntries);
        renderMostUsedStrategiesChart(filteredEntries || currentEntries);
      };

      // Initial render after page load
      window.addEventListener("DOMContentLoaded", () => {
        setTimeout(() => renderMostUsedStrategiesChart(currentEntries), 1500);
      });
    </script>
    <script>
      // Hook chart rendering into journal rendering
      if (typeof renderJournalEntries === "function") {
        const oldRenderJournalEntries = renderJournalEntries;
        renderJournalEntries = async function (filteredEntries = null) {
          await oldRenderJournalEntries(filteredEntries);
          window.currentEntriesFiltered =
            filteredEntries || window.currentEntries || [];
          renderStrategyUsageChart(window.currentEntriesFiltered);
        };
      }

      // Auto-init chart on load if entries exist
      window.addEventListener("DOMContentLoaded", () => {
        if (
          typeof currentEntries !== "undefined" &&
          currentEntries.length > 0
        ) {
          renderStrategyUsageChart(currentEntries);
        }
      });

      // === Frosted, Stack-Safe, Smart confirmDialog() ===
      let confirmDialogStack = 0;

      async function confirmDialog(message, options = {}) {
        return new Promise((resolve) => {
          const {
            title = "Confirm Action",
            confirmText = "Yes",
            cancelText = "Cancel",
            confirmColor = "",
            cancelColor = "bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600",
          } = options;

          const dangerWords = [
            "delete",
            "erase",
            "remove",
            "restore",
            "reset",
            "overwrite",
            "destroy",
          ];
          const isDanger =
            dangerWords.some((w) =>
              (title + " " + message).toLowerCase().includes(w)
            ) || options.danger === true;

          const btnColor =
            confirmColor ||
            (isDanger
              ? "bg-red-600 hover:bg-red-700"
              : "bg-blue-600 hover:bg-blue-700");

          confirmDialogStack += 1;
          const zIndexBase = 40 + confirmDialogStack * 10;
          const offset = (confirmDialogStack - 1) * 12;

          const overlay = document.createElement("div");
          overlay.className =
            "fixed inset-0 backdrop-blur-md bg-black/40 dark:bg-black/60 transition-opacity duration-300 opacity-0 flex items-center justify-center";
          overlay.style.zIndex = zIndexBase;
          document.body.appendChild(overlay);
          requestAnimationFrame(() => (overlay.style.opacity = "1"));

          const dialog = document.createElement("div");
          dialog.className =
            "max-w-md w-full mx-4 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm rounded-xl shadow-2xl p-6 text-gray-900 dark:text-gray-100 transform scale-95 transition-all duration-300 opacity-0";
          dialog.style.zIndex = zIndexBase + 1;
          dialog.style.marginTop = `${offset}px`;
          dialog.setAttribute("role", "dialog");
          dialog.setAttribute("aria-modal", "true");
          dialog.setAttribute("tabindex", "-1");

          dialog.innerHTML = `
      <h2 class="text-lg font-semibold mb-3">${title}</h2>
      <p class="whitespace-pre-line mb-4">${message}</p>
      <div class="flex justify-end gap-2 mt-4">
        <button id="cancelBtn" class="py-2 px-4 ${cancelColor}
          text-gray-900 dark:text-gray-100 font-semibold rounded-lg shadow-md transition">
          ${cancelText}
        </button>
        <button id="confirmBtn" class="py-2 px-4 ${btnColor}
          text-white font-semibold rounded-lg shadow-md transition">
          ${confirmText}
        </button>
      </div>
    `;

          overlay.appendChild(dialog);

          requestAnimationFrame(() => {
            dialog.style.opacity = "1";
            dialog.style.transform = "scale(1)";
          });
          dialog.focus();

          const cancelBtn = dialog.querySelector("#cancelBtn");
          const confirmBtn = dialog.querySelector("#confirmBtn");

          const closeModal = (confirmed) => {
            dialog.style.opacity = "0";
            dialog.style.transform = "scale(0.95)";
            overlay.style.opacity = "0";
            setTimeout(() => {
              overlay.remove();
              confirmDialogStack -= 1;
              document.removeEventListener("keydown", handleKey);
              resolve(confirmed);
            }, 300);
          };

          function handleKey(e) {
            if (e.key === "Escape") closeModal(false);
            if (e.key === "Enter") closeModal(true);
          }
          document.addEventListener("keydown", handleKey);

          cancelBtn.onclick = () => closeModal(false);
          confirmBtn.onclick = () => closeModal(true);
        });
      }

      // --- Delete All Entries Button ---
      const deleteAllBtn = document.getElementById("deleteAllBtn");
      if (deleteAllBtn) {
        deleteAllBtn.addEventListener("click", async () => {
          if (
            !confirm(
              "‚ö†Ô∏è This will permanently delete all journal entries and strategies. Continue?"
            )
          )
            return;
          try {
            const idb = await openDB();
            const tx1 = idb.transaction(STORE_ENTRIES, "readwrite");
            const tx2 = idb.transaction(STORE_STRATEGIES, "readwrite");
            tx1.objectStore(STORE_ENTRIES).clear();
            tx2.objectStore(STORE_STRATEGIES).clear();

            await Promise.all([
              new Promise((res) => {
                tx1.oncomplete = res;
                tx1.onerror = res;
              }),
              new Promise((res) => {
                tx2.oncomplete = res;
                tx2.onerror = res;
              }),
            ]);

            await renderJournalEntries([]);
            await loadStrategies();
            if (rawEntriesPre) rawEntriesPre.textContent = "";
            if (rawStrategiesPre) rawStrategiesPre.textContent = "";
            showMessageModal("All data deleted successfully.", "success");
          } catch (err) {
            console.error(err);
            showMessageModal("Failed to delete all data.", "error");
          }
        });
      }
    </script>
    <script>
      if (document.getElementById("strategyForm")) {
        document
          .getElementById("strategyForm")
          .addEventListener("submit", async (e) => {
            e.preventDefault();
            const strategyName = document
              .getElementById("strategyName")
              .value.trim();
            const colorValue = document.getElementById(
              "strategyColorPicker"
            ).value;
            if (!strategyName) return alert("Please enter a strategy name");

            const colorClass = `text-white bg-[${colorValue}]`;
            const newStrategy = {
              id: Date.now(),
              name: strategyName,
              colorClass,
              colorBase: colorValue,
              colorShade: "custom",
            };

            const db = await openDB();
            const tx = db.transaction("strategies", "readwrite");
            tx.objectStore("strategies").put(newStrategy);
            showMessageModal("Strategy added", "success");
            await loadStrategies();
          });
      }

      function updateStrategyEditHandlers() {
        const list = document.getElementById("strategiesList");
        if (!list) return;
        list.querySelectorAll("button[data-action='edit']").forEach((btn) => {
          btn.addEventListener("click", async () => {
            const id = parseInt(btn.dataset.id);
            const s = currentStrategies.find((x) => x.id === id);
            if (!s) return;
            const newName = prompt("New name", s.name);
            const newColor = prompt(
              "New color (hex, e.g. #4f46e5)",
              s.colorBase || "#4f46e5"
            );
            if (!newName) return;
            s.name = newName;
            s.colorBase = newColor;
            s.colorClass = `text-white bg-[${newColor}]`;
            await putItem("strategies", s);
            await loadStrategies();
            showMessageModal("Strategy updated", "success");
          });
        });
      }
    </script>
    <!-- Capacitor Initialization Patch (Filesystem Support, No Logic Changes) -->
    <script>
      // ‚úÖ Helper: resize image and convert to Base64 (works on Android)
      async function resizeAndConvertToBase64(file, maxWidth = 800) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              const canvas = document.createElement("canvas");
              const scale = Math.min(1, maxWidth / img.width);
              canvas.width = img.width * scale;
              canvas.height = img.height * scale;
              const ctx = canvas.getContext("2d");
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              // Compress to JPEG (quality 0.8)
              resolve(canvas.toDataURL("image/jpeg", 0.8));
            };
            img.onerror = reject;
            img.src = e.target.result;
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      document.addEventListener("DOMContentLoaded", async () => {
        if (
          window.Capacitor &&
          (window.Capacitor.Plugins || window.Filesystem)
        ) {
          console.log("‚úÖ Capacitor detected - running inside APK");
          window.isCapacitor = true;
          window.CapacitorApp = window.Capacitor.Plugins || {};
          window.AppFilesystem =
            window.CapacitorApp.Filesystem || window.Filesystem;

          // Optional test - verify Filesystem availability
          try {
            const info = await AppFilesystem.getUri({ path: "test.txt" });
            console.log("Capacitor Filesystem ready:", info);
          } catch (e) {
            console.warn("Capacitor Filesystem plugin not accessible yet.", e);
          }
        } else {
          console.log("üåê Running in browser - Capacitor not detected.");
          window.isCapacitor = false;
        }
      });
    </script>
    <!-- Patch: Keep all screenshots visible (Hybrid + APK) -->
    <script>
      async function getVisibleImageSrc(imgObj) {
        if (!imgObj) return null;

        // Base64 inline
        if (typeof imgObj === "string" && imgObj.startsWith("data:image"))
          return imgObj;

        // Capacitor URI
        if (window.Capacitor && (imgObj.uri || imgObj.path)) {
          const Filesystem =
            window.Capacitor.Plugins?.Filesystem || window.Filesystem;
          if (!Filesystem) return null;
          try {
            const path = imgObj.uri
              ? imgObj.uri.replace("file://", "")
              : imgObj.path;
            const res = await Filesystem.readFile({ path, directory: "DATA" });
            const mime = path.endsWith(".png") ? "image/png" : "image/jpeg";
            return `data:${mime};base64,${res.data}`;
          } catch (err) {
            console.warn("Could not read Capacitor file", err);
            return null;
          }
        }

        // Blob fallback
        if (imgObj.blob) return URL.createObjectURL(imgObj.blob);

        return null;
      }

      async function loadEntryImagesSafely(entry) {
        entry._preTradeImageSrc = await getVisibleImageSrc(entry.preTradeImage);
        entry._postTradeImageSrc = await getVisibleImageSrc(
          entry.postTradeImage
        );
        return entry;
      }

      console.log("‚úÖ Screenshot visibility patch active.");
    </script>
    <!-- Unified Refresh Helper -->
    <script>
      async function softRefreshUI() {
        console.log("üîÅ Soft-refreshing journal UI...");
        if (typeof renderJournalEntries === "function") {
          try {
            await renderJournalEntries();
            console.log("‚úÖ UI soft-refreshed successfully.");
          } catch (e) {
            console.warn("‚ö†Ô∏è softRefreshUI failed, fallback to reload", e);
            reloadAppData();
          }
        } else {
          reloadAppData();
        }
      }

      function reloadAppData() {
        console.log("üîÑ Reloading app data...");
        if (window.Capacitor) {
          location.reload(); // Safe in APK
        } else {
          window.location.reload(); // Safe in browser
        }
      }

      console.log(
        "‚úÖ Unified Refresh Helper ready. Use softRefreshUI() or reloadAppData()."
      );
    </script>
    <!-- Color Save Instant Refresh Helper -->
    <script>
      async function afterColorSave() {
        console.log("üé® Color update saved. Refreshing display...");
        if (typeof renderJournalEntries === "function") {
          try {
            await renderJournalEntries();
            console.log("‚úÖ Colors refreshed instantly.");
          } catch (err) {
            console.warn(
              "‚ö†Ô∏è renderJournalEntries failed, fallback to reload",
              err
            );
            reloadAppData();
          }
        } else {
          reloadAppData();
        }
      }
      console.log(
        "‚úÖ afterColorSave() helper active. Call it after saving a color."
      );
    </script>
    <!-- Front-End Patch: Apply strategy color immediately after save -->
    <script>
      async function applyStrategyColorToUI(strategyName, colorValue) {
        if (!strategyName || !colorValue) return;

        // Find all elements related to this strategy
        const elements = document.querySelectorAll(
          `[data-strategy-name="${strategyName}"]`
        );
        if (elements.length === 0) {
          console.warn(`No elements found for strategy: ${strategyName}`);
          return;
        }

        elements.forEach((el) => {
          try {
            // Update background color immediately
            el.style.backgroundColor = colorValue;

            // Optional: handle Tailwind-style classes (remove old bg- classes)
            el.classList.forEach((cls) => {
              if (cls.startsWith("bg-")) el.classList.remove(cls);
            });

            console.log(
              `üé® Updated UI color for "${strategyName}" ‚Üí ${colorValue}`
            );
          } catch (err) {
            console.warn(`‚ö†Ô∏è Failed to apply color to ${strategyName}`, err);
          }
        });
      }

      console.log(
        "‚úÖ applyStrategyColorToUI() ready ‚Äî call it after saving a strategy color."
      );
    </script>
    <!-- Color Save and Refresh Helper -->
    <script>
      async function saveColorAndRefresh(strategyName, newColor) {
        console.log("üé® Saving color update...");
        try {
          // 1. Save the color (your own existing save function)
          if (typeof saveStrategyColor === "function") {
            await saveStrategyColor(strategyName, newColor);
          } else {
            console.warn(
              "‚ö†Ô∏è saveStrategyColor() not found - skipping direct save call."
            );
          }

          // 2. Wait a bit to let storage (IndexedDB/localStorage) commit changes
          await new Promise((res) => setTimeout(res, 400));

          // 3. Apply new color visually
          if (typeof applyStrategyColorToUI === "function") {
            applyStrategyColorToUI(strategyName, newColor);
          }

          // 4. Soft re-render from latest data
          if (typeof softRefreshUI === "function") {
            await softRefreshUI();
          } else if (typeof renderJournalEntries === "function") {
            await renderJournalEntries();
          } else {
            reloadAppData();
          }

          console.log("‚úÖ Color updated and refreshed properly.");
        } catch (err) {
          console.error("‚ùå Color save or refresh failed:", err);
          reloadAppData();
        }
      }
      console.log(
        "‚úÖ saveColorAndRefresh() ready ‚Äî use instead of direct save calls."
      );
    </script>
    <!-- Enhanced Color Auto-Hook Wrapper (v3 with Add + Edit Support) -->
    <script>
      (function () {
        function callIfExistsReturnPromise(fnName, ...args) {
          try {
            const fn = window[fnName];
            if (typeof fn === "function") {
              const r = fn(...args);
              return Promise.resolve(r);
            }
          } catch (e) {
            console.warn(e);
          }
          return Promise.resolve(null);
        }

        function waitCommit(ms = 500) {
          return new Promise((res) => setTimeout(res, ms));
        }

        async function ensureColorSaveAndRefresh(
          strategyName,
          colorValue,
          saveFnName
        ) {
          console.log(
            "ensureColorSaveAndRefresh:",
            strategyName,
            colorValue,
            saveFnName
          );
          try {
            const fnName = saveFnName || "addStrategyBtn";
            await callIfExistsReturnPromise(fnName, strategyName, colorValue);
            await waitCommit(700);

            if (typeof window.applyStrategyColorToUI === "function") {
              try {
                window.applyStrategyColorToUI(strategyName, colorValue);
              } catch (e) {
                console.warn(e);
              }
            }

            if (typeof window.softRefreshUI === "function") {
              await window.softRefreshUI();
            } else if (typeof window.renderJournalEntries === "function") {
              await window.renderJournalEntries();
            } else if (typeof window.reloadAppData === "function") {
              window.reloadAppData();
            }

            console.log("ensureColorSaveAndRefresh: done");
          } catch (err) {
            console.error("ensureColorSaveAndRefresh failed", err);
            if (typeof window.reloadAppData === "function")
              window.reloadAppData();
          }
        }

        function attachWrappers() {
          const possibleButtons = Array.from(
            document.querySelectorAll(
              'button, input[type="button"], input[type="submit"], a'
            )
          );

          possibleButtons.forEach((btn) => {
            if (btn.dataset._colorWrapperAttached) return;
            const text =
              (btn.textContent || "").toLowerCase() +
              " " +
              (btn.getAttribute("aria-label") || "");
            const onclick = btn.getAttribute && btn.getAttribute("onclick");
            if (
              /save|apply|ok|update|set|add|edit/i.test(text) ||
              (onclick && /color|strategy|save|add|edit/i.test(onclick))
            ) {
              btn.dataset._colorWrapperAttached = "1";
              btn.addEventListener(
                "click",
                function (ev) {
                  try {
                    // Let the button‚Äôs normal save/edit function run first
                    setTimeout(async () => {
                      const container =
                        btn.closest("[data-strategy-name]") ||
                        document.querySelector("[data-current-strategy]") ||
                        btn.closest(".strategy-row") ||
                        document.body;
                      const strategyName =
                        (container &&
                          container.dataset &&
                          container.dataset.strategyName) ||
                        btn.dataset.strategyName ||
                        (document.querySelector('input[name="strategyName"]') &&
                          document.querySelector('input[name="strategyName"]')
                            .value) ||
                        null;
                      const colorInput = container
                        ? container.querySelector(
                            'input[type="color"], input[name*="color"], .color-picker input'
                          )
                        : document.querySelector(
                            'input[type="color"], input[name*="color"]'
                          );
                      const colorValue =
                        (colorInput &&
                          (colorInput.value ||
                            colorInput.getAttribute("value"))) ||
                        btn.dataset.colorValue ||
                        null;

                      // Detect correct save function
                      const saveFn =
                        /edit/i.test(text) || (onclick && /edit/i.test(onclick))
                          ? "editStrategyBtn"
                          : "addStrategyBtn";

                      await ensureColorSaveAndRefresh(
                        strategyName,
                        colorValue,
                        saveFn
                      );
                    }, 200);
                  } catch (e) {
                    console.warn("color wrapper error", e);
                  }
                },
                { capture: true }
              );
            }
          });
        }

        try {
          attachWrappers();
          const mo = new MutationObserver(() => attachWrappers());
          mo.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
          });
          console.log(
            "‚úÖ Color save wrapper (v3) with Add + Edit support installed"
          );
        } catch (e) {
          console.warn("Failed to install color wrapper (v3)", e);
        }

        window.saveColorAndRefresh = async function (
          strategyName,
          newColor,
          mode
        ) {
          const fnName = mode === "edit" ? "editStrategyBtn" : "addStrategyBtn";
          return ensureColorSaveAndRefresh(strategyName, newColor, fnName);
        };
      })();
    </script>
    <!-- Tap-to-Zoom Screenshot Feature (Improved Pinch & Scroll Zoom, v5) -->
    <style>
      #imageZoomOverlay {
        display: none;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        justify-content: center;
        align-items: center;
        overflow: hidden;
        touch-action: none;
      }
      #imageZoomOverlay img {
        max-width: 90%;
        max-height: 90%;
        cursor: zoom-out;
        transition: transform 0.15s ease;
        touch-action: none;
      }
    </style>
    <style>
      /* üß© FIX ‚Äî Make sure invisible overlays/toasts don't block clicks */

      /* 1Ô∏è‚É£ Allow clicks through toast when it‚Äôs hidden */
      #toast {
        pointer-events: none;
      }

      /* 2Ô∏è‚É£ Ensure the Strategies modal is always above everything else */
      #strategiesModal {
        z-index: 60 !important;
      }

      /* 3Ô∏è‚É£ Prevent hidden or transparent overlays from capturing clicks */
      .hidden,
      [style*="opacity: 0"] {
        pointer-events: none !important;
      }


      }
    </style>

    <script>
      (function () {
        const overlay = document.createElement("div");
        overlay.id = "imageZoomOverlay";
        overlay.innerHTML = '<img src="" alt="Zoomed Screenshot">';
        document.body.appendChild(overlay);

        const img = overlay.querySelector("img");
        let zoomLevel = 1;
        let startDistance = null;

        function openImage(src) {
          overlay.style.display = "flex";
          img.src = src;
          zoomLevel = 1;
          img.style.transform = "scale(1)";
        }

        function closeImage() {
          overlay.style.display = "none";
          img.src = "";
        }

        overlay.addEventListener("click", closeImage);

        // Desktop scroll zoom
        overlay.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            zoomLevel += e.deltaY * -0.001;
            zoomLevel = Math.min(Math.max(zoomLevel, 1), 5);
            img.style.transform = `scale(${zoomLevel})`;
          },
          { passive: false }
        );

        // Mobile pinch zoom
        overlay.addEventListener("touchstart", (e) => {
          if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            startDistance = Math.sqrt(dx * dx + dy * dy);
          }
        });

        overlay.addEventListener(
          "touchmove",
          (e) => {
            if (e.touches.length === 2 && startDistance) {
              e.preventDefault();
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              const newDistance = Math.sqrt(dx * dx + dy * dy);
              const scaleChange = newDistance / startDistance;
              zoomLevel = Math.min(Math.max(zoomLevel * scaleChange, 1), 5);
              img.style.transform = `scale(${zoomLevel})`;
              startDistance = newDistance;
            }
          },
          { passive: false }
        );

        overlay.addEventListener("touchend", (e) => {
          if (e.touches.length < 2) startDistance = null;
        });

        // Enable zoom for screenshots inside journal entries
        function enableZoom() {
          document
            .querySelectorAll(
              ".journal-entry img, .screenshot img, img.screenshot"
            )
            .forEach((el) => {
              if (!el.dataset.zoomable) {
                el.dataset.zoomable = true;
                el.style.cursor = "zoom-in";
                el.addEventListener("click", (e) => {
                  e.stopPropagation();
                  openImage(el.src);
                });
              }
            });
        }

        enableZoom();
        const observer = new MutationObserver(enableZoom);
        observer.observe(document.body, { childList: true, subtree: true });
      })();
    </script>
    <!-- Tap-to-Zoom Screenshot Feature (v6 - Mobile Fixes, Tap Toggle, Local Image Support) -->
    <script>
      (function () {
        const overlay = document.createElement("div");
        overlay.id = "imageZoomOverlay";
        overlay.style.cssText = `
    display:none;position:fixed;z-index:9999;top:0;left:0;width:100%;height:100%;
    background:rgba(0,0,0,0.9);justify-content:center;align-items:center;
  `;
        overlay.innerHTML =
          '<img src="" alt="Zoomed Screenshot" style="max-width:90%;max-height:90%;cursor:zoom-out;transition:transform 0.15s ease;">';
        document.body.appendChild(overlay);

        const img = overlay.querySelector("img");
        let zoomLevel = 1;
        let initialDistance = null;
        let isOpen = false;

        // Open or close image
        function toggleZoom(src) {
          if (isOpen) {
            overlay.style.display = "none";
            isOpen = false;
          } else {
            let fixedSrc = src;
            // Fix for local file URIs (Android WebView)
            if (src.startsWith("/") || src.startsWith("file://")) {
              try {
                fetch(src)
                  .then((r) => r.blob())
                  .then((b) => {
                    const blobURL = URL.createObjectURL(b);
                    img.src = blobURL;
                  });
              } catch (e) {
                console.warn("Image fetch failed", e);
              }
            } else {
              img.src = src;
            }
            overlay.style.display = "flex";
            zoomLevel = 1;
            img.style.transform = "scale(1)";
            isOpen = true;
          }
        }

        // Toggle overlay on click or tap
        overlay.addEventListener("click", () => toggleZoom(""));

        // Scroll zoom (desktop)
        img.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            zoomLevel += e.deltaY * -0.001;
            zoomLevel = Math.min(Math.max(zoomLevel, 1), 5);
            img.style.transform = `scale(${zoomLevel})`;
          },
          { passive: false }
        );

        // Touch start for pinch
        img.addEventListener(
          "touchstart",
          (e) => {
            if (e.touches.length === 2) {
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              initialDistance = Math.sqrt(dx * dx + dy * dy);
            }
          },
          { passive: false }
        );

        // Touch move for pinch zoom
        img.addEventListener(
          "touchmove",
          (e) => {
            if (e.touches.length === 2 && initialDistance) {
              e.preventDefault();
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const scaleChange = distance / initialDistance;
              zoomLevel = Math.min(Math.max(zoomLevel * scaleChange, 1), 5);
              img.style.transform = `scale(${zoomLevel})`;
              initialDistance = distance;
            }
          },
          { passive: false }
        );

        img.addEventListener(
          "touchend",
          () => {
            initialDistance = null;
          },
          { passive: false }
        );

        // Enable zoom only for screenshots inside journal entries
        function enableZoomOnScreenshots() {
          document
            .querySelectorAll(
              ".journal-entry img, .screenshot img, img.screenshot"
            )
            .forEach((el) => {
              if (!el.dataset.zoomable) {
                el.dataset.zoomable = true;
                el.style.cursor = "zoom-in";
                el.addEventListener("click", (e) => {
                  e.stopPropagation();
                  toggleZoom(el.src);
                });
                el.addEventListener(
                  "touchend",
                  (e) => {
                    e.stopPropagation();
                    toggleZoom(el.src);
                  },
                  { passive: true }
                );
              }
            });
        }

        enableZoomOnScreenshots();
        const observer = new MutationObserver(enableZoomOnScreenshots);
        observer.observe(document.body, { childList: true, subtree: true });
      })();
    </script>
    <!-- Tap-to-Zoom Screenshot Feature (v7 - Mobile WebView Fixes + Responsive Images) -->
    <style>
      /* Ensure screenshots always visible on small screens */
      .journal-entry img,
      .screenshot img,
      img.screenshot {
        max-width: 100% !important;
        height: auto !important;
        display: block;
        object-fit: contain !important;
        border-radius: 6px;
      }

      /* Overlay for zoomed image */
      #imageZoomOverlay {
        display: none;
        position: fixed;
        z-index: 9999;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        justify-content: center;
        align-items: center;
        touch-action: none;
        will-change: transform;
      }

      #imageZoomOverlay img {
        max-width: 95%;
        max-height: 95%;
        cursor: zoom-out;
        transition: transform 0.15s ease;
        touch-action: none;
        will-change: transform;
      }
    </style>
    <script>
      (function () {
        console.log("üì± v7 Zoom system initialized");

        const overlay = document.createElement("div");
        overlay.id = "imageZoomOverlay";
        overlay.innerHTML = '<img src="" alt="Zoomed Screenshot">';
        document.body.appendChild(overlay);

        const img = overlay.querySelector("img");
        let zoomLevel = 1;
        let initialDistance = null;
        let isOpen = false;

        function toggleZoom(src) {
          console.log("üîÑ toggleZoom", { src, isOpen });
          if (isOpen) {
            overlay.style.display = "none";
            isOpen = false;
          } else {
            let fixedSrc = src;
            if (src && (src.startsWith("/") || src.startsWith("file://"))) {
              console.log("üóÇ Local file detected", src);
              try {
                if (window.resolveLocalFileSystemURL) {
                  window.resolveLocalFileSystemURL(
                    src,
                    function (fileEntry) {
                      fileEntry.file(function (file) {
                        const reader = new FileReader();
                        reader.onloadend = function () {
                          img.src = this.result;
                        };
                        reader.readAsDataURL(file);
                      });
                    },
                    function (e) {
                      console.warn("resolveLocalFileSystemURL failed", e);
                    }
                  );
                } else {
                  fetch(src)
                    .then((r) => r.blob())
                    .then((b) => {
                      img.src = URL.createObjectURL(b);
                    });
                }
              } catch (e) {
                console.warn("Local image fetch error", e);
              }
            } else {
              img.src = src;
            }
            overlay.style.display = "flex";
            zoomLevel = 1;
            img.style.transform = "scale(1)";
            isOpen = true;
          }
        }

        // Tap toggle for closing
        overlay.addEventListener("click", () => {
          console.log("üñ± Overlay clicked -> closing");
          toggleZoom("");
        });

        // Scroll zoom (desktop)
        img.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            zoomLevel += e.deltaY * -0.001;
            zoomLevel = Math.min(Math.max(zoomLevel, 1), 5);
            img.style.transform = `scale(${zoomLevel})`;
            console.log("üñ± Wheel zoom", zoomLevel);
          },
          { passive: false }
        );

        // Touch start for pinch
        img.addEventListener(
          "touchstart",
          (e) => {
            if (e.touches.length === 2) {
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              initialDistance = Math.sqrt(dx * dx + dy * dy);
              console.log("ü§è Pinch start", initialDistance);
            }
          },
          { passive: false }
        );

        // Touch move for pinch zoom
        img.addEventListener(
          "touchmove",
          (e) => {
            if (e.touches.length === 2 && initialDistance) {
              e.preventDefault();
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const scaleChange = distance / initialDistance;
              zoomLevel = Math.min(Math.max(zoomLevel * scaleChange, 1), 5);
              img.style.transform = `scale(${zoomLevel})`;
              initialDistance = distance;
              console.log("üîç Pinching", zoomLevel);
            }
          },
          { passive: false }
        );

        img.addEventListener(
          "touchend",
          () => {
            initialDistance = null;
          },
          { passive: false }
        );

        // Enable zoom only for screenshots inside journal entries
        function enableZoomOnScreenshots() {
          document
            .querySelectorAll(
              ".journal-entry img, .screenshot img, img.screenshot"
            )
            .forEach((el) => {
              if (!el.dataset.zoomable) {
                el.dataset.zoomable = true;
                el.style.cursor = "zoom-in";
                el.addEventListener("click", (e) => {
                  e.stopPropagation();
                  toggleZoom(el.src);
                });
                el.addEventListener(
                  "touchend",
                  (e) => {
                    e.stopPropagation();
                    toggleZoom(el.src);
                  },
                  { passive: true }
                );
                console.log("‚ú® Zoom enabled for image", el.src);
              }
            });
        }

        enableZoomOnScreenshots();
        const observer = new MutationObserver(enableZoomOnScreenshots);
        observer.observe(document.body, { childList: true, subtree: true });
      })();
    </script>
    <!-- Tap-to-Zoom Screenshot Feature (v8 - WebView-compatible, canvas downscale) -->
    <style>
      /* Responsive screenshot styles */
      .journal-entry img,
      .screenshot img,
      img.screenshot {
        max-width: 100% !important;
        height: auto !important;
        display: block;
        object-fit: contain !important;
        border-radius: 6px;
      }

      /* Strong overlay rules with high z-index and isolation for WebView */
      #imageZoomOverlay {
        display: none !important;
        position: fixed !important;
        z-index: 2147483647 !important; /* very high priority */
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        background: rgba(0, 0, 0, 0.95) !important;
        justify-content: center !important;
        align-items: center !important;
        touch-action: none !important;
        overscroll-behavior: contain !important;
        transform: translateZ(0) !important;
        -webkit-transform: translateZ(0) !important;
        pointer-events: auto !important;
      }

      #imageZoomOverlay img {
        max-width: 96% !important;
        max-height: 96% !important;
        cursor: zoom-out !important;
        transition: transform 0.12s ease !important;
        touch-action: none !important;
        will-change: transform !important;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6) !important;
        border-radius: 6px !important;
        pointer-events: auto !important;
      }
    </style>
    <script>
      (function () {
        // Make sure the body allows touch interception by overlay (WebView compatibility)
        try {
          document.documentElement.style.touchAction = "none";
          document.body.style.touchAction = "none";
          document.body.style.overscrollBehavior = "contain";
        } catch (e) {
          console.warn("could not set touchAction", e);
        }

        const overlayId = "imageZoomOverlay";
        let overlay = document.getElementById(overlayId);
        if (!overlay) {
          overlay = document.createElement("div");
          overlay.id = overlayId;
          overlay.innerHTML = '<img alt="Zoomed Screenshot" />';
          document.body.appendChild(overlay);
        }
        const img = overlay.querySelector("img");
        let zoomLevel = 1;
        let initialDistance = null;
        let isOpen = false;
        let lastBlobUrl = null;

        function downscaleIfNeededAndSetSrc(src) {
          return new Promise((resolve, reject) => {
            // If src is already a data URL or blob URL or http(s), just load and check
            const loadImage = (finalSrc) => {
              const tmp = new Image();
              tmp.crossOrigin = "anonymous";
              tmp.onload = () => {
                // if image large, downscale via canvas
                const MAX = 4096; // safe max for many devices
                if (tmp.naturalWidth > MAX || tmp.naturalHeight > MAX) {
                  try {
                    const scale = Math.min(
                      1,
                      MAX / Math.max(tmp.naturalWidth, tmp.naturalHeight)
                    );
                    const w = Math.round(tmp.naturalWidth * scale);
                    const h = Math.round(tmp.naturalHeight * scale);
                    const canvas = document.createElement("canvas");
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext("2d");
                    ctx.drawImage(tmp, 0, 0, w, h);
                    const dataUrl = canvas.toDataURL("image/jpeg", 0.85);
                    resolve(dataUrl);
                  } catch (err) {
                    console.warn("downscale failed", err);
                    resolve(finalSrc);
                  }
                } else {
                  resolve(finalSrc);
                }
              };
              tmp.onerror = () => resolve(finalSrc);
              tmp.src = finalSrc;
            };

            // If local file path (starts with / or file://) try to fetch as blob (WebView)
            if (
              typeof src === "string" &&
              (src.startsWith("file://") || src.startsWith("/"))
            ) {
              // try fetch; in Capacitor this may work, otherwise fallback to src
              fetch(src)
                .then((r) => r.blob())
                .then((b) => {
                  const blobURL = URL.createObjectURL(b);
                  // remember to revoke previous blob to avoid leaks
                  if (lastBlobUrl && lastBlobUrl !== blobURL)
                    try {
                      URL.revokeObjectURL(lastBlobUrl);
                    } catch (e) {}
                  lastBlobUrl = blobURL;
                  loadImage(blobURL);
                })
                .catch((err) => {
                  // fallback: set src directly (some WebViews accept file://)
                  console.warn("fetch local file failed", err);
                  resolve(src);
                });
            } else {
              loadImage(src);
            }
          });
        }

        async function openImage(src) {
          if (!src) return;
          try {
            overlay.style.display = "flex";
            zoomLevel = 1;
            img.style.transform = "scale(1)";
            // resolve and downscale if needed
            const fixed = await downscaleIfNeededAndSetSrc(src);
            img.src = fixed;
            isOpen = true;
          } catch (e) {
            console.warn("openImage error", e);
            overlay.style.display = "flex";
            img.src = src;
            isOpen = true;
          }
        }

        function closeOverlay() {
          overlay.style.display = "none";
          // revoke blob url if used
          try {
            if (lastBlobUrl) {
              URL.revokeObjectURL(lastBlobUrl);
              lastBlobUrl = null;
            }
          } catch (e) {}
          img.src = "";
          isOpen = false;
        }

        function toggle(src) {
          if (isOpen) closeOverlay();
          else openImage(src);
        }

        // Unified tap/click handler for images in entries
        function enableZoomOnScreenshots() {
          const selector =
            ".journal-entry img, .screenshot img, img.screenshot";
          document.querySelectorAll(selector).forEach((el) => {
            if (!el.dataset.zoomable) {
              el.dataset.zoomable = "1";
              el.style.cursor = "zoom-in";
              // click handler
              el.addEventListener(
                "click",
                (e) => {
                  e.stopPropagation();
                  toggle(el.src);
                },
                { passive: true }
              );
              // touchend handler as backup
              el.addEventListener(
                "touchend",
                (e) => {
                  e.stopImmediatePropagation();
                  toggle(el.src);
                },
                { passive: true }
              );
            }
          });
        }

        // wheel on image for desktop zoom
        img.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            zoomLevel += e.deltaY * -0.0015;
            zoomLevel = Math.max(1, Math.min(zoomLevel, 6));
            img.style.transform = `scale(${zoomLevel})`;
          },
          { passive: false }
        );

        // touch gestures on image
        img.addEventListener(
          "touchstart",
          (e) => {
            if (e.touches && e.touches.length === 2) {
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              initialDistance = Math.hypot(dx, dy);
            }
          },
          { passive: false }
        );

        img.addEventListener(
          "touchmove",
          (e) => {
            if (e.touches && e.touches.length === 2 && initialDistance) {
              e.preventDefault();
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              const distance = Math.hypot(dx, dy);
              const scaleChange = distance / initialDistance;
              zoomLevel = Math.max(1, Math.min(zoomLevel * scaleChange, 6));
              img.style.transform = `scale(${zoomLevel})`;
              initialDistance = distance;
            }
          },
          { passive: false }
        );

        img.addEventListener(
          "touchend",
          () => {
            initialDistance = null;
          },
          { passive: false }
        );

        // close overlay when pressing background (overlay itself)
        overlay.addEventListener(
          "click",
          (e) => {
            if (e.target === overlay) closeOverlay();
          },
          { passive: true }
        );

        // Observe DOM for dynamically added screenshots
        const mo = new MutationObserver(enableZoomOnScreenshots);
        mo.observe(document.body, { childList: true, subtree: true });
        // initial enable
        enableZoomOnScreenshots();

        // expose for debugging
        window.__zoomOverlay = overlay;
        window.__zoomOpen = openImage;
        window.__zoomClose = closeOverlay;
        window.__zoomToggle = toggle;

        console.log("v8 zoom patch loaded");
      })();
    </script>
    <script>
      (function () {
        const imageModal = document.getElementById("imageModal");
        const zoomedImage = document.getElementById("zoomedImage");

        let scale = 1;
        let isDragging = false;
        let startX,
          startY,
          originX = 0,
          originY = 0;

        window.showImageModal = function (src) {
          zoomedImage.src = src;
          scale = 1;
          originX = originY = 0;
          zoomedImage.style.transform = `translate(0px, 0px) scale(1)`;
          imageModal.classList.remove("hidden");
        };

        imageModal.addEventListener("click", (e) => {
          if (e.target === imageModal || e.target === zoomedImage) {
            imageModal.classList.add("hidden");
          }
        });

        imageModal.addEventListener("wheel", (e) => {
          e.preventDefault();
          const zoomIntensity = 0.1;
          if (e.deltaY < 0) scale += zoomIntensity;
          else scale = Math.max(1, scale - zoomIntensity);
          zoomedImage.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;
        });

        let initialDistance = null;
        let lastScale = 1;
        imageModal.addEventListener("touchstart", (e) => {
          if (e.touches.length === 2) {
            initialDistance = Math.hypot(
              e.touches[0].pageX - e.touches[1].pageX,
              e.touches[0].pageY - e.touches[1].pageY
            );
            lastScale = scale;
          }
        });

        imageModal.addEventListener("touchmove", (e) => {
          if (e.touches.length === 2 && initialDistance) {
            const newDistance = Math.hypot(
              e.touches[0].pageX - e.touches[1].pageX,
              e.touches[0].pageY - e.touches[1].pageY
            );
            scale = Math.max(1, lastScale * (newDistance / initialDistance));
            zoomedImage.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;
          }
        });

        zoomedImage.addEventListener("mousedown", (e) => {
          if (scale <= 1) return;
          isDragging = true;
          startX = e.clientX - originX;
          startY = e.clientY - originY;
          zoomedImage.style.cursor = "grabbing";
        });
        imageModal.addEventListener("mouseup", () => {
          isDragging = false;
          zoomedImage.style.cursor = "grab";
        });
        imageModal.addEventListener("mousemove", (e) => {
          if (!isDragging) return;
          originX = e.clientX - startX;
          originY = e.clientY - startY;
          zoomedImage.style.transform = `translate(${originX}px, ${originY}px) scale(${scale})`;
        });
      })();
    </script>
    <script>
      // Allow touch scroll inside scrollable sections without blocking main scroll
      document.addEventListener(
        "touchmove",
        function (e) {
          if (e.target.closest(".scrollable-list")) {
            e.stopPropagation();
          }
        },
        { passive: true }
      );
    </script>
    <script>
      // Enable touch scrolling inside WebView or mobile browsers
      document.addEventListener(
        "touchstart",
        function (e) {
          e.stopPropagation();
        },
        { passive: true }
      );

      document.addEventListener(
        "touchmove",
        function (e) {
          if (!e.target.closest(".fixed")) return;
        },
        { passive: true }
      );
    </script>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const backupBtn = document.getElementById("backupJsonBtn");
        if (!backupBtn) return;

        backupBtn.addEventListener("click", async () => {
          try {
            const dbRequest = indexedDB.open("ForexJournalDB");

            dbRequest.onerror = function () {
              alert("‚ùå Could not open IndexedDB 'ForexJournalDB'.");
            };

            dbRequest.onsuccess = async function (event) {
              const db = event.target.result;
              const storeNames = Array.from(db.objectStoreNames);

              if (!storeNames.length) {
                alert("‚ö†Ô∏è No data found in IndexedDB.");
                return;
              }

              const exportData = {};
              const allDataPromises = storeNames.map(
                (storeName) =>
                  new Promise((resolve) => {
                    const tx = db.transaction(storeName, "readonly");
                    const store = tx.objectStore(storeName);
                    const getAllRequest = store.getAll();

                    getAllRequest.onsuccess = () => {
                      exportData[storeName] = getAllRequest.result || [];
                      resolve();
                    };
                    getAllRequest.onerror = () => {
                      console.error("‚ùå Error reading store:", storeName);
                      exportData[storeName] = [];
                      resolve(); // keep going even if one fails
                    };
                  })
              );

              await Promise.all(allDataPromises);

              const jsonData = JSON.stringify(
                {
                  timestamp: new Date().toISOString(),
                  ...exportData,
                },
                null,
                2
              );

              const isAndroidWebView =
                /wv|android/i.test(navigator.userAgent) && window.Android;

              if (
                isAndroidWebView &&
                typeof window.Android.saveBackupToDownloads === "function"
              ) {
                console.log("‚úÖ Using Android native saveBackupToDownloads");
                window.Android.saveBackupToDownloads(jsonData);
                alert("‚úÖ Backup saved to Downloads (Android)");
              } else {
                console.log("üíæ Using browser download fallback");
                const blob = new Blob([jsonData], { type: "application/json" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = `forex_journal_backup_${
                  new Date().toISOString().split("T")[0]
                }.json`;
                a.click();
                URL.revokeObjectURL(a.href);
                alert("‚úÖ Backup saved (browser mode)");
              }
            };
          } catch (err) {
            console.error("Backup failed:", err);
            alert("‚ùå Backup failed: " + err.message);
          }
        });
      });
    </script>

    <!-- Inline non-destructive patch: image & strategy fixes -->
    <script>
      (function () {
        // Helper: open IndexedDB 'ForexJournalDB' and get object store 'entries'
        function openDB() {
          return new Promise((resolve, reject) => {
            const req = indexedDB.open("ForexJournalDB");
            req.onsuccess = (e) => resolve(e.target.result);
            req.onerror = (e) => reject(e);
          });
        }

        function getEntryById(id) {
          return new Promise(async (resolve, reject) => {
            try {
              const db = await openDB();
              const tx = db.transaction("entries", "readonly");
              const store = tx.objectStore("entries");
              const r = store.get(Number(id));
              r.onsuccess = () => resolve(r.result);
              r.onerror = () => reject(r.error);
            } catch (err) {
              reject(err);
            }
          });
        }

        function putEntry(entry) {
          return new Promise(async (resolve, reject) => {
            try {
              const db = await openDB();
              const tx = db.transaction("entries", "readwrite");
              const store = tx.objectStore("entries");
              const r = store.put(entry);
              r.onsuccess = () => resolve(r.result);
              r.onerror = () => reject(r.error);
            } catch (err) {
              reject(err);
            }
          });
        }

        // convert File to base64 dataURL
        function fileToBase64(file) {
          return new Promise((res, rej) => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.onerror = rej;
            reader.readAsDataURL(file);
          });
        }

        // utility to collect selected strategy chips' names
        function getSelectedStrategies() {
          const chips = document.querySelectorAll(
            ".strategy-chip.selected, .chip.selected"
          );
          const names = [];
          chips.forEach((c) => {
            let name =
              c.dataset.name ||
              c.dataset.strategy ||
              c.textContent ||
              c.innerText;
            if (name) names.push(name.toString().trim());
          });
          return names;
        }

        // Apply pre/post images onto thumbnails if available
        function applyThumbnailsToForm(entry) {
          try {
            const preThumb = document.getElementById("preThumb");
            const postThumb = document.getElementById("postThumb");
            const preInput = document.getElementById("preTradeImage");
            const postInput = document.getElementById("postTradeImage");

            if (entry && entry.preTradeImage) {
              if (preThumb) preThumb.src = entry.preTradeImage;
              if (preInput) preInput.dataset.existing = entry.preTradeImage;
            } else if (preInput) {
              delete preInput.dataset.existing;
              if (preThumb) preThumb.removeAttribute("src");
            }

            if (entry && entry.postTradeImage) {
              if (postThumb) postThumb.src = entry.postTradeImage;
              if (postInput) postInput.dataset.existing = entry.postTradeImage;
            } else if (postInput) {
              delete postInput.dataset.existing;
              if (postThumb) postThumb.removeAttribute("src");
            }
          } catch (e) {
            console.warn(e);
          }
        }

        // Preselect strategy chips based on entry.strategies array
        function preselectStrategyChips(entry) {
          try {
            const saved = entry && entry.strategies ? entry.strategies : [];
            const chips = document.querySelectorAll(".strategy-chip, .chip");
            chips.forEach((chip) => {
              const name =
                chip.dataset.name ||
                chip.dataset.strategy ||
                chip.textContent ||
                chip.innerText;
              if (!name) return;
              const should = saved.includes(name.toString().trim());
              if (should) chip.classList.add("selected");
              else chip.classList.remove("selected");
            });
          } catch (e) {
            console.warn(e);
          }
        }

        // Wrap existing addEntryModalContent if present to populate images & chips
        if (typeof window.addEntryModalContent === "function") {
          const orig = window.addEntryModalContent;
          window.addEntryModalContent = async function (arg) {
            // call original (may fill form), then attempt to fetch entry if arg is id
            try {
              await orig(arg);
            } catch (e) {
              try {
                orig(arg);
              } catch (e2) {}
            }
            try {
              let entry = null;
              if (arg && (typeof arg === "number" || !isNaN(Number(arg)))) {
                entry = await getEntryById(Number(arg));
              } else if (arg && typeof arg === "object") {
                entry = arg;
              } else {
                // try to detect editing id from form dataset
                const form = document.querySelector("#journalForm, form");
                if (form && form.dataset && form.dataset.editingId) {
                  entry = await getEntryById(Number(form.dataset.editingId));
                }
              }
              if (entry) {
                applyThumbnailsToForm(entry);
                preselectStrategyChips(entry);
              }
            } catch (err) {
              // ignore
              console.warn("addEntryModalContent patch error", err);
            }
          };
        }

        // Hook submitBtn to save images and strategies properly
        document.addEventListener("DOMContentLoaded", function () {
          const submitBtn = document.getElementById("submitBtn");
          const form =
            document.getElementById("journalForm") ||
            document.querySelector("form");
          if (!form || !submitBtn) {
            // try to attach to form submit if button not found
            if (form) {
              form.addEventListener("submit", async function (e) {
                e.preventDefault();
                await handleFormSave(form);
              });
            }
            return;
          }

          // intercept submit
          form.addEventListener("submit", async function (e) {
            e.preventDefault();
            await handleFormSave(form);
          });

          async function handleFormSave(formEl) {
            try {
              // gather form data
              const fd = new FormData(formEl);
              const entry = {};
              for (const [k, v] of fd.entries()) {
                entry[k] = v;
              }

              // strategies from chips override any field
              const selectedStrategies = getSelectedStrategies();
              if (selectedStrategies.length)
                entry.strategies = selectedStrategies;

              // handle file inputs
              const preInput = document.getElementById("preTradeImage");
              const postInput = document.getElementById("postTradeImage");

              if (preInput) {
                if (preInput.files && preInput.files.length) {
                  entry.preTradeImage = await resizeAndConvertToBase64(
                    preInput.files[0]
                  );
                } else if (preInput.dataset && preInput.dataset.existing) {
                  entry.preTradeImage = preInput.dataset.existing;
                }
              }
              if (postInput) {
                if (postInput.files && postInput.files.length) {
                  entry.postTradeImage = await resizeAndConvertToBase64(
                    postInput.files[0]
                  );
                } else if (postInput.dataset && postInput.dataset.existing) {
                  entry.postTradeImage = postInput.dataset.existing;
                }
              } // clear file input datasets so next edit will load fresh

              // ... (Your logic for refreshing the UI) ...

              if (preInput) {
                preInput.value = "";
                delete preInput.dataset.existing;
              }
              if (postInput) {
                postInput.value = "";
                delete postInput.dataset.existing;
              }

              // üí• FIX: Clear all form fields (textareas, inputs, etc.)
              // This stops the old entry data from being submitted as a new entry.
              if (form) {
                form.reset();
              } // close modal if present

              const modal = document.getElementById("addEntryModal");
              if (modal) modal.classList.add("hidden");

              // ... (Rest of the code) ...

              // determine editing or new
              const editingId =
                formEl.dataset.editingId || fd.get("id") || fd.get("entryId");
              if (editingId) {
                entry.id = Number(editingId);
                await putEntry(entry);
              } else {
                // ensure id exists
                entry.id = entry.id ? Number(entry.id) : Date.now();
                await putEntry(entry);
              }

              // refresh UI: call render function if exists, else reload entries if function exists
              if (typeof window.renderJournalEntries === "function") {
                try {
                  await window.renderJournalEntries();
                } catch (e) {}
              } else if (typeof window.loadEntries === "function") {
                try {
                  await window.loadEntries();
                } catch (e) {}
              } else {
                // fallback: reload page
                try {
                  location.reload();
                } catch (e) {}
              }

              // close modal if present
              const modal = document.getElementById("addEntryModal");
              if (modal) modal.classList.add("hidden");

              // clear file input datasets so next edit will load fresh
              if (preInput) {
                preInput.value = "";
                delete preInput.dataset.existing;
              }
              if (postInput) {
                postInput.value = "";
                delete postInput.dataset.existing;
              }

              // show success if function exists
              if (typeof window.showMessageModal === "function") {
                try {
                  window.showMessageModal(
                    "Entry saved successfully.",
                    "success"
                  );
                } catch (e) {}
              } else {
                try {
                  alert("Entry saved successfully.");
                } catch (e) {}
              }
            } catch (err) {
              console.error("handleFormSave error", err);
              try {
                alert("Failed to save entry: " + err.message);
              } catch (e) {}
            }
          }

          // enhance journalList rendering by ensuring thumbnails are set after render
          const origRender = window.renderJournalEntries;
          if (typeof origRender === "function") {
            window.renderJournalEntries = async function () {
              await origRender();
              // apply thumbnails on all rendered cards
              try {
                const list =
                  document.getElementById("journalList") ||
                  document.querySelector(".journal-list");
                if (!list) return;
                const items = list.querySelectorAll("[data-entry-id]");
                for (const el of items) {
                  const id =
                    el.dataset.entryId || el.getAttribute("data-entry-id");
                  if (!id) continue;
                  const data = await getEntryById(Number(id));
                  if (!data) continue;
                  // find img placeholders inside card
                  const preImg = el.querySelector(
                    "#preThumb, .preThumb, .pre-trade-img, img.pre-trade"
                  );
                  const postImg = el.querySelector(
                    "#postThumb, .postThumb, .post-trade-img, img.post-trade"
                  );
                  if (preImg && data.preTradeImage)
                    preImg.src = data.preTradeImage;
                  if (postImg && data.postTradeImage)
                    postImg.src = data.postTradeImage;
                }
              } catch (e) {
                console.warn(e);
              }
            };
          }
        }); // DOMContentLoaded
      })();
    </script>
    <script>
      async function initApp() {
        const splash = document.getElementById("splash-screen");
        const ring = document.getElementById("splash-ring");
        const percentText = document.getElementById("splash-percent");
        const splashText = document.getElementById("splash-text");

        function updateSplash(progress, text) {
          const percent = Math.min(100, progress);
          const dashOffset = 283 - (283 * percent) / 100;
          ring.style.strokeDashoffset = dashOffset;
          percentText.textContent = `${percent}%`;
          splashText.textContent = text;
        }

        try {
          splash.style.display = "flex";
          updateSplash(0, "Opening database...");

          await openDB();
          updateSplash(20, "Loading default strategies...");

          await ensureDefaults();
          updateSplash(40, "Fetching strategies...");

          await loadStrategies();
          updateSplash(60, "Loading journal entries...");

          await loadEntries();
          updateSplash(80, "Rendering interface...");

          await renderJournalEntries();
          updateSplash(100, "Ready!");
        } catch (err) {
          console.error("Initialization failed:", err);
          splashText.textContent = "Error loading app üòû";
          ring.classList.add("text-red-500");
        } finally {
          // Short pause for polish
          setTimeout(() => {
            splash.classList.add("opacity-0");
            setTimeout(() => splash.remove(), 700);
          }, 800);
        }
      }

      window.addEventListener("DOMContentLoaded", initApp);
    </script>
  </body>
</html>
