<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Forex Trading Journal (Offline Ready)</title>
    <link rel="stylesheet" href="./output.css" />
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

    <style>
      /* 7. UI and Design Polish: Custom Scrollbar Styles */
      body {
        font-family: "Inter", sans-serif;
        transition: background-color 0.3s, color 0.3s;
      }

      .scrollable-list {
        max-height: 70vh;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #4f46e5 #f5f7fa;
      }

      .scrollable-list::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      .scrollable-list::-webkit-scrollbar-track {
        background: #f5f7fa;
        border-radius: 10px;
      }
      .scrollable-list::-webkit-scrollbar-thumb {
        background: #4f46e5;
        border-radius: 10px;
      }
      .scrollable-list::-webkit-scrollbar-thumb:hover {
        background: #3730a3;
      }

      /* Dark Mode Styles */
      @media (prefers-color-scheme: dark) {
        .dark-mode-text {
          color: white;
        }

        .dark-mode-bg {
          background-color: #1f2937;
        }

        .scrollable-list::-webkit-scrollbar-track {
          background: #1f2937;
        }
        .scrollable-list::-webkit-scrollbar-thumb {
          background: #3b82f6;
        }
        .scrollable-list::-webkit-scrollbar-thumb:hover {
          background: #2563eb;
        }
      }

      /* Splash Screen Styles */
      #splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #f3f4f6; /* Light background */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
        transition: opacity 0.7s ease-out;
      }

      @media (prefers-color-scheme: dark) {
        #splash-screen {
          background-color: #1f2937; /* Dark background */
        }
      }

      .splash-ring-container {
        position: relative;
        width: 100px;
        height: 100px;
        margin-bottom: 20px;
      }

      .splash-ring {
        fill: transparent;
        stroke: #6366f1; /* Indigo color */
        stroke-width: 5px;
        stroke-dasharray: 283; /* 2 * PI * 45 (r=45 for 90x90 circle) */
        stroke-dashoffset: 283;
        transition: stroke-dashoffset 0.5s ease-out, stroke 0.3s;
      }

      .splash-percent {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: 600;
        font-size: 1.25rem;
        color: #6366f1; /* Indigo color */
      }
    </style>
  </head>

  <body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200">
    <div id="splash-screen">
      <div class="splash-ring-container">
        <svg viewBox="0 0 100 100" class="w-full h-full">
          <circle
            cx="50"
            cy="50"
            r="45"
            stroke="#e5e7eb"
            stroke-width="5"
            fill="none"
          ></circle>
          <circle
            cx="50"
            cy="50"
            r="45"
            id="splash-ring"
            class="splash-ring"
            transform="rotate(-90 50 50)"
            fill="none"
          ></circle>
        </svg>
        <div id="splash-percent" class="splash-percent">0%</div>
      </div>
      <p id="splash-text" class="text-lg font-medium text-gray-700 dark:text-gray-300">
        Loading...
      </p>
    </div>
    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
      <header class="mb-8 flex flex-col sm:flex-row justify-between items-start sm:items-center">
        <h1 class="text-3xl font-bold text-indigo-600 dark:text-indigo-400">
          Forex Trading Journal
        </h1>
        <div class="flex space-x-2 mt-4 sm:mt-0">
          <button
            id="exportBtn"
            class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md"
          >
            Export CSV
          </button>
          <button
            id="importBtn"
            class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md"
          >
            Import CSV
          </button>
          <button
            id="deleteAllBtn"
            class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md"
          >
            Clear All Data
          </button>
        </div>
      </header>

      <section
        class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg mb-8"
      >
        <h2 class="text-2xl font-semibold mb-4 text-gray-900 dark:text-gray-100">
          Add New Trade Entry
        </h2>
        <form id="tradeForm" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          <div>
            <label
              for="tradeDate"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Date</label
            >
            <input
              type="date"
              id="tradeDate"
              required
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            />
          </div>

          <div>
            <label
              for="currencyPair"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Currency Pair</label
            >
            <input
              type="text"
              id="currencyPair"
              required
              list="pairSuggestions"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 uppercase dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            />
            <datalist id="pairSuggestions">
              </datalist>
          </div>

          <div>
            <label
              for="strategy"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Strategy</label
            >
            <select
              id="strategy"
              required
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            >
              <option value="">Select a Strategy</option>
              </select>
          </div>

          <div>
            <label
              for="direction"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Direction</label
            >
            <select
              id="direction"
              required
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            >
              <option value="Long">Long</option>
              <option value="Short">Short</option>
            </select>
          </div>

          <div>
            <label
              for="result"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Result</label
            >
            <select
              id="result"
              required
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            >
              <option value="Win">Win</option>
              <option value="Loss">Loss</option>
              <option value="Break Even">Break Even</option>
            </select>
          </div>

          <div>
            <label
              for="pips"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Pips Gained/Lost (Optional)</label
            >
            <input
              type="number"
              id="pips"
              step="0.1"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            />
          </div>

          <div class="md:col-span-2 lg:col-span-3">
            <label
              for="imageFile"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Trade Screenshot (Optional)</label
            >
            <input
              type="file"
              id="imageFile"
              accept="image/*"
              class="mt-1 block w-full text-sm text-gray-500 dark:text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 dark:file:bg-gray-700 dark:file:text-indigo-400 dark:file:hover:bg-gray-600"
            />
            <div id="imagePreviewContainer" class="mt-2 hidden">
              <img id="imagePreview" class="w-24 h-24 object-cover rounded-md" alt="Trade Screenshot Preview" />
              <button type="button" id="clearImageBtn" class="mt-1 text-xs text-red-500 hover:text-red-700">Remove Image</button>
            </div>
            <input type="hidden" id="imageData" />
          </div>

          <div class="md:col-span-2 lg:col-span-3">
            <label
              for="notes"
              class="block text-sm font-medium text-gray-700 dark:text-gray-300"
              >Notes (Optional)</label
            >
            <textarea
              id="notes"
              rows="3"
              class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
            ></textarea>
          </div>

          <input type="hidden" id="entryId" />

          <div class="md:col-span-2 lg:col-span-3 pt-4 flex space-x-4">
            <button
              type="submit"
              class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-lg"
            >
              Save Trade
            </button>
            <button
              type="button"
              id="cancelEditBtn"
              class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-lg hidden"
            >
              Cancel Edit
            </button>
          </div>
        </form>
      </section>

      <section
        id="strategy-section"
        class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg mb-8"
      >
        <h2 class="text-2xl font-semibold mb-4 text-gray-900 dark:text-gray-100">
          Strategy Management
        </h2>
        <form id="strategyForm" class="flex space-x-4 mb-4">
          <input
            type="text"
            id="strategyName"
            placeholder="New Strategy Name (e.g., London Breakout)"
            required
            class="flex-1 rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
          />
          <button
            type="submit"
            class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow-md"
          >
            Add Strategy
          </button>
        </form>
        <ul
          id="strategyList"
          class="space-y-2 scrollable-list p-2 border border-gray-200 dark:border-gray-700 rounded-lg max-h-48 overflow-y-auto"
        >
          </ul>
      </section>

      <section
        class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg"
      >
        <h2 class="text-2xl font-semibold mb-4 text-gray-900 dark:text-gray-100">
          Journal Entries
        </h2>
        <div class="mb-4">
          <input
            type="text"
            id="filterText"
            placeholder="Filter by Pair, Strategy, or Notes..."
            class="w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-200"
          />
        </div>
        <div id="entriesList" class="space-y-4 scrollable-list p-2">
          </div>
      </section>

      <div
        id="toast"
        class="fixed bottom-4 right-4 bg-indigo-600 text-white p-3 rounded-lg shadow-xl hidden transition-opacity duration-300"
      >
        Trade saved successfully!
      </div>
    </div>

    <script>
      // =========================================================================================================================
      // 1. SQLite Helpers (Replaces IndexedDB logic)
      // =========================================================================================================================

      const DB_NAME = "ForexJournalDB";
      const STORE_ENTRIES = "entries";
      const STORE_STRATEGIES = "strategies";

      let db;

      // Helper to safely get the plugin (assuming standard Capacitor plugin global access)
      const getSqlitePlugin = () => {
          if (window.Capacitor?.Plugins?.Sqlite) {
              return window.Capacitor.Plugins.Sqlite;
          } else {
              // Dummy implementation for web/testing where plugin is not available
              console.warn("Capacitor SQLite Plugin not available. Using a dummy implementation.");
              return {
                  open: async () => ({ database: DB_NAME }), // Returns database name as a substitute for databaseId
                  execute: async (options) => { console.log("Dummy Execute:", options.statements); return { changes: { changes: 0 } }; },
                  query: async (options) => { console.log("Dummy Query:", options.statement); return { values: [] }; },
                  close: async () => { console.log("Dummy Close."); },
                  run: async (options) => { console.log("Dummy Run:", options.statement); return { changes: { changes: 0 } }; },
                  isDatabase: async () => ({ result: false }),
                  dropDatabase: async () => { console.log("Dummy Drop."); },
              };
          }
      };

      const Sqlite = getSqlitePlugin();

      /**
       * Open the SQLite database and initialize the tables.
       */
      async function openDB() {
          try {
              // The `open` method handles creation/opening
              const { database } = await Sqlite.open({
                  database: DB_NAME,
                  encrypted: false,
                  mode: 'full',
                  version: 1,
                  readonly: false
              });
              db = database; // Use the database name as the identifier

              // SQL statements to create tables if they do not exist
              // The 'id' column in entries will be the primary key for auto-increment.
              const statements = `
                  CREATE TABLE IF NOT EXISTS ${STORE_ENTRIES} (
                      id INTEGER PRIMARY KEY,
                      date TEXT NOT NULL,
                      pair TEXT NOT NULL,
                      strategy TEXT NOT NULL,
                      direction TEXT NOT NULL,
                      result TEXT NOT NULL,
                      pips REAL,
                      image TEXT,
                      notes TEXT,
                      timestamp INTEGER NOT NULL
                  );
                  CREATE TABLE IF NOT EXISTS ${STORE_STRATEGIES} (
                      name TEXT PRIMARY KEY NOT NULL,
                      description TEXT
                  );
              `;

              await Sqlite.execute({ database: db, statements: statements });
              console.log("SQLite Database initialized.");
          } catch (err) {
              console.error("SQLite Initialization failed:", err);
              throw err;
          }
      }

      /**
       * Saves an item to a store (table).
       * If item.id is provided, it attempts to update (using UPDATE).
       * @param {string} storeName - The name of the table (STORE_ENTRIES or STORE_STRATEGIES).
       * @param {Object} item - The object to save.
       */
      async function addItem(storeName, item) {
          if (storeName === STORE_ENTRIES) {
              // Save a trade entry
              const sql = item.id
                  ? `
                      UPDATE ${STORE_ENTRIES} SET
                          date=?, pair=?, strategy=?, direction=?, result=?, pips=?, image=?, notes=?, timestamp=?
                      WHERE id=?
                  `
                  : `
                      INSERT INTO ${STORE_ENTRIES}
                          (date, pair, strategy, direction, result, pips, image, notes, timestamp)
                      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                  `;

              const values = item.id
                  ? [
                      item.date, item.pair, item.strategy, item.direction, item.result, item.pips || null, item.image || null, item.notes || null, item.timestamp,
                      item.id
                  ]
                  : [
                      item.date, item.pair, item.strategy, item.direction, item.result, item.pips || null, item.image || null, item.notes || null, item.timestamp
                  ];

              const result = await Sqlite.run({ database: db, statement: sql, values: values });
              return item.id ? item.id : result.changes.lastId;
          } else if (storeName === STORE_STRATEGIES) {
              // Save a strategy. Name is the primary key.
              const sql = `INSERT OR REPLACE INTO ${STORE_STRATEGIES} (name, description) VALUES (?, ?)`;
              await Sqlite.run({ database: db, statement: sql, values: [item.name, item.description || null] });
              return item.name;
          }
      }

      /**
       * Retrieves all items from a store (table).
       * @param {string} storeName - The name of the table.
       * @returns {Promise<Array<Object>>} - The list of items.
       */
      async function getAll(storeName) {
          let orderBy = '';
          if (storeName === STORE_ENTRIES) {
              orderBy = 'ORDER BY timestamp DESC';
          }
          const sql = `SELECT * FROM ${storeName} ${orderBy}`;
          const result = await Sqlite.query({ database: db, statement: sql, values: [] });

          // Rows are returned as an array of objects
          return result.values || [];
      }

      /**
       * Deletes an item from a store (table) by its key (id or name).
       * @param {string} storeName - The name of the table.
       * @param {*} key - The key (id for entries, name for strategies).
       */
      async function deleteItem(storeName, key) {
          const keyColumn = storeName === STORE_ENTRIES ? 'id' : 'name';
          const sql = `DELETE FROM ${storeName} WHERE ${keyColumn} = ?`;
          await Sqlite.run({ database: db, statement: sql, values: [key] });
      }

      /**
       * Clears all data from a store (table).
       * @param {string} storeName - The name of the table.
       */
      async function clear(storeName) {
          const sql = `DELETE FROM ${storeName}`;
          await Sqlite.run({ database: db, statement: sql, values: [] });
      }

      // =========================================================================================================================
      // 2. State & DOM References
      // =========================================================================================================================

      let journalEntries = [];
      let tradingStrategies = [];
      let currencyPairs = [];

      const tradeForm = document.getElementById("tradeForm");
      const strategyForm = document.getElementById("strategyForm");
      const entriesList = document.getElementById("entriesList");
      const strategyList = document.getElementById("strategyList");
      const strategySelect = document.getElementById("strategy");
      const pairSuggestions = document.getElementById("pairSuggestions");

      const exportBtn = document.getElementById("exportBtn");
      const importBtn = document.getElementById("importBtn");
      const deleteAllBtn = document.getElementById("deleteAllBtn");
      const filterText = document.getElementById("filterText");

      const imageFile = document.getElementById("imageFile");
      const imageDataField = document.getElementById("imageData");
      const imagePreview = document.getElementById("imagePreview");
      const imagePreviewContainer = document.getElementById("imagePreviewContainer");
      const clearImageBtn = document.getElementById("clearImageBtn");
      const cancelEditBtn = document.getElementById("cancelEditBtn");

      // =========================================================================================================================
      // 3. Trade Entry Logic
      // =========================================================================================================================

      /**
       * Converts a file (image) to a Base64 string.
       * @param {File} file
       * @returns {Promise<string>}
       */
      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = (error) => reject(error);
          reader.readAsDataURL(file);
        });
      }

      /**
       * Handles trade form submission (Add/Edit).
       */
      tradeForm.addEventListener("submit", async (e) => {
        e.preventDefault();

        const entryId = document.getElementById("entryId").value;
        const date = document.getElementById("tradeDate").value;
        const pair = document.getElementById("currencyPair").value.toUpperCase();
        const strategy = document.getElementById("strategy").value;
        const direction = document.getElementById("direction").value;
        const result = document.getElementById("result").value;
        const pips = parseFloat(document.getElementById("pips").value) || null;
        const notes = document.getElementById("notes").value.trim() || null;
        let image = imageDataField.value || null;

        // Handle new image upload during submission
        if (imageFile.files.length > 0) {
          image = await fileToBase64(imageFile.files[0]);
        }

        const newEntry = {
          // If editing, use the existing ID (SQLite will UPDATE)
          id: entryId ? parseInt(entryId) : undefined,
          date,
          pair,
          strategy,
          direction,
          result,
          pips,
          image,
          notes,
          timestamp: entryId ? journalEntries.find(e => e.id === parseInt(entryId)).timestamp : Date.now(),
        };

        try {
          // The addItem function handles both INSERT and UPDATE based on 'id' presence
          const newId = await addItem(STORE_ENTRIES, newEntry);
          newEntry.id = newId;

          if (entryId) {
            // Update mode: replace the old entry in the state
            const index = journalEntries.findIndex((e) => e.id === newEntry.id);
            if (index > -1) {
              journalEntries[index] = newEntry;
            }
            showToast("Trade updated successfully!");
          } else {
            // Insert mode: add to the front of the state
            journalEntries.unshift(newEntry);
            showToast("Trade saved successfully!");
          }

          // Update the list of pairs
          updateCurrencyPairs(pair);

          // Reset the form and re-render
          tradeForm.reset();
          resetFormForNewEntry();
          await renderJournalEntries();
        } catch (error) {
          console.error("Error saving/updating entry:", error);
          alert("Error saving trade: " + error.message);
        }
      });

      /**
       * Initializes image file listeners for preview/clearing.
       */
      function initImageListeners() {
        // Preview image on file selection
        imageFile.addEventListener("change", (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              imagePreview.src = e.target.result;
              imagePreviewContainer.classList.remove("hidden");
              imageDataField.value = ""; // Clear hidden field if new file is selected
            };
            reader.readAsDataURL(file);
          } else {
            imagePreviewContainer.classList.add("hidden");
            imagePreview.src = "";
          }
        });

        // Clear button to remove the image (either new or existing)
        clearImageBtn.addEventListener("click", () => {
          imageFile.value = "";
          imageDataField.value = "";
          imagePreview.src = "";
          imagePreviewContainer.classList.add("hidden");
        });
      }

      /**
       * Renders the list of journal entries.
       */
      async function renderJournalEntries() {
        const filterValue = filterText.value.toLowerCase();

        const filteredEntries = journalEntries.filter((entry) => {
          const searchString = `${entry.pair} ${entry.strategy} ${entry.notes || ""}`.toLowerCase();
          return searchString.includes(filterValue);
        });

        if (filteredEntries.length === 0) {
          entriesList.innerHTML = `<p class="text-center text-gray-500 dark:text-gray-400">No trades found.</p>`;
          return;
        }

        entriesList.innerHTML = filteredEntries
          .map(
            (entry) => `
              <div
                class="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg shadow flex flex-col sm:flex-row justify-between items-start sm:items-center border-l-4 ${
                  entry.result === "Win"
                    ? "border-green-500"
                    : entry.result === "Loss"
                    ? "border-red-500"
                    : "border-yellow-500"
                }"
              >
                <div class="flex-1 min-w-0">
                  <div class="flex items-center space-x-3 mb-1">
                    <span class="text-lg font-bold text-gray-900 dark:text-gray-100">${entry.pair}</span>
                    <span class="px-2 py-0.5 text-xs font-semibold rounded-full ${
                      entry.result === "Win"
                        ? "bg-green-100 text-green-800 dark:bg-green-800 dark:text-green-100"
                        : entry.result === "Loss"
                        ? "bg-red-100 text-red-800 dark:bg-red-800 dark:text-red-100"
                        : "bg-yellow-100 text-yellow-800 dark:bg-yellow-800 dark:text-yellow-100"
                    }">${entry.result}</span>
                    ${entry.pips !== null ? `<span class="text-sm text-gray-600 dark:text-gray-300">${entry.pips >= 0 ? "+" : ""}${entry.pips} pips</span>` : ""}
                  </div>
                  <p class="text-sm text-indigo-600 dark:text-indigo-400 font-medium mb-1">${entry.strategy}</p>
                  <p class="text-xs text-gray-500 dark:text-gray-400">${entry.date} - ${entry.direction}</p>
                  ${
                    entry.notes
                      ? `<p class="text-sm text-gray-700 dark:text-gray-300 mt-2 italic">${entry.notes}</p>`
                      : ""
                  }
                  ${
                    entry.image
                      ? `<img src="${entry.image}" alt="Trade Screenshot" class="mt-2 w-20 h-20 object-cover rounded-md cursor-pointer" onclick="viewImage('${entry.image}')" />`
                      : ""
                  }
                </div>
                <div class="flex space-x-2 mt-3 sm:mt-0">
                  <button
                    onclick="editEntry(${entry.id})"
                    class="text-indigo-600 hover:text-indigo-900 dark:text-indigo-400 dark:hover:text-indigo-200 text-sm font-semibold"
                  >
                    Edit
                  </button>
                  <button
                    onclick="deleteEntry(${entry.id})"
                    class="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-200 text-sm font-semibold"
                  >
                    Delete
                  </button>
                </div>
              </div>
            `
          )
          .join("");
      }

      /**
       * Fills the form with data for editing a trade entry.
       * @param {number} id - The ID of the entry to edit.
       */
      function editEntry(id) {
        const entry = journalEntries.find((e) => e.id === id);
        if (!entry) return;

        // Scroll to the form
        window.scrollTo({ top: 0, behavior: "smooth" });

        // Populate form fields
        document.getElementById("entryId").value = entry.id;
        document.getElementById("tradeDate").value = entry.date;
        document.getElementById("currencyPair").value = entry.pair;
        document.getElementById("strategy").value = entry.strategy;
        document.getElementById("direction").value = entry.direction;
        document.getElementById("result").value = entry.result;
        document.getElementById("pips").value = entry.pips;
        document.getElementById("notes").value = entry.notes;

        // Handle image field
        imageFile.value = ""; // Clear file input
        if (entry.image) {
          imageDataField.value = entry.image; // Store base64 in hidden field
          imagePreview.src = entry.image;
          imagePreviewContainer.classList.remove("hidden");
        } else {
          imageDataField.value = "";
          imagePreview.src = "";
          imagePreviewContainer.classList.add("hidden");
        }

        // Change button text and show cancel button
        const submitBtn = tradeForm.querySelector('button[type="submit"]');
        submitBtn.textContent = "Update Trade";
        submitBtn.classList.remove("bg-indigo-600");
        submitBtn.classList.add("bg-orange-500", "hover:bg-orange-600");
        cancelEditBtn.classList.remove("hidden");
      }

      /**
       * Deletes a trade entry by ID.
       * @param {number} id - The ID of the entry to delete.
       */
      async function deleteEntry(id) {
        if (!confirm("Are you sure you want to delete this trade entry?")) {
          return;
        }

        try {
          await deleteItem(STORE_ENTRIES, id);
          journalEntries = journalEntries.filter((e) => e.id !== id);
          await renderJournalEntries();
          showToast("Trade deleted.");
        } catch (error) {
          console.error("Error deleting entry:", error);
          alert("Error deleting trade: " + error.message);
        }
      }

      /**
       * Resets the form after editing or canceling an edit.
       */
      function resetFormForNewEntry() {
        document.getElementById("entryId").value = "";
        const submitBtn = tradeForm.querySelector('button[type="submit"]');
        submitBtn.textContent = "Save Trade";
        submitBtn.classList.remove("bg-orange-500", "hover:bg-orange-600");
        submitBtn.classList.add("bg-indigo-600");
        cancelEditBtn.classList.add("hidden");

        // Reset image fields
        imageFile.value = "";
        imageDataField.value = "";
        imagePreview.src = "";
        imagePreviewContainer.classList.add("hidden");
        document.getElementById("tradeDate").valueAsDate = new Date(); // Reset date to today
      }

      // Filter listener
      filterText.addEventListener("input", renderJournalEntries);
      cancelEditBtn.addEventListener("click", () => {
        tradeForm.reset();
        resetFormForNewEntry();
      });

      // =========================================================================================================================
      // 4. Strategy Management Logic
      // =========================================================================================================================

      /**
       * Handles strategy form submission (Add new strategy).
       */
      strategyForm.addEventListener("submit", async (e) => {
        e.preventDefault();

        const nameInput = document.getElementById("strategyName");
        const name = nameInput.value.trim();

        if (name && !tradingStrategies.some((s) => s.name === name)) {
          const newStrategy = { name: name, description: null };
          try {
            await addItem(STORE_STRATEGIES, newStrategy);
            tradingStrategies.push(newStrategy);
            tradingStrategies.sort((a, b) => a.name.localeCompare(b.name));
            renderStrategies();
            nameInput.value = "";
            showToast(`Strategy '${name}' added.`);
          } catch (error) {
            console.error("Error adding strategy:", error);
            alert("Error adding strategy: " + error.message);
          }
        }
      });

      /**
       * Renders the list of strategies in the management section and updates the select dropdown.
       */
      function renderStrategies() {
        // 1. Render management list
        strategyList.innerHTML = tradingStrategies
          .map(
            (s) => `
              <li class="flex justify-between items-center text-gray-700 dark:text-gray-300 p-2 hover:bg-gray-100 dark:hover:bg-gray-600 rounded-lg">
                <span>${s.name}</span>
                <button
                  onclick="deleteStrategy('${s.name.replace(/'/g, "\\'")}')"
                  class="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 text-sm font-semibold"
                >
                  Delete
                </button>
              </li>
            `
          )
          .join("");

        // 2. Update trade form dropdown
        strategySelect.innerHTML =
          '<option value="">Select a Strategy</option>' +
          tradingStrategies
            .map((s) => `<option value="${s.name}">${s.name}</option>`)
            .join("");
      }

      /**
       * Deletes a strategy by name.
       * @param {string} name - The name of the strategy to delete.
       */
      async function deleteStrategy(name) {
        // Check if any entries use this strategy
        const isUsed = journalEntries.some((e) => e.strategy === name);

        if (isUsed) {
          alert(
            `Cannot delete strategy "${name}" because it is currently used in one or more trade entries.`
          );
          return;
        }

        if (
          !confirm(`Are you sure you want to delete the strategy: "${name}"?`)
        ) {
          return;
        }

        try {
          await deleteItem(STORE_STRATEGIES, name);
          tradingStrategies = tradingStrategies.filter((s) => s.name !== name);
          renderStrategies();
          showToast(`Strategy '${name}' deleted.`);
        } catch (error) {
          console.error("Error deleting strategy:", error);
          alert("Error deleting strategy: " + error.message);
        }
      }

      // =========================================================================================================================
      // 5. Default Data and Utility Logic
      // =========================================================================================================================

      /**
       * Ensures default strategies are present on first run.
       */
      async function ensureDefaults() {
        if (tradingStrategies.length === 0) {
          const defaultStrategies = [
            { name: "Breakout", description: "Trading on price breaking key levels." },
            { name: "Reversal", description: "Trading on market turning points." },
            { name: "Trend Continuation", description: "Trading in the direction of the main trend." },
          ];

          for (const strategy of defaultStrategies) {
            await addItem(STORE_STRATEGIES, strategy);
          }
          tradingStrategies = defaultStrategies; // Update state after adding
        }
      }

      /**
       * Loads all entries and strategies from the database into state variables.
       */
      async function loadData() {
        tradingStrategies = await getAll(STORE_STRATEGIES);
        journalEntries = await getAll(STORE_ENTRIES);
        updateCurrencyPairs();
      }

      /**
       * Scans entries and populates the currency pair datalist.
       */
      function updateCurrencyPairs(newPair = null) {
        const pairs = new Set(journalEntries.map((e) => e.pair));
        if (newPair) {
          pairs.add(newPair);
        }
        currencyPairs = Array.from(pairs).sort();

        pairSuggestions.innerHTML = currencyPairs
          .map((pair) => `<option value="${pair}">`)
          .join("");
      }

      /**
       * Displays a toast notification.
       * @param {string} message
       */
      function showToast(message) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.classList.remove("hidden");
        toast.classList.add("opacity-100");

        setTimeout(() => {
          toast.classList.remove("opacity-100");
          toast.classList.add("opacity-0");
          setTimeout(() => toast.classList.add("hidden"), 300);
        }, 3000);
      }

      /**
       * Opens an image in a new tab/window (for viewing full size).
       * @param {string} base64Image
       */
      function viewImage(base64Image) {
        const newWindow = window.open();
        newWindow.document.write(
          `<img src="${base64Image}" style="max-width: 100%; height: auto;" />`
        );
        newWindow.document.title = "Trade Screenshot";
      }

      // =========================================================================================================================
      // 6. Data Import/Export Logic
      // =========================================================================================================================

      /**
       * Exports all trade entries as a CSV file.
       */
      exportBtn.addEventListener("click", () => {
        if (journalEntries.length === 0) {
          alert("No data to export.");
          return;
        }

        const dataToExport = journalEntries.map((entry) => ({
          ID: entry.id,
          Date: entry.date,
          Pair: entry.pair,
          Strategy: entry.strategy,
          Direction: entry.direction,
          Result: entry.result,
          Pips: entry.pips,
          Notes: entry.notes,
          Timestamp: entry.timestamp,
          // Base64 Image data is too long and complex for CSV, so we omit it for simplicity
          // Image_Base64: entry.image || "",
        }));

        const csv = Papa.unparse(dataToExport);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute(
          "download",
          `forex_journal_export_${new Date().toISOString().slice(0, 10)}.csv`
        );
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        showToast("Export successful!");
      });

      /**
       * Handles importing data from a CSV file.
       */
      importBtn.addEventListener("click", () => {
        if (
          !confirm(
            "Importing data will ADD new entries from the CSV. Ensure your CSV is correctly formatted. Continue?"
          )
        ) {
          return;
        }

        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".csv";
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (file) {
            Papa.parse(file, {
              header: true,
              skipEmptyLines: true,
              complete: async (results) => {
                const importedEntries = results.data
                  .filter((row) => row.Date && row.Pair && row.Strategy) // Basic validation
                  .map((row) => ({
                    // We generate a new ID and timestamp for imported items
                    date: row.Date,
                    pair: row.Pair.toUpperCase(),
                    strategy: row.Strategy,
                    direction: row.Direction || "Long",
                    result: row.Result || "Break Even",
                    pips: parseFloat(row.Pips) || null,
                    image: null, // Images are not imported via CSV for simplicity
                    notes: row.Notes || null,
                    timestamp: row.Timestamp ? parseInt(row.Timestamp) : Date.now(),
                  }));

                if (importedEntries.length === 0) {
                  alert("No valid entries found in the CSV file.");
                  return;
                }

                try {
                    let importedCount = 0;
                    for (const entry of importedEntries) {
                        // For imported data, we always treat them as new entries to get a new ID
                        const newId = await addItem(STORE_ENTRIES, entry);
                        entry.id = newId;
                        journalEntries.push(entry);
                        importedCount++;

                        // Add new strategies on the fly
                        if (!tradingStrategies.some(s => s.name === entry.strategy)) {
                            const newStrategy = { name: entry.strategy, description: 'Imported Strategy' };
                            await addItem(STORE_STRATEGIES, newStrategy);
                            tradingStrategies.push(newStrategy);
                        }
                    }

                    // Re-sort and re-render everything
                    journalEntries.sort((a, b) => b.timestamp - a.timestamp);
                    tradingStrategies.sort((a, b) => a.name.localeCompare(b.name));

                    updateCurrencyPairs();
                    renderStrategies();
                    await renderJournalEntries();

                    showToast(`Successfully imported ${importedCount} trade entries!`);
                } catch (error) {
                    console.error("Error during import:", error);
                    alert("Error during data import. Check console for details.");
                }
              },
            });
          }
        };
        input.click();
      });

      /**
       * Clears all data from both tables.
       */
      deleteAllBtn.addEventListener("click", async () => {
        if (
          !confirm(
            "WARNING: This action will permanently DELETE ALL trade entries and ALL strategies. Are you absolutely sure you want to continue? This also clears the previously used IndexedDB database."
          )
        ) {
          return;
        }

        try {
          // 1. Clear IndexedDB (to ensure old data is gone)
          await new Promise((resolve, reject) => {
                // Attempt to open and delete the old IndexedDB database
                const DB_REQUEST = indexedDB.open("ForexJournalDB"); // Assuming this was the old IndexedDB name
                DB_REQUEST.onsuccess = (event) => {
                    event.target.result.close();
                    const deleteRequest = indexedDB.deleteDatabase("ForexJournalDB");
                    deleteRequest.onsuccess = () => {
                        console.log("Old IndexedDB cleared.");
                        resolve();
                    };
                    deleteRequest.onerror = (e) => {
                         // This is often a non-critical error, e.g. if the old DB didn't exist
                        console.warn("Could not clear old IndexedDB:", e.target.error);
                        resolve();
                    };
                    deleteRequest.onblocked = () => {
                        console.warn("Could not clear old IndexedDB: Blocked.");
                        resolve();
                    };
                };
                DB_REQUEST.onerror = (e) => {
                    console.warn("Could not open old IndexedDB:", e.target.error);
                    resolve();
                };
            });

          // 2. Clear SQLite DB
          await Sqlite.execute({
              database: db,
              statements: `
                  DELETE FROM ${STORE_ENTRIES};
                  DELETE FROM ${STORE_STRATEGIES};
              `
          });
          
          // Optionally drop the database and recreate it for a complete clear, but DELETE FROM is usually sufficient.
          // await Sqlite.dropDatabase({ database: db });
          // await openDB();

          // Reset state
          journalEntries = [];
          tradingStrategies = [];
          await renderJournalEntries();
          renderStrategies();
          updateCurrencyPairs();
          await ensureDefaults(); // Re-add defaults after clearing

          showToast("All data has been cleared!");
        } catch (error) {
          console.error("Error clearing database:", error);
          alert("Error clearing all data: " + error.message);
        }
      });

      // =========================================================================================================================
      // 7. Initialization
      // =========================================================================================================================

      /**
       * Main initialization function for the app.
       */
      async function init() {
        const splash = document.getElementById("splash-screen");
        const ring = document.getElementById("splash-ring");
        const percentText = document.getElementById("splash-percent");
        const splashText = document.getElementById("splash-text");

        function updateSplash(progress, text) {
          const percent = Math.min(100, progress);
          const dashOffset = 283 - (283 * percent) / 100;
          ring.style.strokeDashoffset = dashOffset;
          percentText.textContent = `${percent}%`;
          splashText.textContent = text;
        }

        try {
          splash.style.display = "flex";
          updateSplash(0, "Opening database...");

          // 1. Open/Create SQLite DB and Tables
          await openDB();
          updateSplash(20, "Loading all data...");

          // 2. Load all data (strategies & entries)
          await loadData();
          updateSplash(40, "Ensuring default strategies...");

          // 3. Add default strategies if necessary
          await ensureDefaults();
          updateSplash(60, "Rendering strategies...");

          // 4. Render Strategies and Update Pair list
          renderStrategies();
          updateSplash(80, "Rendering journal entries...");

          // 5. Render Journal Entries
          await renderJournalEntries();
          updateSplash(90, "Setting up form...");

          // 6. Set default date to today and initialize listeners
          document.getElementById("tradeDate").valueAsDate = new Date();
          initImageListeners(); // Initialize image handlers
          updateSplash(100, "Ready!");
        } catch (err) {
          console.error("Initialization failed:", err);
          splashText.textContent = "Error loading app ðŸ˜ž";
          ring.classList.add("text-red-500");
        } finally {
          // Short pause for polish
          setTimeout(() => {
            splash.classList.add("opacity-0");
            setTimeout(() => splash.remove(), 700);
          }, 800);
        }
      }

      window.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>